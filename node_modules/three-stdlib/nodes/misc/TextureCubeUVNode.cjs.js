"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("../core/TempNode.cjs.js"),e=require("../core/ConstNode.cjs.js"),o=require("../core/StructNode.cjs.js"),n=require("../core/FunctionNode.cjs.js"),i=require("../core/FunctionCallNode.cjs.js"),r=require("../core/ExpressionNode.cjs.js"),c=require("../inputs/FloatNode.cjs.js"),s=require("../math/OperatorNode.cjs.js"),a=require("../math/MathNode.cjs.js"),u=require("../utils/ColorSpaceNode.cjs.js");function l(e,o,n){t.TempNode.call(this,"v4"),this.value=e,this.uv=o,this.bias=n}require("three"),require("../core/Node.cjs.js"),require("../core/NodeLib.cjs.js"),require("../core/InputNode.cjs.js"),l.Nodes=function(){var t=new o.StructNode("struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}"),i=new e.ConstNode("float cubeUV_maxMipLevel 8.0",!0),r=new e.ConstNode("float cubeUV_minMipLevel 4.0",!0),c=new e.ConstNode("float cubeUV_maxTileSize 256.0",!0),s=new e.ConstNode("float cubeUV_minTileSize 16.0",!0),a=new n.FunctionNode("float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}");a.useKeywords=!1;var u=new n.FunctionNode("vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}");u.useKeywords=!1;var l=new n.FunctionNode("TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}",[t,a,u,i,r,c,s]);l.useKeywords=!1;var d=new e.ConstNode("float r0 1.0",!0),p=new e.ConstNode("float v0 0.339",!0),v=new e.ConstNode("float m0 -2.0",!0),f=[d,p,v,new e.ConstNode("float r1 0.8",!0),new e.ConstNode("float v1 0.276",!0),new e.ConstNode("float m1 -1.0",!0),new e.ConstNode("float r4 0.4",!0),new e.ConstNode("float v4 0.046",!0),new e.ConstNode("float m4 2.0",!0),new e.ConstNode("float r5 0.305",!0),new e.ConstNode("float v5 0.016",!0),new e.ConstNode("float m5 3.0",!0),new e.ConstNode("float r6 0.21",!0),new e.ConstNode("float v6 0.0038",!0),new e.ConstNode("float m6 4.0",!0)];return{bilinearCubeUV:l,roughnessToMip:new n.FunctionNode("float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}",f),m0:v,cubeUV_maxMipLevel:i}}(),l.prototype=Object.create(t.TempNode.prototype),l.prototype.constructor=l,l.prototype.nodeType="TextureCubeUV",l.prototype.bilinearCubeUV=function(t,e,o,n){var c=new i.FunctionCallNode(l.Nodes.bilinearCubeUV,[e,o,n]);this.colorSpaceTL=this.colorSpaceTL||new u.ColorSpaceNode(new r.ExpressionNode("","v4")),this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(c.build(t)+".tl"),this.colorSpaceTR=this.colorSpaceTR||new u.ColorSpaceNode(new r.ExpressionNode("","v4")),this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(c.build(t)+".tr"),this.colorSpaceBL=this.colorSpaceBL||new u.ColorSpaceNode(new r.ExpressionNode("","v4")),this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(c.build(t)+".bl"),this.colorSpaceBR=this.colorSpaceBR||new u.ColorSpaceNode(new r.ExpressionNode("","v4")),this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(c.build(t)+".br");var s={include:t.isShader("vertex"),ignoreCache:!0};t.addContext(s),this.colorSpaceTLExp=new r.ExpressionNode(this.colorSpaceTL.build(t,"v4"),"v4"),this.colorSpaceTRExp=new r.ExpressionNode(this.colorSpaceTR.build(t,"v4"),"v4"),this.colorSpaceBLExp=new r.ExpressionNode(this.colorSpaceBL.build(t,"v4"),"v4"),this.colorSpaceBRExp=new r.ExpressionNode(this.colorSpaceBR.build(t,"v4"),"v4"),t.removeContext();var a=new r.ExpressionNode("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return a.keywords.cubeUV_TL=this.colorSpaceTLExp,a.keywords.cubeUV_TR=this.colorSpaceTRExp,a.keywords.cubeUV_BL=this.colorSpaceBLExp,a.keywords.cubeUV_BR=this.colorSpaceBRExp,a.keywords.cubeUV=c,a},l.prototype.generate=function(t,e){if(t.isShader("fragment")){var o=this.uv,n=this.bias||t.context.roughness,r=new i.FunctionCallNode(l.Nodes.roughnessToMip,[n]),u=new a.MathNode(r,l.Nodes.m0,l.Nodes.cubeUV_maxMipLevel,a.MathNode.CLAMP),d=new a.MathNode(u,a.MathNode.FLOOR),p=new a.MathNode(u,a.MathNode.FRACT),v=this.bilinearCubeUV(t,this.value,o,d),f=this.bilinearCubeUV(t,this.value,o,new s.OperatorNode(d,new c.FloatNode(1).setReadonly(!0),s.OperatorNode.ADD)),b=new a.MathNode(v,f,p,a.MathNode.MIX);return t.format(b.build(t),"v4",e)}return console.warn("THREE.TextureCubeUVNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)},l.prototype.toJSON=function(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).value=this.value.toJSON(t).uuid,e.uv=this.uv.toJSON(t).uuid,e.bias=this.bias.toJSON(t).uuid),e},exports.TextureCubeUVNode=l;
