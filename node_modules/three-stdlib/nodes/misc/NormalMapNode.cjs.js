"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),t=require("../core/TempNode.cjs.js"),o=require("../inputs/Vector2Node.cjs.js"),r=require("../core/FunctionNode.cjs.js"),s=require("../accessors/UVNode.cjs.js"),n=require("../accessors/NormalNode.cjs.js"),i=require("../accessors/PositionNode.cjs.js");function a(e,r){t.TempNode.call(this,"v3"),this.value=e,this.scale=r||new o.Vector2Node(1,1)}require("../core/Node.cjs.js"),require("../core/InputNode.cjs.js"),require("../core/NodeUtils.cjs.js"),require("../core/NodeLib.cjs.js"),a.Nodes={perturbNormal2Arb:new r.FunctionNode("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = map * 2.0 - 1.0;\n\n\t\tmapN.xy *= normalScale;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n\t\t\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\n\n\t\t#else\n\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}",null,{derivatives:!0})},a.prototype=Object.create(t.TempNode.prototype),a.prototype.constructor=a,a.prototype.nodeType="NormalMap",a.prototype.generate=function(t,o){if(t.isShader("fragment")){var r=t.include(a.Nodes.perturbNormal2Arb);this.normal=this.normal||new n.NormalNode,this.position=this.position||new i.PositionNode(i.PositionNode.VIEW),this.uv=this.uv||new s.UVNode;var c=this.scale.build(t,"v2");return t.material.side===e.BackSide&&(c="-"+c),t.format(r+"( -"+this.position.build(t,"v3")+", "+this.normal.build(t,"v3")+", "+this.value.build(t,"v3")+", "+this.uv.build(t,"v2")+", "+c+" )",this.getType(t),o)}return console.warn("THREE.NormalMapNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),o)},a.prototype.copy=function(e){return t.TempNode.prototype.copy.call(this,e),this.value=e.value,this.scale=e.scale,this},a.prototype.toJSON=function(e){var t=this.getJSONNode(e);return t||((t=this.createJSONNode(e)).value=this.value.toJSON(e).uuid,t.scale=this.scale.toJSON(e).uuid),t},exports.NormalMapNode=a;
