"use strict";var e=require("three"),t=require("./types/helpers.cjs.js"),r=function(t,r){var i=null!==t[0].index,a=new Set(Object.keys(t[0].attributes)),n=new Set(Object.keys(t[0].morphAttributes)),s={},u={},f=t[0].morphTargetsRelative,l=new e.BufferGeometry,m=0;if(t.forEach((function(e,t){var o=0;if(i!==(null!==e.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var g in e.attributes){if(!a.has(g))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+g+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[g]&&(s[g]=[]),s[g].push(e.attributes[g]),o++}if(o!==a.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(f!==e.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var c in e.morphAttributes){if(!n.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[c]&&(u[c]=[]),u[c].push(e.morphAttributes[c])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(e.userData),r){var d;if(e.index)d=e.index.count;else{if(void 0===e.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;d=e.attributes.position.count}l.addGroup(m,d,t),m+=d}})),i){var g=0,c=[];t.forEach((function(e){for(var t=e.index,r=0;r<t.count;++r)c.push(t.getX(r)+g);g+=e.attributes.position.count})),l.setIndex(c)}for(var d in s){var h=o(s[d]);if(!h)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+d+" attribute."),null;l.setAttribute(d,h)}for(var b in u){var p=u[b][0].length;if(0===p)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[b]=[];for(var v=0;v<p;++v){for(var y=[],A=0;A<u[b].length;++A)y.push(u[b][A][v]);var B=o(y);if(!B)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+b+" morphAttribute."),null;l.morphAttributes[b].push(B)}}return l},o=function(t){var r=void 0,o=void 0,i=void 0,a=0;if(t.forEach((function(e){return void 0===r&&(r=e.array.constructor),r!==e.array.constructor?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null):(void 0===o&&(o=e.itemSize),o!==e.itemSize?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null):(void 0===i&&(i=e.normalized),i!==e.normalized?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null):void(a+=e.array.length)))})),r&&o){var n=new r(a),s=0;return t.forEach((function(e){n.set(e.array,s),s+=e.array.length})),new e.BufferAttribute(n,o,i)}},i=function(r){for(var o=void 0,i=0,a=0,n=0,s=r.length;n<s;++n){var u=r[n];if(void 0===o&&(o=u.array.constructor),o!==u.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;i+=u.array.length,a+=u.itemSize}for(var f=new e.InterleavedBuffer(new o(i),a),l=0,m=[],g=["getX","getY","getZ","getW"],c=["setX","setY","setZ","setW"],d=0,h=r.length;d<h;d++){var b=r[d],p=b.itemSize,v=b.count,y=new e.InterleavedBufferAttribute(f,p,l,b.normalized);m.push(y),l+=p;for(var A=0;A<v;A++)for(var B=0;B<p;B++){t.getWithKey(y,c[B])(A,t.getWithKey(b,g[B])(A))}}return m};function a(e){var t=0;for(var r in e.attributes){var o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}var i=e.getIndex();return t+=i?i.count*i.itemSize*i.array.BYTES_PER_ELEMENT:0}function n(t,r){void 0===r&&(r=1e-4),r=Math.max(r,Number.EPSILON);for(var o={},i=t.getIndex(),a=t.getAttribute("position"),n=i?i.count:a.count,s=0,u=Object.keys(t.attributes),f={},l={},m=[],g=["getX","getY","getZ","getW"],c=0,d=u.length;c<d;c++){var h=u[c];f[h]=[];var b=t.morphAttributes[h];b&&(l[h]=new Array(b.length).fill(0).map((function(){return[]})))}for(var p=Math.log10(1/r),v=Math.pow(10,p),y=0;y<n;y++){for(var A=i?i.getX(y):y,B="",w=0,E=u.length;w<E;w++)for(var x=u[w],T=t.getAttribute(x),G=T.itemSize,M=0;M<G;M++)B+=~~(T[g[M]](A)*v)+",";if(B in o)m.push(o[B]);else{for(var S=0,U=u.length;S<U;S++)for(var z=u[S],R=t.getAttribute(z),X=t.morphAttributes[z],D=R.itemSize,V=f[z],H=l[z],I=0;I<D;I++){var k=g[I];if(V.push(R[k](A)),X)for(var _=0,j=X.length;_<j;_++)H[_].push(X[_][k](A))}o[B]=s,m.push(s),s++}}for(var F=t.clone(),N=0,O=u.length;N<O;N++){var P=u[N],W=t.getAttribute(P),Y=new W.array.constructor(f[P]),L=new e.BufferAttribute(Y,W.itemSize,W.normalized);if(F.setAttribute(P,L),P in l)for(var Z=0;Z<l[P].length;Z++){var q=t.morphAttributes[P][Z],K=new q.array.constructor(l[P][Z]),C=new e.BufferAttribute(K,q.itemSize,q.normalized);F.morphAttributes[P][Z]=C}}return F.setIndex(m),F}function s(t,r){if(r===e.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){var o=t.getIndex();if(null===o){var i=[],a=t.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(var n=0;n<a.count;n++)i.push(n);t.setIndex(i),o=t.getIndex()}var s=o.count-2,u=[];if(o)if(r===e.TriangleFanDrawMode)for(var f=1;f<=s;f++)u.push(o.getX(0)),u.push(o.getX(f)),u.push(o.getX(f+1));else for(var l=0;l<s;l++)l%2==0?(u.push(o.getX(l)),u.push(o.getX(l+1)),u.push(o.getX(l+2))):(u.push(o.getX(l+2)),u.push(o.getX(l+1)),u.push(o.getX(l)));u.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var m=t.clone();return m.setIndex(u),m.clearGroups(),m}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),t}function u(t){if(!0!==t.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;var r=new e.Vector3,o=new e.Vector3,i=new e.Vector3,a=new e.Vector3,n=new e.Vector3,s=new e.Vector3,u=new e.Vector3,f=new e.Vector3,l=new e.Vector3;function m(e,t,m,g,c,d,h,b,p){r.fromBufferAttribute(m,d),o.fromBufferAttribute(m,h),i.fromBufferAttribute(m,b);var v=e.morphTargetInfluences;if(t.morphTargets&&g&&v){u.set(0,0,0),f.set(0,0,0),l.set(0,0,0);for(var y=0,A=g.length;y<A;y++){var B=v[y],w=g[y];0!==B&&(a.fromBufferAttribute(w,d),n.fromBufferAttribute(w,h),s.fromBufferAttribute(w,b),c?(u.addScaledVector(a,B),f.addScaledVector(n,B),l.addScaledVector(s,B)):(u.addScaledVector(a.sub(r),B),f.addScaledVector(n.sub(o),B),l.addScaledVector(s.sub(i),B)))}r.add(u),o.add(f),i.add(l)}e.isSkinnedMesh&&(e.boneTransform(d,r),e.boneTransform(h,o),e.boneTransform(b,i)),p[3*d+0]=r.x,p[3*d+1]=r.y,p[3*d+2]=r.z,p[3*h+0]=o.x,p[3*h+1]=o.y,p[3*h+2]=o.z,p[3*b+0]=i.x,p[3*b+1]=i.y,p[3*b+2]=i.z}var g,c,d,h,b,p,v,y,A,B=t.geometry,w=t.material,E=B.index,x=B.attributes.position,T=B.morphAttributes.position,G=B.morphTargetsRelative,M=B.attributes.normal,S=B.morphAttributes.position,U=B.groups,z=B.drawRange,R=new Float32Array(x.count*x.itemSize),X=new Float32Array(M.count*M.itemSize);if(null!==E)if(Array.isArray(w))for(h=0,p=U.length;h<p;h++)for(A=w[(y=U[h]).materialIndex],b=Math.max(y.start,z.start),v=Math.min(y.start+y.count,z.start+z.count);b<v;b+=3)m(t,A,x,T,G,g=E.getX(b),c=E.getX(b+1),d=E.getX(b+2),R),m(t,A,M,S,G,g,c,d,X);else for(h=Math.max(0,z.start),p=Math.min(E.count,z.start+z.count);h<p;h+=3)m(t,w,x,T,G,g=E.getX(h),c=E.getX(h+1),d=E.getX(h+2),R),m(t,w,M,S,G,g,c,d,X);else if(void 0!==x)if(Array.isArray(w))for(h=0,p=U.length;h<p;h++)for(A=w[(y=U[h]).materialIndex],b=Math.max(y.start,z.start),v=Math.min(y.start+y.count,z.start+z.count);b<v;b+=3)m(t,A,x,T,G,g=b,c=b+1,d=b+2,R),m(t,A,M,S,G,g,c,d,X);else for(h=Math.max(0,z.start),p=Math.min(x.count,z.start+z.count);h<p;h+=3)m(t,w,x,T,G,g=h,c=h+1,d=h+2,R),m(t,w,M,S,G,g,c,d,X);return{positionAttribute:x,normalAttribute:M,morphedPositionAttribute:new e.Float32BufferAttribute(R,3),morphedNormalAttribute:new e.Float32BufferAttribute(X,3)}}var f=Object.freeze({__proto__:null,mergeBufferGeometries:r,mergeBufferAttributes:o,interleaveAttributes:i,estimateBytesUsed:a,mergeVertices:n,toTrianglesDrawMode:s,computeMorphedAttributes:u});exports.BufferGeometryUtils=f,exports.computeMorphedAttributes=u,exports.estimateBytesUsed=a,exports.interleaveAttributes=i,exports.mergeBufferAttributes=o,exports.mergeBufferGeometries=r,exports.mergeVertices=n,exports.toTrianglesDrawMode=s;
