"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/assertThisInitialized"),t=require("@babel/runtime/helpers/inheritsLoose"),n=require("@babel/runtime/helpers/defineProperty"),r=require("three");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var a=i(e),o=i(t),s=i(n),f=function(e){void 0===e&&(e=1);var t=new Float32Array(4096*e*3),n=new r.DataTexture(t,1024,4*e,r.RGBFormat,r.FloatType);return n.wrapS=r.RepeatWrapping,n.wrapT=r.RepeatWrapping,n.magFilter=r.NearestFilter,n.needsUpdate=!0,n},u=function(e,t,n){void 0===n&&(n=0);var r=Math.floor(1024);t.arcLengthDivisions=r/2,t.updateArcLengths();for(var i=t.getSpacedPoints(r),a=t.computeFrenetFrames(r,!0),o=0;o<r;o++){var s=Math.floor(o/1024),f=o%1024,u=i[o];l(e,f,u.x,u.y,u.z,0+s+4*n),u=a.tangents[o],l(e,f,u.x,u.y,u.z,1+s+4*n),u=a.normals[o],l(e,f,u.x,u.y,u.z,2+s+4*n),u=a.binormals[o],l(e,f,u.x,u.y,u.z,3+s+4*n)}e.needsUpdate=!0},l=function(e,t,n,r,i,a){var o=e.image.data,s=3072*a;o[3*t+s+0]=n,o[3*t+s+1]=r,o[3*t+s+2]=i};function c(e){return{spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}}}function p(e,t,n){void 0===n&&(n=1),e.__ok||(e.__ok=!0,e.onBeforeCompile=function(e){if(!e.__modified){e.__modified=!0,Object.assign(e.uniforms,t);var r=("\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = "+4*n+".;\n\t\tfloat textureStacks = 1.;\n\n\t\t"+e.vertexShader+"\n\t\t").replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,"\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * 4.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t").replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=r}})}var h=function(){function e(e,t){void 0===t&&(t=1),s.default(this,"curveArray",void 0),s.default(this,"curveLengthArray",void 0),s.default(this,"object3D",void 0),s.default(this,"splineTexure",void 0),s.default(this,"uniforms",void 0);var n=e.clone(),i=f(t),a=c(i);n.traverse((function(e){(e instanceof r.Mesh||e instanceof r.InstancedMesh)&&(e.material=e.material.clone(),p(e.material,a,t))})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=n,this.splineTexure=i,this.uniforms=a}var t=e.prototype;return t.updateCurve=function(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");var n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,u(this.splineTexure,t,e)},t.moveAlongCurve=function(e){this.uniforms.pathOffset.value+=e},e}(),v=new r.Matrix4,d=function(e){function t(t,n,i,o){var f,u=new r.InstancedMesh(i,o,t);return u.instanceMatrix.setUsage(r.DynamicDrawUsage),f=e.call(this,u,n)||this,s.default(a.default(f),"offsets",void 0),s.default(a.default(f),"whichCurve",void 0),f.offsets=new Array(t).fill(0),f.whichCurve=new Array(t).fill(0),f}o.default(t,e);var n=t.prototype;return n.writeChanges=function(e){v.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,v),this.object3D.instanceMatrix.needsUpdate=!0},n.moveIndividualAlongCurve=function(e,t){this.offsets[e]+=t,this.writeChanges(e)},n.setCurve=function(e,t){if(isNaN(t))throw Error("curve index being set is Not a Number (NaN)");this.whichCurve[e]=t,this.writeChanges(e)},t}(h);exports.Flow=h,exports.InstancedFlow=d,exports.getUniforms=c,exports.initSplineTexture=f,exports.modifyShader=p,exports.updateSplineTexture=u;
