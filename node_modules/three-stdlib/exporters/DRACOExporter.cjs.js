"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=function(){};e.prototype={constructor:e,parse:function(o,t){if(!0===o.isBufferGeometry)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_decoder to work.");void 0===t&&(t={decodeSpeed:5,encodeSpeed:5,encoderMethod:e.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});var r,i,n=o.geometry,d=DracoEncoderModule(),a=new d.Encoder;if(!0!==n.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");if(!0===o.isMesh){r=new d.MeshBuilder,i=new d.Mesh;var u=n.getAttribute("position");if(r.AddFloatAttributeToMesh(i,d.POSITION,u.count,u.itemSize,u.array),null!==(s=n.getIndex()))r.AddFacesToMesh(i,s.count/3,s.array);else{for(var s=new(u.count>65535?Uint32Array:Uint16Array)(u.count),c=0;c<s.length;c++)s[c]=c;r.AddFacesToMesh(i,u.count,s)}if(!0===t.exportNormals){var E=n.getAttribute("normal");void 0!==E&&r.AddFloatAttributeToMesh(i,d.NORMAL,E.count,E.itemSize,E.array)}if(!0===t.exportUvs){var A=n.getAttribute("uv");void 0!==A&&r.AddFloatAttributeToMesh(i,d.TEX_COORD,A.count,A.itemSize,A.array)}if(!0===t.exportColor)void 0!==(p=n.getAttribute("color"))&&r.AddFloatAttributeToMesh(i,d.COLOR,p.count,p.itemSize,p.array)}else{if(!0!==o.isPoints)throw new Error("DRACOExporter: Unsupported object type.");r=new d.PointCloudBuilder,i=new d.PointCloud;var p;u=n.getAttribute("position");r.AddFloatAttribute(i,d.POSITION,u.count,u.itemSize,u.array),!0===t.exportColor&&void 0!==(p=n.getAttribute("color"))&&r.AddFloatAttribute(i,d.COLOR,p.count,p.itemSize,p.array)}var f,O=new d.DracoInt8Array,l=void 0!==t.encodeSpeed?t.encodeSpeed:5,v=void 0!==t.decodeSpeed?t.decodeSpeed:5;if(a.SetSpeedOptions(l,v),void 0!==t.encoderMethod&&a.SetEncodingMethod(t.encoderMethod),void 0!==t.quantization)for(var y=0;y<5;y++)void 0!==t.quantization[y]&&a.SetAttributeQuantization(y,t.quantization[y]);if(f=!0===o.isMesh?a.EncodeMeshToDracoBuffer(i,O):a.EncodePointCloudToDracoBuffer(i,!0,O),d.destroy(i),0===f)throw new Error("THREE.DRACOExporter: Draco encoding failed.");for(var M=new Int8Array(new ArrayBuffer(f)),h=0;h<f;h++)M[h]=O.GetValue(h);return d.destroy(O),d.destroy(a),d.destroy(r),M}},e.MESH_EDGEBREAKER_ENCODING=1,e.MESH_SEQUENTIAL_ENCODING=0,e.POINT_CLOUD=0,e.TRIANGULAR_MESH=1,e.INVALID=-1,e.POSITION=0,e.NORMAL=1,e.COLOR=2,e.TEX_COORD=3,e.GENERIC=4,exports.DRACOExporter=e;
