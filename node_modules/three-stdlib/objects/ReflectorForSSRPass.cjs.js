"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),t=function t(r,n){e.Mesh.call(this,r),this.type="ReflectorForSSRPass";var a=this,i=void 0!==(n=n||{}).color?new e.Color(n.color):new e.Color(8355711),o=n.textureWidth||512,s=n.textureHeight||512,l=n.clipBias||0,u=n.shader||t.ReflectorShader,c=n.useDepthTexture,d=new e.Vector3(0,1,0),f=new e.Vector3,p=new e.Vector3;a.needsUpdate=!1,a.maxDistance=t.ReflectorShader.uniforms.maxDistance.value,a.opacity=t.ReflectorShader.uniforms.opacity.value,a._isDistanceAttenuation=t.ReflectorShader.defines.isDistanceAttenuation,Object.defineProperty(a,"isDistanceAttenuation",{get:function(){return a._isDistanceAttenuation},set:function(e){a._isDistanceAttenuation!==e&&(a._isDistanceAttenuation=e,a.material.defines.isDistanceAttenuation=e,a.material.needsUpdate=!0)}}),a._isFresnel=t.ReflectorShader.defines.isFresnel,Object.defineProperty(a,"isFresnel",{get:function(){return a._isFresnel},set:function(e){a._isFresnel!==e&&(a._isFresnel=e,a.material.defines.isFresnel=e,a.material.needsUpdate=!0)}});var m=new e.Plane,v=new e.Vector3,x=new e.Vector3,h=new e.Vector3,y=new e.Matrix4,b=new e.Vector3(0,0,-1),g=new e.Vector4,D=new e.Vector3,w=new e.Vector3,M=new e.Vector4,F=new e.Matrix4,R=new e.PerspectiveCamera;if(c){var S=new e.DepthTexture;S.type=e.UnsignedShortType,S.minFilter=e.NearestFilter,S.maxFilter=e.NearestFilter}var U={minFilter:e.LinearFilter,magFilter:e.LinearFilter,format:e.RGBFormat,depthTexture:c?S:null},P=new e.WebGLRenderTarget(o,s,U);e.MathUtils.isPowerOfTwo(o)&&e.MathUtils.isPowerOfTwo(s)||(P.texture.generateMipmaps=!1);var O=new e.ShaderMaterial({transparent:c,defines:Object.assign({useDepthTexture:c},t.ReflectorShader.defines),uniforms:e.UniformsUtils.clone(u.uniforms),fragmentShader:u.fragmentShader,vertexShader:u.vertexShader});O.uniforms.tDiffuse.value=P.texture,O.uniforms.color.value=i,O.uniforms.textureMatrix.value=F,c&&(O.uniforms.tDepth.value=P.depthTexture),this.material=O,this.doRender=function(e,t,r){if(O.uniforms.maxDistance.value=a.maxDistance*(r.position.length()/r.position.y),O.uniforms.opacity.value=a.opacity,f.copy(r.position).normalize(),p.copy(f).reflect(d),O.uniforms.fresnel.value=(f.dot(p)+1)/2,x.setFromMatrixPosition(a.matrixWorld),h.setFromMatrixPosition(r.matrixWorld),y.extractRotation(a.matrixWorld),v.set(0,0,1),v.applyMatrix4(y),D.subVectors(x,h),!(D.dot(v)>0)){D.reflect(v).negate(),D.add(x),y.extractRotation(r.matrixWorld),b.set(0,0,-1),b.applyMatrix4(y),b.add(h),w.subVectors(x,b),w.reflect(v).negate(),w.add(x),R.position.copy(D),R.up.set(0,1,0),R.up.applyMatrix4(y),R.up.reflect(v),R.lookAt(w),R.far=r.far,R.updateMatrixWorld(),R.projectionMatrix.copy(r.projectionMatrix),F.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),F.multiply(R.projectionMatrix),F.multiply(R.matrixWorldInverse),F.multiply(a.matrixWorld),m.setFromNormalAndCoplanarPoint(v,x),m.applyMatrix4(R.matrixWorldInverse),g.set(m.normal.x,m.normal.y,m.normal.z,m.constant);var n=R.projectionMatrix;M.x=(Math.sign(g.x)+n.elements[8])/n.elements[0],M.y=(Math.sign(g.y)+n.elements[9])/n.elements[5],M.z=-1,M.w=(1+n.elements[10])/n.elements[14],g.multiplyScalar(2/g.dot(M)),n.elements[2]=g.x,n.elements[6]=g.y,n.elements[10]=g.z+1-l,n.elements[14]=g.w,P.texture.encoding=e.outputEncoding;var i=e.getRenderTarget(),o=e.xr.enabled,s=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(P),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,R),e.xr.enabled=o,e.shadowMap.autoUpdate=s,e.setRenderTarget(i);var u=r.viewport;void 0!==u&&e.state.viewport(u)}},this.getRenderTarget=function(){return P}};(t.prototype=Object.create(e.Mesh.prototype)).constructor=t,t.ReflectorShader={defines:{isDistanceAttenuation:!0,isFresnel:!0},uniforms:{color:{value:null},tDiffuse:{value:null},tDepth:{value:null},textureMatrix:{value:null},maxDistance:{value:180},opacity:{value:.5},fresnel:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnel;\n\t\tvarying vec4 vUv;\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tfloat op=opacity;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tif(depth>maxDistance) discard;\n\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\tfloat ratio=1.-(depth/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef isFresnel\n\t\t\t\t\top*=fresnel;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t"},exports.ReflectorForSSRPass=t;
