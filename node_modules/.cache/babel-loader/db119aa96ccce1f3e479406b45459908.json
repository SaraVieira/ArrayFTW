{"ast":null,"code":"import _regeneratorRuntime from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read } from 'ktx-parse';\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nvar DFDModel = {\n  ETC1S: 163,\n  UASTC: 166\n};\nvar DFDChannel = {\n  ETC1S: {\n    RGB: 0,\n    RRR: 3,\n    GGG: 4,\n    AAA: 15\n  },\n  UASTC: {\n    RGB: 0,\n    RGBA: 3,\n    RRR: 4,\n    RRRG: 5\n  }\n};\nvar SupercompressionScheme = {\n  ZSTD: 2\n};\nvar Transfer = {\n  SRGB: 2\n}; //\n\nvar KTX2Loader = /*#__PURE__*/function (_CompressedTextureLoa) {\n  _inherits(KTX2Loader, _CompressedTextureLoa);\n\n  var _super = _createSuper(KTX2Loader);\n\n  function KTX2Loader(manager) {\n    var _this;\n\n    _classCallCheck(this, KTX2Loader);\n\n    _this = _super.call(this, manager);\n    _this.basisLoader = new BasisTextureLoader(manager);\n    _this.zstd = new ZSTDDecoder();\n\n    _this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n\n    return _this;\n  }\n\n  _createClass(KTX2Loader, [{\n    key: \"setTranscoderPath\",\n    value: function setTranscoderPath(path) {\n      this.basisLoader.setTranscoderPath(path);\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(path) {\n      this.basisLoader.setWorkerLimit(path);\n      return this;\n    }\n  }, {\n    key: \"detectSupport\",\n    value: function detectSupport(renderer) {\n      this.basisLoader.detectSupport(renderer);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.basisLoader.dispose();\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var texture = new CompressedTexture();\n      var bufferPending = new Promise(function (resolve, reject) {\n        new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n      });\n      bufferPending.then(function (buffer) {\n        scope.parse(buffer, function (_texture) {\n          texture.copy(_texture);\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }, onError);\n      }).catch(onError);\n      return texture;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(buffer, onLoad, onError) {\n      var scope = this;\n      var ktx = read(new Uint8Array(buffer));\n\n      if (ktx.pixelDepth > 0) {\n        throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n      }\n\n      if (ktx.layerCount > 1) {\n        throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n      }\n\n      if (ktx.faceCount > 1) {\n        throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n      }\n\n      var dfd = KTX2Utils.getBasicDFD(ktx);\n      KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n        var basisFormat = dfd.colorModel === DFDModel.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n        var parseConfig = {\n          levels: levels,\n          width: ktx.pixelWidth,\n          height: ktx.pixelHeight,\n          basisFormat: basisFormat,\n          hasAlpha: KTX2Utils.getAlpha(ktx)\n        };\n\n        if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n          parseConfig.globalData = ktx.globalData;\n        }\n\n        return scope.basisLoader.parseInternalAsync(parseConfig);\n      }).then(function (texture) {\n        texture.encoding = dfd.transferFunction === Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n        texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n        onLoad(texture);\n      }).catch(onError);\n      return this;\n    }\n  }]);\n\n  return KTX2Loader;\n}(CompressedTextureLoader);\n\nvar KTX2Utils = {\n  createLevels: function () {\n    var _createLevels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ktx, zstd) {\n      var levels, width, height, levelIndex, levelWidth, levelHeight, levelData;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(ktx.supercompressionScheme === SupercompressionScheme.ZSTD)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return zstd.init();\n\n            case 3:\n              levels = [];\n              width = ktx.pixelWidth;\n              height = ktx.pixelHeight;\n\n              for (levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n                levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n                levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n                levelData = ktx.levels[levelIndex].levelData;\n\n                if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n                  levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n                }\n\n                levels.push({\n                  index: levelIndex,\n                  width: levelWidth,\n                  height: levelHeight,\n                  data: levelData\n                });\n              }\n\n              return _context.abrupt(\"return\", levels);\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function createLevels(_x, _x2) {\n      return _createLevels.apply(this, arguments);\n    }\n\n    return createLevels;\n  }(),\n  getBasicDFD: function getBasicDFD(ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function getAlpha(ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === DFDModel.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === DFDChannel.UASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === DFDChannel.ETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function getPremultiplyAlpha(ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & 1);\n  }\n};\nexport { KTX2Loader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/KTX2Loader.js"],"names":["CompressedTextureLoader","CompressedTexture","FileLoader","sRGBEncoding","LinearEncoding","BasisTextureLoader","ZSTDDecoder","read","DFDModel","ETC1S","UASTC","DFDChannel","RGB","RRR","GGG","AAA","RGBA","RRRG","SupercompressionScheme","ZSTD","Transfer","SRGB","KTX2Loader","manager","basisLoader","zstd","init","MSC_TRANSCODER","console","warn","path","setTranscoderPath","setWorkerLimit","renderer","detectSupport","dispose","url","onLoad","onProgress","onError","scope","texture","bufferPending","Promise","resolve","reject","setPath","setResponseType","load","then","buffer","parse","_texture","copy","needsUpdate","catch","ktx","Uint8Array","pixelDepth","Error","layerCount","faceCount","dfd","KTX2Utils","getBasicDFD","createLevels","levels","basisFormat","colorModel","BasisFormat","UASTC_4x4","parseConfig","width","pixelWidth","height","pixelHeight","hasAlpha","getAlpha","globalData","parseInternalAsync","encoding","transferFunction","premultiplyAlpha","getPremultiplyAlpha","supercompressionScheme","levelIndex","length","levelWidth","Math","max","floor","pow","levelHeight","levelData","decode","uncompressedByteLength","push","index","data","dataFormatDescriptor","samples","channelID","flags"],"mappings":"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","sourcesContent":["import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read } from 'ktx-parse';\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nvar DFDModel = {\n  ETC1S: 163,\n  UASTC: 166\n};\nvar DFDChannel = {\n  ETC1S: {\n    RGB: 0,\n    RRR: 3,\n    GGG: 4,\n    AAA: 15\n  },\n  UASTC: {\n    RGB: 0,\n    RGBA: 3,\n    RRR: 4,\n    RRRG: 5\n  }\n};\nvar SupercompressionScheme = {\n  ZSTD: 2\n};\nvar Transfer = {\n  SRGB: 2\n}; //\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === DFDModel.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n\n    for (let levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n\n      if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === DFDModel.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === DFDChannel.UASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === DFDChannel.ETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & 1);\n  }\n};\n\nexport { KTX2Loader };\n"]},"metadata":{},"sourceType":"module"}