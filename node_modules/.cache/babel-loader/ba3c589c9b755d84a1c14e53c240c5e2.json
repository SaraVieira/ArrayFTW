{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\n\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      frustrum = _ref.frustrum,\n      _ref$frustum = _ref.frustum,\n      frustum = _ref$frustum === void 0 ? 3.75 : _ref$frustum,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0.005 : _ref$size,\n      _ref$near = _ref.near,\n      near = _ref$near === void 0 ? 9.5 : _ref$near,\n      _ref$samples = _ref.samples,\n      samples = _ref$samples === void 0 ? 17 : _ref$samples,\n      _ref$rings = _ref.rings,\n      rings = _ref$rings === void 0 ? 11 : _ref$rings;\n\n  return \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + (frustrum != null ? frustrum : frustum) + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n};\n\nvar deployed = false;\n\nvar softShadows = function softShadows(props) {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    if (props == null ? void 0 : props.frustrum) {\n      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');\n    }\n\n    deployed = true;\n    var shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/@react-three/drei/core/softShadows.js"],"names":["_extends","ShaderChunk","pcss","frustrum","frustum","size","near","samples","rings","deployed","softShadows","props","console","warn","shader","shadowmap_pars_fragment","replace"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,SAASC,WAAT,QAA4B,OAA5B;;AAEA,IAAMC,IAAI,GAAG,SAAPA,IAAO;AAAA,iFAOT,EAPS;AAAA,MACXC,QADW,QACXA,QADW;AAAA,0BAEXC,OAFW;AAAA,MAEXA,OAFW,6BAED,IAFC;AAAA,uBAGXC,IAHW;AAAA,MAGXA,IAHW,0BAGJ,KAHI;AAAA,uBAIXC,IAJW;AAAA,MAIXA,IAJW,0BAIJ,GAJI;AAAA,0BAKXC,OALW;AAAA,MAKXA,OALW,6BAKD,EALC;AAAA,wBAMXC,KANW;AAAA,MAMXA,KANW,2BAMH,EANG;;AAAA,SAOF,8BAA8BH,IAA9B,GAAqC,gCAArC,IAAyEF,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8BC,OAAvG,IAAkH,uFAAlH,GAA4ME,IAA5M,GAAmN,0BAAnN,GAAgPC,OAAhP,GAA0P,sBAA1P,GAAmRC,KAAnR,GAA2R,yzEAPzR;AAAA,CAAb;;AASA,IAAIC,QAAQ,GAAG,KAAf;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAC,KAAK,EAAI;AAC3B;AACA,MAAI,CAACF,QAAL,EAAe;AACb,QAAIE,KAAK,IAAI,IAAT,GAAgB,KAAK,CAArB,GAAyBA,KAAK,CAACR,QAAnC,EAA6C;AAC3CS,MAAAA,OAAO,CAACC,IAAR,CAAa,wFAAb;AACD;;AAEDJ,IAAAA,QAAQ,GAAG,IAAX;AACA,QAAIK,MAAM,GAAGb,WAAW,CAACc,uBAAzB;AACAD,IAAAA,MAAM,GAAGA,MAAM,CAACE,OAAP,CAAe,sBAAf,EAAuC,2BAA2Bd,IAAI,CAACF,QAAQ,CAAC,EAAD,EAAKW,KAAL,CAAT,CAAtE,CAAT;AACAG,IAAAA,MAAM,GAAGA,MAAM,CAACE,OAAP,CAAe,mCAAf,EAAoD,2EAApD,CAAT;AACAf,IAAAA,WAAW,CAACc,uBAAZ,GAAsCD,MAAtC;AACD;AACF,CAbD;;AAeA,SAASJ,WAAT","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\n\nconst pcss = ({\n  frustrum,\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 17,\n  rings = 11\n} = {}) => \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + (frustrum != null ? frustrum : frustum) + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    if (props == null ? void 0 : props.frustrum) {\n      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');\n    }\n\n    deployed = true;\n    let shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };\n"]},"metadata":{},"sourceType":"module"}