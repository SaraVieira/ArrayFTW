{"ast":null,"code":"import { Loader, FileLoader, Matrix3, Vector2, Vector3, BufferGeometry, Float32BufferAttribute, ShapePath, Path } from 'three';\n\nvar SVGLoader = function SVGLoader(manager) {\n  Loader.call(this, manager); // Default dots per inch\n\n  this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n  this.defaultUnit = 'px';\n};\n\nSVGLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: SVGLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(text) {\n    var scope = this;\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      var transform = getNodeTransform(node);\n      var traverseChildNodes = true;\n      var path = null;\n\n      switch (node.nodeName) {\n        case 'svg':\n          break;\n\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case 'defs':\n          traverseChildNodes = false;\n          break;\n\n        case 'use':\n          style = parseStyle(node, style);\n          var usedNodeId = node.href.baseVal.substring(1);\n          var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n\n          break;\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n\n      if (traverseChildNodes) {\n        var nodes = node.childNodes;\n\n        for (var i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      var path = new ShapePath();\n      var point = new Vector2();\n      var control = new Vector2();\n      var firstPoint = new Vector2();\n      var isFirstPoint = true;\n      var doSetFirstPoint = false;\n      var d = node.getAttribute('d'); // console.log( d );\n\n      var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n      for (var i = 0, l = commands.length; i < l; i++) {\n        var command = commands[i];\n        var type = command.charAt(0);\n        var data = command.substr(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        switch (type) {\n          case 'M':\n            var numbers = parseFloats(data);\n\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'H':\n            var numbers = parseFloats(data);\n\n            for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n              point.x = numbers[_j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'V':\n            var numbers = parseFloats(data);\n\n            for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n              point.y = numbers[_j2];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'L':\n            var numbers = parseFloats(data);\n\n            for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n              point.x = numbers[_j3 + 0];\n              point.y = numbers[_j3 + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'C':\n            var numbers = parseFloats(data);\n\n            for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n              path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n              control.x = numbers[_j4 + 2];\n              control.y = numbers[_j4 + 3];\n              point.x = numbers[_j4 + 4];\n              point.y = numbers[_j4 + 5];\n              if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'S':\n            var numbers = parseFloats(data);\n\n            for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n              control.x = numbers[_j5 + 0];\n              control.y = numbers[_j5 + 1];\n              point.x = numbers[_j5 + 2];\n              point.y = numbers[_j5 + 3];\n              if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Q':\n            var numbers = parseFloats(data);\n\n            for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n              path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n              control.x = numbers[_j6 + 0];\n              control.y = numbers[_j6 + 1];\n              point.x = numbers[_j6 + 2];\n              point.y = numbers[_j6 + 3];\n              if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'T':\n            var numbers = parseFloats(data);\n\n            for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[_j7 + 0];\n              point.y = numbers[_j7 + 1];\n              if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'A':\n            var numbers = parseFloats(data);\n\n            for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n              // skip command if start point == end point\n              if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n              var start = point.clone();\n              point.x = numbers[_j8 + 5];\n              point.y = numbers[_j8 + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n              if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'm':\n            var numbers = parseFloats(data);\n\n            for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n              point.x += numbers[_j9 + 0];\n              point.y += numbers[_j9 + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (_j9 === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (_j9 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'h':\n            var numbers = parseFloats(data);\n\n            for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n              point.x += numbers[_j10];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'v':\n            var numbers = parseFloats(data);\n\n            for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n              point.y += numbers[_j11];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'l':\n            var numbers = parseFloats(data);\n\n            for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n              point.x += numbers[_j12 + 0];\n              point.y += numbers[_j12 + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'c':\n            var numbers = parseFloats(data);\n\n            for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n              path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n              control.x = point.x + numbers[_j13 + 2];\n              control.y = point.y + numbers[_j13 + 3];\n              point.x += numbers[_j13 + 4];\n              point.y += numbers[_j13 + 5];\n              if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 's':\n            var numbers = parseFloats(data);\n\n            for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n              control.x = point.x + numbers[_j14 + 0];\n              control.y = point.y + numbers[_j14 + 1];\n              point.x += numbers[_j14 + 2];\n              point.y += numbers[_j14 + 3];\n              if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'q':\n            var numbers = parseFloats(data);\n\n            for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n              path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n              control.x = point.x + numbers[_j15 + 0];\n              control.y = point.y + numbers[_j15 + 1];\n              point.x += numbers[_j15 + 2];\n              point.y += numbers[_j15 + 3];\n              if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 't':\n            var numbers = parseFloats(data);\n\n            for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[_j16 + 0];\n              point.y = point.y + numbers[_j16 + 1];\n              if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'a':\n            var numbers = parseFloats(data);\n\n            for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n              // skip command if no displacement\n              if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n              var start = point.clone();\n              point.x += numbers[_j17 + 5];\n              point.y += numbers[_j17 + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], start, point);\n              if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n      for (var i = 0; i < node.sheet.cssRules.length; i++) {\n        var stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i) {\n          return i.trim();\n        });\n\n        for (var j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      var dx2 = (start.x - end.x) / 2.0;\n      var dy2 = (start.y - end.y) / 2.0;\n      var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      var rxs = rx * rx;\n      var rys = ry * ry;\n      var x1ps = x1p * x1p;\n      var y1ps = y1p * y1p; // Ensure radii are large enough\n\n      var cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        var s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      var dq = rxs * y1ps + rys * x1ps;\n      var pq = (rxs * rys - dq) / dq;\n      var q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      var cxp = q * rx * y1p / ry;\n      var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      var dot = ux * vx + uy * vy;\n      var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n\n\n    function parseRectNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      var w = parseFloatWithUnits(node.getAttribute('width'));\n      var h = parseFloatWithUnits(node.getAttribute('height'));\n      var path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n\n      path.lineTo(x, y + 2 * ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var r = parseFloatWithUnits(node.getAttribute('r'));\n      var subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var rx = parseFloatWithUnits(node.getAttribute('rx'));\n      var ry = parseFloatWithUnits(node.getAttribute('ry'));\n      var subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseLineNode(node) {\n      var x1 = parseFloatWithUnits(node.getAttribute('x1'));\n      var y1 = parseFloatWithUnits(node.getAttribute('y1'));\n      var x2 = parseFloatWithUnits(node.getAttribute('x2'));\n      var y2 = parseFloatWithUnits(node.getAttribute('y2'));\n      var path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      var stylesheetStyles = {};\n\n      if (node.hasAttribute('class')) {\n        var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(function (i) {\n          return i.trim();\n        });\n\n        for (var i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n    function parseFloats(input) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n\n      var RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i\n      }; // States\n\n      var SEP = 0;\n      var INT = 1;\n      var FLOAT = 2;\n      var EXP = 3;\n      var state = SEP;\n      var seenComma = true;\n      var result = [],\n          number = '',\n          exponent = '';\n\n      function throwSyntaxError(current, i, partial) {\n        var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = '';\n        exponent = '';\n      }\n\n      var current,\n          i = 0,\n          length = input.length;\n\n      for (i = 0; i < length; i++) {\n        current = input[i]; // parse until next number\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        } // parse integer part\n\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n\n        if (state == EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n\n      newNumber();\n      return result;\n    } // Units\n\n\n    var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    var unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n\n    function parseFloatWithUnits(string) {\n      var theUnit = 'px';\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (var i = 0, n = units.length; i < n; i++) {\n          var u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      var scale = undefined;\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    } // Transforms\n\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n\n      var transform = parseNodeTransform(node);\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n\n    function parseNodeTransform(node) {\n      var transform = new Matrix3();\n      var currentTransform = tempTransform0;\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        var tx = parseFloatWithUnits(node.getAttribute('x'));\n        var ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n\n      if (node.hasAttribute('transform')) {\n        var transformsTexts = node.getAttribute('transform').split(')');\n\n        for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          var transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          var openParPos = transformText.indexOf('(');\n          var closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            var transformType = transformText.substr(0, openParPos);\n            var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  var tx = array[0];\n                  var ty = tx;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                }\n\n                break;\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  var angle = 0;\n                  var cx = 0;\n                  var cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n\n                break;\n\n              case 'scale':\n                if (array.length >= 1) {\n                  var scaleX = array[0];\n                  var scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n\n      var isRotated = isTransformRotated(m);\n      var subPaths = path.subPaths;\n\n      for (var i = 0, n = subPaths.length; i < n; i++) {\n        var subPath = subPaths[i];\n        var curves = subPath.curves;\n\n        for (var j = 0; j < curves.length; j++) {\n          var curve = curves[j];\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n\n    function getTransformScaleX(m) {\n      var te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n\n    function getTransformScaleY(m) {\n      var te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n\n    var paths = [];\n    var stylesheets = {};\n    var transformStack = [];\n    var tempTransform0 = new Matrix3();\n    var tempTransform1 = new Matrix3();\n    var tempTransform2 = new Matrix3();\n    var tempTransform3 = new Matrix3();\n    var tempV2 = new Vector2();\n    var tempV3 = new Vector3();\n    var currentTransform = new Matrix3();\n    var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    var data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n});\n\nSVGLoader.getStrokeStyle = function (width, color, lineJoin, lineCap, miterLimit) {\n  // Param width: Stroke width\n  // Param color: As returned by THREE.Color.getStyle()\n  // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n  // Param lineCap: One of \"round\", \"square\" or \"butt\"\n  // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n  // Returns style object\n  width = width !== undefined ? width : 1;\n  color = color !== undefined ? color : '#000';\n  lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n  lineCap = lineCap !== undefined ? lineCap : 'butt';\n  miterLimit = miterLimit !== undefined ? miterLimit : 4;\n  return {\n    strokeColor: color,\n    strokeWidth: width,\n    strokeLineJoin: lineJoin,\n    strokeLineCap: lineCap,\n    strokeMiterLimit: miterLimit\n  };\n};\n\nSVGLoader.pointsToStroke = function (points, style, arcDivisions, minDistance) {\n  // Generates a stroke with some witdh around the given path.\n  // The path can be open or closed (last point equals to first point)\n  // Param points: Array of Vector2D (the path). Minimum 2 points.\n  // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n  // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n  // Param minDistance: Points closer to this distance will be merged. (Optional)\n  // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n\n  if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n    return null;\n  }\n\n  var geometry = new BufferGeometry();\n  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  return geometry;\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n  var tempV2_1 = new Vector2();\n  var tempV2_2 = new Vector2();\n  var tempV2_3 = new Vector2();\n  var tempV2_4 = new Vector2();\n  var tempV2_5 = new Vector2();\n  var tempV2_6 = new Vector2();\n  var tempV2_7 = new Vector2();\n  var lastPointL = new Vector2();\n  var lastPointR = new Vector2();\n  var point0L = new Vector2();\n  var point0R = new Vector2();\n  var currentPointL = new Vector2();\n  var currentPointR = new Vector2();\n  var nextPointL = new Vector2();\n  var nextPointR = new Vector2();\n  var innerPoint = new Vector2();\n  var outerPoint = new Vector2();\n  return function (points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    var numPoints = points.length;\n    if (numPoints < 2) return 0;\n    var isClosed = points[0].equals(points[numPoints - 1]);\n    var currentPoint;\n    var previousPoint = points[0];\n    var nextPoint;\n    var strokeWidth2 = style.strokeWidth / 2;\n    var deltaU = 1 / (numPoints - 1);\n    var u0 = 0;\n    var innerSideModified;\n    var joinIsOnLeftSide;\n    var isMiter;\n    var initialJoinIsOnLeftSide = false;\n    var numVertices = 0;\n    var currentCoordinate = vertexOffset * 3;\n    var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n\n      var normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      var u1 = u0 + deltaU;\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          var miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          var miterLength2 = tempV2_5.length();\n          var segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          var segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n\n              break;\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      var lastOuter = outerPoint;\n      var lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      var angle = Math.PI;\n      var dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n\n      for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            var vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      var dupPoints = false;\n\n      for (var i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n      var newPoints = [];\n      newPoints.push(points[0]);\n\n      for (var _i = 1, _n = points.length - 1; _i < _n; _i++) {\n        if (points[_i].distanceTo(points[_i + 1]) >= minDistance) {\n          newPoints.push(points[_i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  };\n}();\n\nexport { SVGLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/SVGLoader.js"],"names":["Loader","FileLoader","Matrix3","Vector2","Vector3","BufferGeometry","Float32BufferAttribute","ShapePath","Path","SVGLoader","manager","call","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","usedNodeId","href","baseVal","substring","usedNode","viewportElement","getElementById","warn","fill","undefined","color","setStyle","transformPath","currentTransform","paths","push","userData","nodes","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","stylesheets","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","SEP","INT","FLOAT","state","seenComma","result","number","exponent","throwSyntaxError","current","partial","SyntaxError","newNumber","Number","pow","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","vertexOffset","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","center","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,OAA7B,EAAsCC,OAAtC,EAA+CC,OAA/C,EAAwDC,cAAxD,EAAwEC,sBAAxE,EAAgGC,SAAhG,EAA2GC,IAA3G,QAAuH,OAAvH;;AAEA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAUC,OAAV,EAAmB;AACjCV,EAAAA,MAAM,CAACW,IAAP,CAAY,IAAZ,EAAkBD,OAAlB,EADiC,CACL;;AAE5B,OAAKE,UAAL,GAAkB,EAAlB,CAHiC,CAGX;;AAEtB,OAAKC,WAAL,GAAmB,IAAnB;AACD,CAND;;AAQAJ,SAAS,CAACK,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAcjB,MAAM,CAACc,SAArB,CAAd,EAA+C;AACnEI,EAAAA,WAAW,EAAET,SADsD;AAEnEU,EAAAA,IAAI,EAAE,cAAUC,GAAV,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,OAAnC,EAA4C;AAChD,QAAIC,KAAK,GAAG,IAAZ;AACA,QAAIC,MAAM,GAAG,IAAIxB,UAAJ,CAAeuB,KAAK,CAACd,OAArB,CAAb;AACAe,IAAAA,MAAM,CAACC,OAAP,CAAeF,KAAK,CAACG,IAArB;AACAF,IAAAA,MAAM,CAACG,gBAAP,CAAwBJ,KAAK,CAACK,aAA9B;AACAJ,IAAAA,MAAM,CAACK,kBAAP,CAA0BN,KAAK,CAACO,eAAhC;AACAN,IAAAA,MAAM,CAACN,IAAP,CAAYC,GAAZ,EAAiB,UAAUY,IAAV,EAAgB;AAC/B,UAAI;AACFX,QAAAA,MAAM,CAACG,KAAK,CAACS,KAAN,CAAYD,IAAZ,CAAD,CAAN;AACD,OAFD,CAEE,OAAOE,CAAP,EAAU;AACV,YAAIX,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACW,CAAD,CAAP;AACD,SAFD,MAEO;AACLC,UAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AAEDV,QAAAA,KAAK,CAACd,OAAN,CAAc2B,SAAd,CAAwBjB,GAAxB;AACD;AACF,KAZD,EAYGE,UAZH,EAYeC,OAZf;AAaD,GArBkE;AAsBnEU,EAAAA,KAAK,EAAE,eAAUD,IAAV,EAAgB;AACrB,QAAIR,KAAK,GAAG,IAAZ;;AAEA,aAASc,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgC;AAC9B,UAAID,IAAI,CAACE,QAAL,KAAkB,CAAtB,EAAyB;AACzB,UAAIC,SAAS,GAAGC,gBAAgB,CAACJ,IAAD,CAAhC;AACA,UAAIK,kBAAkB,GAAG,IAAzB;AACA,UAAIjB,IAAI,GAAG,IAAX;;AAEA,cAAQY,IAAI,CAACM,QAAb;AACE,aAAK,KAAL;AACE;;AAEF,aAAK,OAAL;AACEC,UAAAA,kBAAkB,CAACP,IAAD,CAAlB;AACA;;AAEF,aAAK,GAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACA;;AAEF,aAAK,MAAL;AACEA,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACA,cAAID,IAAI,CAACS,YAAL,CAAkB,GAAlB,CAAJ,EAA4BrB,IAAI,GAAGsB,aAAa,CAACV,IAAD,CAApB;AAC5B;;AAEF,aAAK,MAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAGuB,aAAa,CAACX,IAAD,CAApB;AACA;;AAEF,aAAK,SAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAGwB,gBAAgB,CAACZ,IAAD,CAAvB;AACA;;AAEF,aAAK,UAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAGyB,iBAAiB,CAACb,IAAD,CAAxB;AACA;;AAEF,aAAK,QAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAG0B,eAAe,CAACd,IAAD,CAAtB;AACA;;AAEF,aAAK,SAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAG2B,gBAAgB,CAACf,IAAD,CAAvB;AACA;;AAEF,aAAK,MAAL;AACEC,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACAb,UAAAA,IAAI,GAAG4B,aAAa,CAAChB,IAAD,CAApB;AACA;;AAEF,aAAK,MAAL;AACEK,UAAAA,kBAAkB,GAAG,KAArB;AACA;;AAEF,aAAK,KAAL;AACEJ,UAAAA,KAAK,GAAGO,UAAU,CAACR,IAAD,EAAOC,KAAP,CAAlB;AACA,cAAIgB,UAAU,GAAGjB,IAAI,CAACkB,IAAL,CAAUC,OAAV,CAAkBC,SAAlB,CAA4B,CAA5B,CAAjB;AACA,cAAIC,QAAQ,GAAGrB,IAAI,CAACsB,eAAL,CAAqBC,cAArB,CAAoCN,UAApC,CAAf;;AAEA,cAAII,QAAJ,EAAc;AACZtB,YAAAA,SAAS,CAACsB,QAAD,EAAWpB,KAAX,CAAT;AACD,WAFD,MAEO;AACLL,YAAAA,OAAO,CAAC4B,IAAR,CAAa,4DAA4DP,UAAzE;AACD;;AAED;AA9DJ;;AAkEA,UAAI7B,IAAJ,EAAU;AACR,YAAIa,KAAK,CAACwB,IAAN,KAAeC,SAAf,IAA4BzB,KAAK,CAACwB,IAAN,KAAe,MAA/C,EAAuD;AACrDrC,UAAAA,IAAI,CAACuC,KAAL,CAAWC,QAAX,CAAoB3B,KAAK,CAACwB,IAA1B;AACD;;AAEDI,QAAAA,aAAa,CAACzC,IAAD,EAAO0C,gBAAP,CAAb;AACAC,QAAAA,KAAK,CAACC,IAAN,CAAW5C,IAAX;AACAA,QAAAA,IAAI,CAAC6C,QAAL,GAAgB;AACdjC,UAAAA,IAAI,EAAEA,IADQ;AAEdC,UAAAA,KAAK,EAAEA;AAFO,SAAhB;AAID;;AAED,UAAII,kBAAJ,EAAwB;AACtB,YAAI6B,KAAK,GAAGlC,IAAI,CAACmC,UAAjB;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrCrC,UAAAA,SAAS,CAACmC,KAAK,CAACE,CAAD,CAAN,EAAWnC,KAAX,CAAT;AACD;AACF;;AAED,UAAIE,SAAJ,EAAe;AACbmC,QAAAA,cAAc,CAACC,GAAf;;AAEA,YAAID,cAAc,CAACD,MAAf,GAAwB,CAA5B,EAA+B;AAC7BP,UAAAA,gBAAgB,CAACU,IAAjB,CAAsBF,cAAc,CAACA,cAAc,CAACD,MAAf,GAAwB,CAAzB,CAApC;AACD,SAFD,MAEO;AACLP,UAAAA,gBAAgB,CAACW,QAAjB;AACD;AACF;AACF;;AAED,aAAS/B,aAAT,CAAuBV,IAAvB,EAA6B;AAC3B,UAAIZ,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACA,UAAI0E,KAAK,GAAG,IAAI9E,OAAJ,EAAZ;AACA,UAAI+E,OAAO,GAAG,IAAI/E,OAAJ,EAAd;AACA,UAAIgF,UAAU,GAAG,IAAIhF,OAAJ,EAAjB;AACA,UAAIiF,YAAY,GAAG,IAAnB;AACA,UAAIC,eAAe,GAAG,KAAtB;AACA,UAAIC,CAAC,GAAG/C,IAAI,CAACgD,YAAL,CAAkB,GAAlB,CAAR,CAP2B,CAOK;;AAEhC,UAAIC,QAAQ,GAAGF,CAAC,CAACG,KAAF,CAAQ,sBAAR,CAAf;;AAEA,WAAK,IAAId,CAAC,GAAG,CAAR,EAAWe,CAAC,GAAGF,QAAQ,CAACZ,MAA7B,EAAqCD,CAAC,GAAGe,CAAzC,EAA4Cf,CAAC,EAA7C,EAAiD;AAC/C,YAAIgB,OAAO,GAAGH,QAAQ,CAACb,CAAD,CAAtB;AACA,YAAIiB,IAAI,GAAGD,OAAO,CAACE,MAAR,CAAe,CAAf,CAAX;AACA,YAAIC,IAAI,GAAGH,OAAO,CAACI,MAAR,CAAe,CAAf,EAAkBC,IAAlB,EAAX;;AAEA,YAAIZ,YAAY,KAAK,IAArB,EAA2B;AACzBC,UAAAA,eAAe,GAAG,IAAlB;AACAD,UAAAA,YAAY,GAAG,KAAf;AACD;;AAED,gBAAQQ,IAAR;AACE,eAAK,GAAL;AACE,gBAAIK,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,CAAC,GAAGC,EAAzC,EAA6CD,CAAC,IAAI,CAAlD,EAAqD;AACnDlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,CAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,CAAC,GAAG,CAAL,CAAjB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;;AAEA,kBAAIH,CAAC,KAAK,CAAV,EAAa;AACXxE,gBAAAA,IAAI,CAAC4E,MAAL,CAAYtB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACD,eAFD,MAEO;AACL3E,gBAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACD;;AAED,kBAAIH,CAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,EAAC,GAAG,CAAR,EAAWC,GAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,EAAC,GAAGC,GAAzC,EAA6CD,EAAC,EAA9C,EAAkD;AAChDlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,EAAD,CAAjB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,EAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,EAA9C,EAAkD;AAChDlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAD,CAAjB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnDlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAAC8E,aAAL,CAAmBR,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1B,EAAmCF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1C,EAAmDF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1D,EAAmEF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1E,EAAmFF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1F,EAAmGF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1G;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACA,kBAAIA,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAAC8E,aAAL,CAAmBC,aAAa,CAACzB,KAAK,CAACoB,CAAP,EAAUnB,OAAO,CAACmB,CAAlB,CAAhC,EAAsDK,aAAa,CAACzB,KAAK,CAACqB,CAAP,EAAUpB,OAAO,CAACoB,CAAlB,CAAnE,EAAyFL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAhG,EAAyGF,OAAO,CAACE,GAAC,GAAG,CAAL,CAAhH,EAAyHF,OAAO,CAACE,GAAC,GAAG,CAAL,CAAhI,EAAyIF,OAAO,CAACE,GAAC,GAAG,CAAL,CAAhJ;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACA,kBAAIA,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAACgF,gBAAL,CAAsBV,OAAO,CAACE,GAAC,GAAG,CAAL,CAA7B,EAAsCF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA7C,EAAsDF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA7D,EAAsEF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA7E;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAnB;AACAlB,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACA,kBAAIA,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnD,kBAAIS,EAAE,GAAGF,aAAa,CAACzB,KAAK,CAACoB,CAAP,EAAUnB,OAAO,CAACmB,CAAlB,CAAtB;AACA,kBAAIQ,EAAE,GAAGH,aAAa,CAACzB,KAAK,CAACqB,CAAP,EAAUpB,OAAO,CAACoB,CAAlB,CAAtB;AACA3E,cAAAA,IAAI,CAACgF,gBAAL,CAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BZ,OAAO,CAACE,GAAC,GAAG,CAAL,CAArC,EAA8CF,OAAO,CAACE,GAAC,GAAG,CAAL,CAArD;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYO,EAAZ;AACA1B,cAAAA,OAAO,CAACoB,CAAR,GAAYO,EAAZ;AACA5B,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACA,kBAAIA,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnD;AACA,kBAAIF,OAAO,CAACE,GAAC,GAAG,CAAL,CAAP,IAAkBlB,KAAK,CAACoB,CAAxB,IAA6BJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAP,IAAkBlB,KAAK,CAACqB,CAAzD,EAA4D;AAC5D,kBAAIQ,KAAK,GAAG7B,KAAK,CAAC8B,KAAN,EAAZ;AACA9B,cAAAA,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAjB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACAU,cAAAA,eAAe,CAACrF,IAAD,EAAOsE,OAAO,CAACE,GAAD,CAAd,EAAmBF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1B,EAAmCF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1C,EAAmDF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1D,EAAmEF,OAAO,CAACE,GAAC,GAAG,CAAL,CAA1E,EAAmFW,KAAnF,EAA0F7B,KAA1F,CAAf;AACA,kBAAIkB,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,GAAC,GAAG,CAAR,EAAWC,IAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,GAAC,GAAGC,IAAzC,EAA6CD,GAAC,IAAI,CAAlD,EAAqD;AACnDlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,GAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,GAAC,GAAG,CAAL,CAAlB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;;AAEA,kBAAIH,GAAC,KAAK,CAAV,EAAa;AACXxE,gBAAAA,IAAI,CAAC4E,MAAL,CAAYtB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACD,eAFD,MAEO;AACL3E,gBAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACD;;AAED,kBAAIH,GAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,EAA9C,EAAkD;AAChDlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAD,CAAlB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,EAA9C,EAAkD;AAChDlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAD,CAAlB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnDlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACA3E,cAAAA,IAAI,CAAC6E,MAAL,CAAYvB,KAAK,CAACoB,CAAlB,EAAqBpB,KAAK,CAACqB,CAA3B;AACA,kBAAIH,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAAC8E,aAAL,CAAmBxB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAApC,EAA6ClB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAA9D,EAAuElB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAxF,EAAiGlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlH,EAA2HlB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA5I,EAAqJlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAtK;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACA,kBAAIA,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAAC8E,aAAL,CAAmBC,aAAa,CAACzB,KAAK,CAACoB,CAAP,EAAUnB,OAAO,CAACmB,CAAlB,CAAhC,EAAsDK,aAAa,CAACzB,KAAK,CAACqB,CAAP,EAAUpB,OAAO,CAACoB,CAAlB,CAAnE,EAAyFrB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA1G,EAAmHlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAApI,EAA6IlB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA9J,EAAuKlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAxL;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACA,kBAAIA,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnDxE,cAAAA,IAAI,CAACgF,gBAAL,CAAsB1B,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAvC,EAAgDlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAjE,EAA0ElB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA3F,EAAoGlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAArH;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAjB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAA7B;AACAlB,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACA,kBAAIA,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnD,kBAAIS,EAAE,GAAGF,aAAa,CAACzB,KAAK,CAACoB,CAAP,EAAUnB,OAAO,CAACmB,CAAlB,CAAtB;AACA,kBAAIQ,EAAE,GAAGH,aAAa,CAACzB,KAAK,CAACqB,CAAP,EAAUpB,OAAO,CAACoB,CAAlB,CAAtB;AACA3E,cAAAA,IAAI,CAACgF,gBAAL,CAAsBC,EAAtB,EAA0BC,EAA1B,EAA8B5B,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA/C,EAAwDlB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAzE;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYO,EAAZ;AACA1B,cAAAA,OAAO,CAACoB,CAAR,GAAYO,EAAZ;AACA5B,cAAAA,KAAK,CAACoB,CAAN,GAAUpB,KAAK,CAACoB,CAAN,GAAUJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAA3B;AACAlB,cAAAA,KAAK,CAACqB,CAAN,GAAUrB,KAAK,CAACqB,CAAN,GAAUL,OAAO,CAACE,IAAC,GAAG,CAAL,CAA3B;AACA,kBAAIA,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACE,gBAAIgB,OAAO,GAAGC,WAAW,CAACJ,IAAD,CAAzB;;AAEA,iBAAK,IAAIK,IAAC,GAAG,CAAR,EAAWC,KAAE,GAAGH,OAAO,CAACrB,MAA7B,EAAqCuB,IAAC,GAAGC,KAAzC,EAA6CD,IAAC,IAAI,CAAlD,EAAqD;AACnD;AACA,kBAAIF,OAAO,CAACE,IAAC,GAAG,CAAL,CAAP,IAAkB,CAAlB,IAAuBF,OAAO,CAACE,IAAC,GAAG,CAAL,CAAP,IAAkB,CAA7C,EAAgD;AAChD,kBAAIW,KAAK,GAAG7B,KAAK,CAAC8B,KAAN,EAAZ;AACA9B,cAAAA,KAAK,CAACoB,CAAN,IAAWJ,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAlB,cAAAA,KAAK,CAACqB,CAAN,IAAWL,OAAO,CAACE,IAAC,GAAG,CAAL,CAAlB;AACAjB,cAAAA,OAAO,CAACmB,CAAR,GAAYpB,KAAK,CAACoB,CAAlB;AACAnB,cAAAA,OAAO,CAACoB,CAAR,GAAYrB,KAAK,CAACqB,CAAlB;AACAU,cAAAA,eAAe,CAACrF,IAAD,EAAOsE,OAAO,CAACE,IAAD,CAAd,EAAmBF,OAAO,CAACE,IAAC,GAAG,CAAL,CAA1B,EAAmCF,OAAO,CAACE,IAAC,GAAG,CAAL,CAA1C,EAAmDF,OAAO,CAACE,IAAC,GAAG,CAAL,CAA1D,EAAmEF,OAAO,CAACE,IAAC,GAAG,CAAL,CAA1E,EAAmFW,KAAnF,EAA0F7B,KAA1F,CAAf;AACA,kBAAIkB,IAAC,KAAK,CAAN,IAAWd,eAAe,KAAK,IAAnC,EAAyCF,UAAU,CAACJ,IAAX,CAAgBE,KAAhB;AAC1C;;AAED;;AAEF,eAAK,GAAL;AACA,eAAK,GAAL;AACEtD,YAAAA,IAAI,CAACsF,WAAL,CAAiBC,SAAjB,GAA6B,IAA7B;;AAEA,gBAAIvF,IAAI,CAACsF,WAAL,CAAiBE,MAAjB,CAAwBvC,MAAxB,GAAiC,CAArC,EAAwC;AACtC;AACAK,cAAAA,KAAK,CAACF,IAAN,CAAWI,UAAX;AACAxD,cAAAA,IAAI,CAACsF,WAAL,CAAiBG,YAAjB,CAA8BrC,IAA9B,CAAmCE,KAAnC;AACAG,cAAAA,YAAY,GAAG,IAAf;AACD;;AAED;;AAEF;AACEjD,YAAAA,OAAO,CAAC4B,IAAR,CAAa4B,OAAb;AA7RJ,SAV+C,CAwS7C;;;AAGFN,QAAAA,eAAe,GAAG,KAAlB;AACD;;AAED,aAAO1D,IAAP;AACD;;AAED,aAASmB,kBAAT,CAA4BP,IAA5B,EAAkC;AAChC,UAAI,CAACA,IAAI,CAAC8E,KAAN,IAAe,CAAC9E,IAAI,CAAC8E,KAAL,CAAWC,QAA3B,IAAuC,CAAC/E,IAAI,CAAC8E,KAAL,CAAWC,QAAX,CAAoB1C,MAAhE,EAAwE;;AAExE,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,IAAI,CAAC8E,KAAL,CAAWC,QAAX,CAAoB1C,MAAxC,EAAgDD,CAAC,EAAjD,EAAqD;AACnD,YAAI4C,UAAU,GAAGhF,IAAI,CAAC8E,KAAL,CAAWC,QAAX,CAAoB3C,CAApB,CAAjB;AACA,YAAI4C,UAAU,CAAC3B,IAAX,KAAoB,CAAxB,EAA2B;AAC3B,YAAI4B,YAAY,GAAGD,UAAU,CAACE,YAAX,CAAwBC,KAAxB,CAA8B,KAA9B,EAAqCC,MAArC,CAA4CC,OAA5C,EAAqDC,GAArD,CAAyD,UAAAlD,CAAC;AAAA,iBAAIA,CAAC,CAACqB,IAAF,EAAJ;AAAA,SAA1D,CAAnB;;AAEA,aAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,YAAY,CAAC5C,MAAjC,EAAyCuB,CAAC,EAA1C,EAA8C;AAC5C2B,UAAAA,WAAW,CAACN,YAAY,CAACrB,CAAD,CAAb,CAAX,GAA+BpF,MAAM,CAACC,MAAP,CAAc8G,WAAW,CAACN,YAAY,CAACrB,CAAD,CAAb,CAAX,IAAgC,EAA9C,EAAkDoB,UAAU,CAAC/E,KAA7D,CAA/B;AACD;AACF;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASwE,eAAT,CAAyBrF,IAAzB,EAA+BiF,EAA/B,EAAmCC,EAAnC,EAAuCkB,eAAvC,EAAwDC,cAAxD,EAAwEC,UAAxE,EAAoFnB,KAApF,EAA2FoB,GAA3F,EAAgG;AAC9F,UAAItB,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAArB,EAAwB;AACtB;AACAlF,QAAAA,IAAI,CAAC6E,MAAL,CAAY0B,GAAG,CAAC7B,CAAhB,EAAmB6B,GAAG,CAAC5B,CAAvB;AACA;AACD;;AAEDyB,MAAAA,eAAe,GAAGA,eAAe,GAAGI,IAAI,CAACC,EAAvB,GAA4B,GAA9C,CAP8F,CAO3C;;AAEnDxB,MAAAA,EAAE,GAAGuB,IAAI,CAACE,GAAL,CAASzB,EAAT,CAAL;AACAC,MAAAA,EAAE,GAAGsB,IAAI,CAACE,GAAL,CAASxB,EAAT,CAAL,CAV8F,CAU3E;;AAEnB,UAAIyB,GAAG,GAAG,CAACxB,KAAK,CAACT,CAAN,GAAU6B,GAAG,CAAC7B,CAAf,IAAoB,GAA9B;AACA,UAAIkC,GAAG,GAAG,CAACzB,KAAK,CAACR,CAAN,GAAU4B,GAAG,CAAC5B,CAAf,IAAoB,GAA9B;AACA,UAAIkC,GAAG,GAAGL,IAAI,CAACM,GAAL,CAASV,eAAT,IAA4BO,GAA5B,GAAkCH,IAAI,CAACO,GAAL,CAASX,eAAT,IAA4BQ,GAAxE;AACA,UAAII,GAAG,GAAG,CAACR,IAAI,CAACO,GAAL,CAASX,eAAT,CAAD,GAA6BO,GAA7B,GAAmCH,IAAI,CAACM,GAAL,CAASV,eAAT,IAA4BQ,GAAzE,CAf8F,CAehB;;AAE9E,UAAIK,GAAG,GAAGhC,EAAE,GAAGA,EAAf;AACA,UAAIiC,GAAG,GAAGhC,EAAE,GAAGA,EAAf;AACA,UAAIiC,IAAI,GAAGN,GAAG,GAAGA,GAAjB;AACA,UAAIO,IAAI,GAAGJ,GAAG,GAAGA,GAAjB,CApB8F,CAoBxE;;AAEtB,UAAIK,EAAE,GAAGF,IAAI,GAAGF,GAAP,GAAaG,IAAI,GAAGF,GAA7B;;AAEA,UAAIG,EAAE,GAAG,CAAT,EAAY;AACV;AACA,YAAIC,CAAC,GAAGd,IAAI,CAACe,IAAL,CAAUF,EAAV,CAAR;AACApC,QAAAA,EAAE,GAAGqC,CAAC,GAAGrC,EAAT;AACAC,QAAAA,EAAE,GAAGoC,CAAC,GAAGpC,EAAT;AACA+B,QAAAA,GAAG,GAAGhC,EAAE,GAAGA,EAAX;AACAiC,QAAAA,GAAG,GAAGhC,EAAE,GAAGA,EAAX;AACD;;AAED,UAAIsC,EAAE,GAAGP,GAAG,GAAGG,IAAN,GAAaF,GAAG,GAAGC,IAA5B;AACA,UAAIM,EAAE,GAAG,CAACR,GAAG,GAAGC,GAAN,GAAYM,EAAb,IAAmBA,EAA5B;AACA,UAAIE,CAAC,GAAGlB,IAAI,CAACe,IAAL,CAAUf,IAAI,CAACmB,GAAL,CAAS,CAAT,EAAYF,EAAZ,CAAV,CAAR;AACA,UAAIpB,cAAc,KAAKC,UAAvB,EAAmCoB,CAAC,GAAG,CAACA,CAAL;AACnC,UAAIE,GAAG,GAAGF,CAAC,GAAGzC,EAAJ,GAAS+B,GAAT,GAAe9B,EAAzB;AACA,UAAI2C,GAAG,GAAG,CAACH,CAAD,GAAKxC,EAAL,GAAU2B,GAAV,GAAgB5B,EAA1B,CAtC8F,CAsChE;;AAE9B,UAAI6C,EAAE,GAAGtB,IAAI,CAACM,GAAL,CAASV,eAAT,IAA4BwB,GAA5B,GAAkCpB,IAAI,CAACO,GAAL,CAASX,eAAT,IAA4ByB,GAA9D,GAAoE,CAAC1C,KAAK,CAACT,CAAN,GAAU6B,GAAG,CAAC7B,CAAf,IAAoB,CAAjG;AACA,UAAIqD,EAAE,GAAGvB,IAAI,CAACO,GAAL,CAASX,eAAT,IAA4BwB,GAA5B,GAAkCpB,IAAI,CAACM,GAAL,CAASV,eAAT,IAA4ByB,GAA9D,GAAoE,CAAC1C,KAAK,CAACR,CAAN,GAAU4B,GAAG,CAAC5B,CAAf,IAAoB,CAAjG,CAzC8F,CAyCM;;AAEpG,UAAIqD,KAAK,GAAGC,QAAQ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAACpB,GAAG,GAAGe,GAAP,IAAc3C,EAArB,EAAyB,CAAC+B,GAAG,GAAGa,GAAP,IAAc3C,EAAvC,CAApB;AACA,UAAIgD,KAAK,GAAGD,QAAQ,CAAC,CAACpB,GAAG,GAAGe,GAAP,IAAc3C,EAAf,EAAmB,CAAC+B,GAAG,GAAGa,GAAP,IAAc3C,EAAjC,EAAqC,CAAC,CAAC2B,GAAD,GAAOe,GAAR,IAAe3C,EAApD,EAAwD,CAAC,CAAC+B,GAAD,GAAOa,GAAR,IAAe3C,EAAvE,CAAR,IAAsFsB,IAAI,CAACC,EAAL,GAAU,CAAhG,CAAZ;AACAzG,MAAAA,IAAI,CAACsF,WAAL,CAAiB6C,UAAjB,CAA4BL,EAA5B,EAAgCC,EAAhC,EAAoC9C,EAApC,EAAwCC,EAAxC,EAA4C8C,KAA5C,EAAmDA,KAAK,GAAGE,KAA3D,EAAkE5B,UAAU,KAAK,CAAjF,EAAoFF,eAApF;AACD;;AAED,aAAS6B,QAAT,CAAkBG,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BC,EAA9B,EAAkC;AAChC,UAAIC,GAAG,GAAGJ,EAAE,GAAGE,EAAL,GAAUD,EAAE,GAAGE,EAAzB;AACA,UAAIE,GAAG,GAAGjC,IAAI,CAACe,IAAL,CAAUa,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,IAA+B7B,IAAI,CAACe,IAAL,CAAUe,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAzC;AACA,UAAIG,GAAG,GAAGlC,IAAI,CAACmC,IAAL,CAAUnC,IAAI,CAACmB,GAAL,CAAS,CAAC,CAAV,EAAanB,IAAI,CAACoC,GAAL,CAAS,CAAT,EAAYJ,GAAG,GAAGC,GAAlB,CAAb,CAAV,CAAV,CAHgC,CAG2B;;AAE3D,UAAIL,EAAE,GAAGG,EAAL,GAAUF,EAAE,GAAGC,EAAf,GAAoB,CAAxB,EAA2BI,GAAG,GAAG,CAACA,GAAP;AAC3B,aAAOA,GAAP;AACD;AACD;AACJ;AACA;AACA;;;AAGI,aAASnH,aAAT,CAAuBX,IAAvB,EAA6B;AAC3B,UAAI8D,CAAC,GAAGmE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,GAAlB,KAA0B,CAA3B,CAA3B;AACA,UAAIe,CAAC,GAAGkE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,GAAlB,KAA0B,CAA3B,CAA3B;AACA,UAAIqB,EAAE,GAAG4D,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,KAA2B,CAA5B,CAA5B;AACA,UAAIsB,EAAE,GAAG2D,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,KAA2B,CAA5B,CAA5B;AACA,UAAIkF,CAAC,GAAGD,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,OAAlB,CAAD,CAA3B;AACA,UAAImF,CAAC,GAAGF,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,QAAlB,CAAD,CAA3B;AACA,UAAI5D,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACAoB,MAAAA,IAAI,CAAC4E,MAAL,CAAYF,CAAC,GAAG,IAAIO,EAApB,EAAwBN,CAAxB;AACA3E,MAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAC,GAAGoE,CAAJ,GAAQ,IAAI7D,EAAxB,EAA4BN,CAA5B;AACA,UAAIM,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0BlF,IAAI,CAAC8E,aAAL,CAAmBJ,CAAC,GAAGoE,CAAvB,EAA0BnE,CAA1B,EAA6BD,CAAC,GAAGoE,CAAjC,EAAoCnE,CAApC,EAAuCD,CAAC,GAAGoE,CAA3C,EAA8CnE,CAAC,GAAG,IAAIO,EAAtD;AAC1BlF,MAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAC,GAAGoE,CAAhB,EAAmBnE,CAAC,GAAGoE,CAAJ,GAAQ,IAAI7D,EAA/B;AACA,UAAID,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0BlF,IAAI,CAAC8E,aAAL,CAAmBJ,CAAC,GAAGoE,CAAvB,EAA0BnE,CAAC,GAAGoE,CAA9B,EAAiCrE,CAAC,GAAGoE,CAArC,EAAwCnE,CAAC,GAAGoE,CAA5C,EAA+CrE,CAAC,GAAGoE,CAAJ,GAAQ,IAAI7D,EAA3D,EAA+DN,CAAC,GAAGoE,CAAnE;AAC1B/I,MAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAC,GAAG,IAAIO,EAApB,EAAwBN,CAAC,GAAGoE,CAA5B;;AAEA,UAAI9D,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACxBlF,QAAAA,IAAI,CAAC8E,aAAL,CAAmBJ,CAAnB,EAAsBC,CAAC,GAAGoE,CAA1B,EAA6BrE,CAA7B,EAAgCC,CAAC,GAAGoE,CAApC,EAAuCrE,CAAvC,EAA0CC,CAAC,GAAGoE,CAAJ,GAAQ,IAAI7D,EAAtD;AACD;;AAEDlF,MAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAZ,EAAeC,CAAC,GAAG,IAAIO,EAAvB;;AAEA,UAAID,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACxBlF,QAAAA,IAAI,CAAC8E,aAAL,CAAmBJ,CAAnB,EAAsBC,CAAtB,EAAyBD,CAAzB,EAA4BC,CAA5B,EAA+BD,CAAC,GAAG,IAAIO,EAAvC,EAA2CN,CAA3C;AACD;;AAED,aAAO3E,IAAP;AACD;;AAED,aAASwB,gBAAT,CAA0BZ,IAA1B,EAAgC;AAC9B,eAASoI,QAAT,CAAkBlF,KAAlB,EAAyBmF,CAAzB,EAA4BC,CAA5B,EAA+B;AAC7B,YAAIxE,CAAC,GAAGmE,mBAAmB,CAACI,CAAD,CAA3B;AACA,YAAItE,CAAC,GAAGkE,mBAAmB,CAACK,CAAD,CAA3B;;AAEA,YAAIC,KAAK,KAAK,CAAd,EAAiB;AACfnJ,UAAAA,IAAI,CAAC4E,MAAL,CAAYF,CAAZ,EAAeC,CAAf;AACD,SAFD,MAEO;AACL3E,UAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAZ,EAAeC,CAAf;AACD;;AAEDwE,QAAAA,KAAK;AACN;;AAED,UAAIC,KAAK,GAAG,iCAAZ;AACA,UAAIpJ,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACA,UAAIuK,KAAK,GAAG,CAAZ;AACAvI,MAAAA,IAAI,CAACgD,YAAL,CAAkB,QAAlB,EAA4ByF,OAA5B,CAAoCD,KAApC,EAA2CJ,QAA3C;AACAhJ,MAAAA,IAAI,CAACsF,WAAL,CAAiBC,SAAjB,GAA6B,IAA7B;AACA,aAAOvF,IAAP;AACD;;AAED,aAASyB,iBAAT,CAA2Bb,IAA3B,EAAiC;AAC/B,eAASoI,QAAT,CAAkBlF,KAAlB,EAAyBmF,CAAzB,EAA4BC,CAA5B,EAA+B;AAC7B,YAAIxE,CAAC,GAAGmE,mBAAmB,CAACI,CAAD,CAA3B;AACA,YAAItE,CAAC,GAAGkE,mBAAmB,CAACK,CAAD,CAA3B;;AAEA,YAAIC,KAAK,KAAK,CAAd,EAAiB;AACfnJ,UAAAA,IAAI,CAAC4E,MAAL,CAAYF,CAAZ,EAAeC,CAAf;AACD,SAFD,MAEO;AACL3E,UAAAA,IAAI,CAAC6E,MAAL,CAAYH,CAAZ,EAAeC,CAAf;AACD;;AAEDwE,QAAAA,KAAK;AACN;;AAED,UAAIC,KAAK,GAAG,iCAAZ;AACA,UAAIpJ,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACA,UAAIuK,KAAK,GAAG,CAAZ;AACAvI,MAAAA,IAAI,CAACgD,YAAL,CAAkB,QAAlB,EAA4ByF,OAA5B,CAAoCD,KAApC,EAA2CJ,QAA3C;AACAhJ,MAAAA,IAAI,CAACsF,WAAL,CAAiBC,SAAjB,GAA6B,KAA7B;AACA,aAAOvF,IAAP;AACD;;AAED,aAAS0B,eAAT,CAAyBd,IAAzB,EAA+B;AAC7B,UAAI8D,CAAC,GAAGmE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA3B;AACA,UAAIe,CAAC,GAAGkE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA3B;AACA,UAAI0F,CAAC,GAAGT,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,GAAlB,CAAD,CAA3B;AACA,UAAI2F,OAAO,GAAG,IAAI1K,IAAJ,EAAd;AACA0K,MAAAA,OAAO,CAACC,MAAR,CAAe9E,CAAf,EAAkBC,CAAlB,EAAqB2E,CAArB,EAAwB,CAAxB,EAA2B9C,IAAI,CAACC,EAAL,GAAU,CAArC;AACA,UAAIzG,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACAoB,MAAAA,IAAI,CAACyJ,QAAL,CAAc7G,IAAd,CAAmB2G,OAAnB;AACA,aAAOvJ,IAAP;AACD;;AAED,aAAS2B,gBAAT,CAA0Bf,IAA1B,EAAgC;AAC9B,UAAI8D,CAAC,GAAGmE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA3B;AACA,UAAIe,CAAC,GAAGkE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA3B;AACA,UAAIqB,EAAE,GAAG4D,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAIsB,EAAE,GAAG2D,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAI2F,OAAO,GAAG,IAAI1K,IAAJ,EAAd;AACA0K,MAAAA,OAAO,CAACpB,UAAR,CAAmBzD,CAAnB,EAAsBC,CAAtB,EAAyBM,EAAzB,EAA6BC,EAA7B,EAAiC,CAAjC,EAAoCsB,IAAI,CAACC,EAAL,GAAU,CAA9C;AACA,UAAIzG,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACAoB,MAAAA,IAAI,CAACyJ,QAAL,CAAc7G,IAAd,CAAmB2G,OAAnB;AACA,aAAOvJ,IAAP;AACD;;AAED,aAAS4B,aAAT,CAAuBhB,IAAvB,EAA6B;AAC3B,UAAI8I,EAAE,GAAGb,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAI+F,EAAE,GAAGd,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAIgG,EAAE,GAAGf,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAIiG,EAAE,GAAGhB,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAD,CAA5B;AACA,UAAI5D,IAAI,GAAG,IAAIpB,SAAJ,EAAX;AACAoB,MAAAA,IAAI,CAAC4E,MAAL,CAAY8E,EAAZ,EAAgBC,EAAhB;AACA3J,MAAAA,IAAI,CAAC6E,MAAL,CAAY+E,EAAZ,EAAgBC,EAAhB;AACA7J,MAAAA,IAAI,CAACsF,WAAL,CAAiBC,SAAjB,GAA6B,KAA7B;AACA,aAAOvF,IAAP;AACD,KArmBoB,CAqmBnB;;;AAGF,aAASoB,UAAT,CAAoBR,IAApB,EAA0BC,KAA1B,EAAiC;AAC/BA,MAAAA,KAAK,GAAGzB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBwB,KAAlB,CAAR,CAD+B,CACG;;AAElC,UAAIiJ,gBAAgB,GAAG,EAAvB;;AAEA,UAAIlJ,IAAI,CAACS,YAAL,CAAkB,OAAlB,CAAJ,EAAgC;AAC9B,YAAI0I,cAAc,GAAGnJ,IAAI,CAACgD,YAAL,CAAkB,OAAlB,EAA2BmC,KAA3B,CAAiC,IAAjC,EAAuCC,MAAvC,CAA8CC,OAA9C,EAAuDC,GAAvD,CAA2D,UAAAlD,CAAC;AAAA,iBAAIA,CAAC,CAACqB,IAAF,EAAJ;AAAA,SAA5D,CAArB;;AAEA,aAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+G,cAAc,CAAC9G,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C8G,UAAAA,gBAAgB,GAAG1K,MAAM,CAACC,MAAP,CAAcyK,gBAAd,EAAgC3D,WAAW,CAAC,MAAM4D,cAAc,CAAC/G,CAAD,CAArB,CAA3C,CAAnB;AACD;AACF;;AAED,UAAIpC,IAAI,CAACS,YAAL,CAAkB,IAAlB,CAAJ,EAA6B;AAC3ByI,QAAAA,gBAAgB,GAAG1K,MAAM,CAACC,MAAP,CAAcyK,gBAAd,EAAgC3D,WAAW,CAAC,MAAMvF,IAAI,CAACgD,YAAL,CAAkB,IAAlB,CAAP,CAA3C,CAAnB;AACD;;AAED,eAASoG,QAAT,CAAkBC,OAAlB,EAA2BC,MAA3B,EAAmCC,cAAnC,EAAmD;AACjD,YAAIA,cAAc,KAAK7H,SAAvB,EAAkC6H,cAAc,GAAG,SAAS/G,IAAT,CAAcgH,CAAd,EAAiB;AAClE,cAAIA,CAAC,CAACC,UAAF,CAAa,KAAb,CAAJ,EAAyB7J,OAAO,CAAC4B,IAAR,CAAa,yDAAb;AACzB,iBAAOgI,CAAP;AACD,SAHiC;AAIlC,YAAIxJ,IAAI,CAACS,YAAL,CAAkB4I,OAAlB,CAAJ,EAAgCpJ,KAAK,CAACqJ,MAAD,CAAL,GAAgBC,cAAc,CAACvJ,IAAI,CAACgD,YAAL,CAAkBqG,OAAlB,CAAD,CAA9B;AAChC,YAAIH,gBAAgB,CAACG,OAAD,CAApB,EAA+BpJ,KAAK,CAACqJ,MAAD,CAAL,GAAgBC,cAAc,CAACL,gBAAgB,CAACG,OAAD,CAAjB,CAA9B;AAC/B,YAAIrJ,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACC,KAAL,CAAWoJ,OAAX,MAAwB,EAA1C,EAA8CpJ,KAAK,CAACqJ,MAAD,CAAL,GAAgBC,cAAc,CAACvJ,IAAI,CAACC,KAAL,CAAWoJ,OAAX,CAAD,CAA9B;AAC/C;;AAED,eAASK,KAAT,CAAeF,CAAf,EAAkB;AAChB,eAAO5D,IAAI,CAACmB,GAAL,CAAS,CAAT,EAAYnB,IAAI,CAACoC,GAAL,CAAS,CAAT,EAAYC,mBAAmB,CAACuB,CAAD,CAA/B,CAAZ,CAAP;AACD;;AAED,eAASG,QAAT,CAAkBH,CAAlB,EAAqB;AACnB,eAAO5D,IAAI,CAACmB,GAAL,CAAS,CAAT,EAAYkB,mBAAmB,CAACuB,CAAD,CAA/B,CAAP;AACD;;AAEDJ,MAAAA,QAAQ,CAAC,MAAD,EAAS,MAAT,CAAR;AACAA,MAAAA,QAAQ,CAAC,cAAD,EAAiB,aAAjB,EAAgCM,KAAhC,CAAR;AACAN,MAAAA,QAAQ,CAAC,SAAD,EAAY,SAAZ,EAAuBM,KAAvB,CAAR;AACAN,MAAAA,QAAQ,CAAC,QAAD,EAAW,QAAX,CAAR;AACAA,MAAAA,QAAQ,CAAC,gBAAD,EAAmB,eAAnB,EAAoCM,KAApC,CAAR;AACAN,MAAAA,QAAQ,CAAC,cAAD,EAAiB,aAAjB,EAAgCO,QAAhC,CAAR;AACAP,MAAAA,QAAQ,CAAC,iBAAD,EAAoB,gBAApB,CAAR;AACAA,MAAAA,QAAQ,CAAC,gBAAD,EAAmB,eAAnB,CAAR;AACAA,MAAAA,QAAQ,CAAC,mBAAD,EAAsB,kBAAtB,EAA0CO,QAA1C,CAAR;AACAP,MAAAA,QAAQ,CAAC,YAAD,EAAe,YAAf,CAAR;AACA,aAAOnJ,KAAP;AACD,KAtpBoB,CAspBnB;;;AAGF,aAASkE,aAAT,CAAuBkE,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,aAAOD,CAAC,IAAIC,CAAC,GAAGD,CAAR,CAAR;AACD,KA3pBoB,CA2pBnB;;;AAGF,aAAS1E,WAAT,CAAqBiG,KAArB,EAA4B;AAC1B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,cAAM,IAAIC,SAAJ,CAAc,oBAAoB,OAAOD,KAAzC,CAAN;AACD,OAHyB,CAGxB;;;AAGF,UAAIE,EAAE,GAAG;AACPC,QAAAA,SAAS,EAAE,iBADJ;AAEPC,QAAAA,UAAU,EAAE,WAFL;AAGPC,QAAAA,KAAK,EAAE,MAHA;AAIPC,QAAAA,IAAI,EAAE,MAJC;AAKPC,QAAAA,KAAK,EAAE,IALA;AAMPC,QAAAA,KAAK,EAAE,GANA;AAOPC,QAAAA,GAAG,EAAE;AAPE,OAAT,CAN0B,CAcvB;;AAEH,UAAIC,GAAG,GAAG,CAAV;AACA,UAAIC,GAAG,GAAG,CAAV;AACA,UAAIC,KAAK,GAAG,CAAZ;AACA,UAAIH,GAAG,GAAG,CAAV;AACA,UAAII,KAAK,GAAGH,GAAZ;AACA,UAAII,SAAS,GAAG,IAAhB;AACA,UAAIC,MAAM,GAAG,EAAb;AAAA,UACIC,MAAM,GAAG,EADb;AAAA,UAEIC,QAAQ,GAAG,EAFf;;AAIA,eAASC,gBAAT,CAA0BC,OAA1B,EAAmC3I,CAAnC,EAAsC4I,OAAtC,EAA+C;AAC7C,YAAInL,KAAK,GAAG,IAAIoL,WAAJ,CAAgB,2BAA2BF,OAA3B,GAAqC,aAArC,GAAqD3I,CAArD,GAAyD,GAAzE,CAAZ;AACAvC,QAAAA,KAAK,CAACmL,OAAN,GAAgBA,OAAhB;AACA,cAAMnL,KAAN;AACD;;AAED,eAASqL,SAAT,GAAqB;AACnB,YAAIN,MAAM,KAAK,EAAf,EAAmB;AACjB,cAAIC,QAAQ,KAAK,EAAjB,EAAqBF,MAAM,CAAC3I,IAAP,CAAYmJ,MAAM,CAACP,MAAD,CAAlB,EAArB,KAAsDD,MAAM,CAAC3I,IAAP,CAAYmJ,MAAM,CAACP,MAAD,CAAN,GAAiBhF,IAAI,CAACwF,GAAL,CAAS,EAAT,EAAaD,MAAM,CAACN,QAAD,CAAnB,CAA7B;AACvD;;AAEDD,QAAAA,MAAM,GAAG,EAAT;AACAC,QAAAA,QAAQ,GAAG,EAAX;AACD;;AAED,UAAIE,OAAJ;AAAA,UACI3I,CAAC,GAAG,CADR;AAAA,UAEIC,MAAM,GAAGuH,KAAK,CAACvH,MAFnB;;AAIA,WAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,MAAhB,EAAwBD,CAAC,EAAzB,EAA6B;AAC3B2I,QAAAA,OAAO,GAAGnB,KAAK,CAACxH,CAAD,CAAf,CAD2B,CACP;;AAEpB,YAAIqI,KAAK,KAAKH,GAAd,EAAmB;AACjB;AACA,cAAIR,EAAE,CAACE,UAAH,CAAcqB,IAAd,CAAmBN,OAAnB,CAAJ,EAAiC;AAC/B;AACD,WAJgB,CAIf;;;AAGF,cAAIjB,EAAE,CAACG,KAAH,CAASoB,IAAT,CAAcN,OAAd,KAA0BjB,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaN,OAAb,CAA9B,EAAqD;AACnDN,YAAAA,KAAK,GAAGF,GAAR;AACAK,YAAAA,MAAM,GAAGG,OAAT;AACA;AACD;;AAED,cAAIjB,EAAE,CAACK,KAAH,CAASkB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1BN,YAAAA,KAAK,GAAGD,KAAR;AACAI,YAAAA,MAAM,GAAGG,OAAT;AACA;AACD,WAjBgB,CAiBf;;;AAGF,cAAIjB,EAAE,CAACM,KAAH,CAASiB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1B,gBAAIL,SAAJ,EAAe;AACbI,cAAAA,gBAAgB,CAACC,OAAD,EAAU3I,CAAV,EAAauI,MAAb,CAAhB;AACD;;AAEDD,YAAAA,SAAS,GAAG,IAAZ;AACD;AACF,SA9B0B,CA8BzB;;;AAGF,YAAID,KAAK,KAAKF,GAAd,EAAmB;AACjB,cAAIT,EAAE,CAACG,KAAH,CAASoB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1BH,YAAAA,MAAM,IAAIG,OAAV;AACA;AACD;;AAED,cAAIjB,EAAE,CAACK,KAAH,CAASkB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1BH,YAAAA,MAAM,IAAIG,OAAV;AACAN,YAAAA,KAAK,GAAGD,KAAR;AACA;AACD;;AAED,cAAIV,EAAE,CAACO,GAAH,CAAOgB,IAAP,CAAYN,OAAZ,CAAJ,EAA0B;AACxBN,YAAAA,KAAK,GAAGJ,GAAR;AACA;AACD,WAfgB,CAef;;;AAGF,cAAIP,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaN,OAAb,KAAyBH,MAAM,CAACvI,MAAP,KAAkB,CAA3C,IAAgDyH,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaT,MAAM,CAAC,CAAD,CAAnB,CAApD,EAA6E;AAC3EE,YAAAA,gBAAgB,CAACC,OAAD,EAAU3I,CAAV,EAAauI,MAAb,CAAhB;AACD;AACF,SAtD0B,CAsDzB;;;AAGF,YAAIF,KAAK,KAAKD,KAAd,EAAqB;AACnB,cAAIV,EAAE,CAACG,KAAH,CAASoB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1BH,YAAAA,MAAM,IAAIG,OAAV;AACA;AACD;;AAED,cAAIjB,EAAE,CAACO,GAAH,CAAOgB,IAAP,CAAYN,OAAZ,CAAJ,EAA0B;AACxBN,YAAAA,KAAK,GAAGJ,GAAR;AACA;AACD,WATkB,CASjB;;;AAGF,cAAIP,EAAE,CAACK,KAAH,CAASkB,IAAT,CAAcN,OAAd,KAA0BH,MAAM,CAACA,MAAM,CAACvI,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAA5D,EAAiE;AAC/DyI,YAAAA,gBAAgB,CAACC,OAAD,EAAU3I,CAAV,EAAauI,MAAb,CAAhB;AACD;AACF,SAxE0B,CAwEzB;;;AAGF,YAAIF,KAAK,IAAIJ,GAAb,EAAkB;AAChB,cAAIP,EAAE,CAACG,KAAH,CAASoB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AAC1BF,YAAAA,QAAQ,IAAIE,OAAZ;AACA;AACD;;AAED,cAAIjB,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaN,OAAb,CAAJ,EAA2B;AACzB,gBAAIF,QAAQ,KAAK,EAAjB,EAAqB;AACnBA,cAAAA,QAAQ,IAAIE,OAAZ;AACA;AACD;;AAED,gBAAIF,QAAQ,CAACxI,MAAT,KAAoB,CAApB,IAAyByH,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaR,QAAb,CAA7B,EAAqD;AACnDC,cAAAA,gBAAgB,CAACC,OAAD,EAAU3I,CAAV,EAAauI,MAAb,CAAhB;AACD;AACF;AACF,SA3F0B,CA2FzB;;;AAGF,YAAIb,EAAE,CAACE,UAAH,CAAcqB,IAAd,CAAmBN,OAAnB,CAAJ,EAAiC;AAC/BG,UAAAA,SAAS;AACTT,UAAAA,KAAK,GAAGH,GAAR;AACAI,UAAAA,SAAS,GAAG,KAAZ;AACD,SAJD,MAIO,IAAIZ,EAAE,CAACM,KAAH,CAASiB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AACjCG,UAAAA,SAAS;AACTT,UAAAA,KAAK,GAAGH,GAAR;AACAI,UAAAA,SAAS,GAAG,IAAZ;AACD,SAJM,MAIA,IAAIZ,EAAE,CAACI,IAAH,CAAQmB,IAAR,CAAaN,OAAb,CAAJ,EAA2B;AAChCG,UAAAA,SAAS;AACTT,UAAAA,KAAK,GAAGF,GAAR;AACAK,UAAAA,MAAM,GAAGG,OAAT;AACD,SAJM,MAIA,IAAIjB,EAAE,CAACK,KAAH,CAASkB,IAAT,CAAcN,OAAd,CAAJ,EAA4B;AACjCG,UAAAA,SAAS;AACTT,UAAAA,KAAK,GAAGD,KAAR;AACAI,UAAAA,MAAM,GAAGG,OAAT;AACD,SAJM,MAIA;AACLD,UAAAA,gBAAgB,CAACC,OAAD,EAAU3I,CAAV,EAAauI,MAAb,CAAhB;AACD;AACF,OA9JyB,CA8JxB;;;AAGFO,MAAAA,SAAS;AACT,aAAOP,MAAP;AACD,KAj0BoB,CAi0BnB;;;AAGF,QAAIW,KAAK,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAZ,CAp0BqB,CAo0B6B;;AAElD,QAAIC,cAAc,GAAG;AACnBC,MAAAA,EAAE,EAAE;AACFA,QAAAA,EAAE,EAAE,CADF;AAEFC,QAAAA,EAAE,EAAE,GAFF;AAGFC,QAAAA,EAAE,EAAE,IAAI,IAHN;AAIFC,QAAAA,EAAE,EAAE,KAAK,IAJP;AAKFC,QAAAA,EAAE,EAAE,IAAI,IALN;AAMFC,QAAAA,EAAE,EAAE,CAAC;AANH,OADe;AASnBJ,MAAAA,EAAE,EAAE;AACFD,QAAAA,EAAE,EAAE,EADF;AAEFC,QAAAA,EAAE,EAAE,CAFF;AAGFC,QAAAA,EAAE,EAAE,IAAI,IAHN;AAIFC,QAAAA,EAAE,EAAE,KAAK,IAJP;AAKFC,QAAAA,EAAE,EAAE,IAAI,IALN;AAMFC,QAAAA,EAAE,EAAE,CAAC;AANH,OATe;AAiBnBH,MAAAA,EAAE,EAAE;AACFF,QAAAA,EAAE,EAAE,IADF;AAEFC,QAAAA,EAAE,EAAE,IAFF;AAGFC,QAAAA,EAAE,EAAE,CAHF;AAIFC,QAAAA,EAAE,EAAE,EAJF;AAKFC,QAAAA,EAAE,EAAE,CALF;AAMFC,QAAAA,EAAE,EAAE,CAAC;AANH,OAjBe;AAyBnBF,MAAAA,EAAE,EAAE;AACFH,QAAAA,EAAE,EAAE,OAAO,EADT;AAEFC,QAAAA,EAAE,EAAE,OAAO,EAFT;AAGFC,QAAAA,EAAE,EAAE,IAAI,EAHN;AAIFC,QAAAA,EAAE,EAAE,CAJF;AAKFC,QAAAA,EAAE,EAAE,IAAI,EALN;AAMFC,QAAAA,EAAE,EAAE,CAAC;AANH,OAzBe;AAiCnBD,MAAAA,EAAE,EAAE;AACFJ,QAAAA,EAAE,EAAE,OAAO,CADT;AAEFC,QAAAA,EAAE,EAAE,OAAO,CAFT;AAGFC,QAAAA,EAAE,EAAE,IAAI,CAHN;AAIFC,QAAAA,EAAE,EAAE,KAAK,CAJP;AAKFC,QAAAA,EAAE,EAAE,CALF;AAMFC,QAAAA,EAAE,EAAE,CAAC;AANH,OAjCe;AAyCnBA,MAAAA,EAAE,EAAE;AACFA,QAAAA,EAAE,EAAE;AADF;AAzCe,KAArB;;AA8CA,aAAS5D,mBAAT,CAA6B6D,MAA7B,EAAqC;AACnC,UAAIC,OAAO,GAAG,IAAd;;AAEA,UAAI,OAAOD,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,YAAYE,MAApD,EAA4D;AAC1D,aAAK,IAAI5J,CAAC,GAAG,CAAR,EAAW6J,CAAC,GAAGX,KAAK,CAACjJ,MAA1B,EAAkCD,CAAC,GAAG6J,CAAtC,EAAyC7J,CAAC,EAA1C,EAA8C;AAC5C,cAAI8J,CAAC,GAAGZ,KAAK,CAAClJ,CAAD,CAAb;;AAEA,cAAI0J,MAAM,CAACK,QAAP,CAAgBD,CAAhB,CAAJ,EAAwB;AACtBH,YAAAA,OAAO,GAAGG,CAAV;AACAJ,YAAAA,MAAM,GAAGA,MAAM,CAAC1K,SAAP,CAAiB,CAAjB,EAAoB0K,MAAM,CAACzJ,MAAP,GAAgB6J,CAAC,CAAC7J,MAAtC,CAAT;AACA;AACD;AACF;AACF;;AAED,UAAI+J,KAAK,GAAG1K,SAAZ;;AAEA,UAAIqK,OAAO,KAAK,IAAZ,IAAoB9M,KAAK,CAACX,WAAN,KAAsB,IAA9C,EAAoD;AAClD;AACA8N,QAAAA,KAAK,GAAGb,cAAc,CAAC,IAAD,CAAd,CAAqBtM,KAAK,CAACX,WAA3B,IAA0CW,KAAK,CAACZ,UAAxD;AACD,OAHD,MAGO;AACL+N,QAAAA,KAAK,GAAGb,cAAc,CAACQ,OAAD,CAAd,CAAwB9M,KAAK,CAACX,WAA9B,CAAR;;AAEA,YAAI8N,KAAK,GAAG,CAAZ,EAAe;AACb;AACAA,UAAAA,KAAK,GAAGb,cAAc,CAACQ,OAAD,CAAd,CAAwB,IAAxB,IAAgC9M,KAAK,CAACZ,UAA9C;AACD;AACF;;AAED,aAAO+N,KAAK,GAAGC,UAAU,CAACP,MAAD,CAAzB;AACD,KAl5BoB,CAk5BnB;;;AAGF,aAAS1L,gBAAT,CAA0BJ,IAA1B,EAAgC;AAC9B,UAAI,EAAEA,IAAI,CAACS,YAAL,CAAkB,WAAlB,KAAkCT,IAAI,CAACM,QAAL,KAAkB,KAAlB,KAA4BN,IAAI,CAACS,YAAL,CAAkB,GAAlB,KAA0BT,IAAI,CAACS,YAAL,CAAkB,GAAlB,CAAtD,CAApC,CAAJ,EAAwH;AACtH,eAAO,IAAP;AACD;;AAED,UAAIN,SAAS,GAAGmM,kBAAkB,CAACtM,IAAD,CAAlC;;AAEA,UAAIsC,cAAc,CAACD,MAAf,GAAwB,CAA5B,EAA+B;AAC7BlC,QAAAA,SAAS,CAACoM,WAAV,CAAsBjK,cAAc,CAACA,cAAc,CAACD,MAAf,GAAwB,CAAzB,CAApC;AACD;;AAEDP,MAAAA,gBAAgB,CAACU,IAAjB,CAAsBrC,SAAtB;AACAmC,MAAAA,cAAc,CAACN,IAAf,CAAoB7B,SAApB;AACA,aAAOA,SAAP;AACD;;AAED,aAASmM,kBAAT,CAA4BtM,IAA5B,EAAkC;AAChC,UAAIG,SAAS,GAAG,IAAIxC,OAAJ,EAAhB;AACA,UAAImE,gBAAgB,GAAG0K,cAAvB;;AAEA,UAAIxM,IAAI,CAACM,QAAL,KAAkB,KAAlB,KAA4BN,IAAI,CAACS,YAAL,CAAkB,GAAlB,KAA0BT,IAAI,CAACS,YAAL,CAAkB,GAAlB,CAAtD,CAAJ,EAAmF;AACjF,YAAIgM,EAAE,GAAGxE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,GAAlB,CAAD,CAA5B;AACA,YAAI0J,EAAE,GAAGzE,mBAAmB,CAACjI,IAAI,CAACgD,YAAL,CAAkB,GAAlB,CAAD,CAA5B;AACA7C,QAAAA,SAAS,CAACwM,SAAV,CAAoBF,EAApB,EAAwBC,EAAxB;AACD;;AAED,UAAI1M,IAAI,CAACS,YAAL,CAAkB,WAAlB,CAAJ,EAAoC;AAClC,YAAImM,eAAe,GAAG5M,IAAI,CAACgD,YAAL,CAAkB,WAAlB,EAA+BmC,KAA/B,CAAqC,GAArC,CAAtB;;AAEA,aAAK,IAAI0H,MAAM,GAAGD,eAAe,CAACvK,MAAhB,GAAyB,CAA3C,EAA8CwK,MAAM,IAAI,CAAxD,EAA2DA,MAAM,EAAjE,EAAqE;AACnE,cAAIC,aAAa,GAAGF,eAAe,CAACC,MAAD,CAAf,CAAwBpJ,IAAxB,EAApB;AACA,cAAIqJ,aAAa,KAAK,EAAtB,EAA0B;AAC1B,cAAIC,UAAU,GAAGD,aAAa,CAACE,OAAd,CAAsB,GAAtB,CAAjB;AACA,cAAIC,WAAW,GAAGH,aAAa,CAACzK,MAAhC;;AAEA,cAAI0K,UAAU,GAAG,CAAb,IAAkBA,UAAU,GAAGE,WAAnC,EAAgD;AAC9C,gBAAIC,aAAa,GAAGJ,aAAa,CAACtJ,MAAd,CAAqB,CAArB,EAAwBuJ,UAAxB,CAApB;AACA,gBAAII,KAAK,GAAGxJ,WAAW,CAACmJ,aAAa,CAACtJ,MAAd,CAAqBuJ,UAAU,GAAG,CAAlC,EAAqCE,WAAW,GAAGF,UAAd,GAA2B,CAAhE,CAAD,CAAvB;AACAjL,YAAAA,gBAAgB,CAACW,QAAjB;;AAEA,oBAAQyK,aAAR;AACE,mBAAK,WAAL;AACE,oBAAIC,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrB,sBAAIoK,EAAE,GAAGU,KAAK,CAAC,CAAD,CAAd;AACA,sBAAIT,EAAE,GAAGD,EAAT;;AAEA,sBAAIU,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrBqK,oBAAAA,EAAE,GAAGS,KAAK,CAAC,CAAD,CAAV;AACD;;AAEDrL,kBAAAA,gBAAgB,CAAC6K,SAAjB,CAA2BF,EAA3B,EAA+BC,EAA/B;AACD;;AAED;;AAEF,mBAAK,QAAL;AACE,oBAAIS,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrB,sBAAI+K,KAAK,GAAG,CAAZ;AACA,sBAAIlG,EAAE,GAAG,CAAT;AACA,sBAAIC,EAAE,GAAG,CAAT,CAHqB,CAGT;;AAEZiG,kBAAAA,KAAK,GAAG,CAACD,KAAK,CAAC,CAAD,CAAN,GAAYvH,IAAI,CAACC,EAAjB,GAAsB,GAA9B;;AAEA,sBAAIsH,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrB;AACA6E,oBAAAA,EAAE,GAAGiG,KAAK,CAAC,CAAD,CAAV;AACAhG,oBAAAA,EAAE,GAAGgG,KAAK,CAAC,CAAD,CAAV;AACD,mBAXoB,CAWnB;;;AAGFE,kBAAAA,cAAc,CAAC5K,QAAf,GAA0BkK,SAA1B,CAAoC,CAACzF,EAArC,EAAyC,CAACC,EAA1C;AACAmG,kBAAAA,cAAc,CAAC7K,QAAf,GAA0B8K,MAA1B,CAAiCH,KAAjC;AACAI,kBAAAA,cAAc,CAACC,gBAAf,CAAgCH,cAAhC,EAAgDD,cAAhD;AACAA,kBAAAA,cAAc,CAAC5K,QAAf,GAA0BkK,SAA1B,CAAoCzF,EAApC,EAAwCC,EAAxC;AACArF,kBAAAA,gBAAgB,CAAC2L,gBAAjB,CAAkCJ,cAAlC,EAAkDG,cAAlD;AACD;;AAED;;AAEF,mBAAK,OAAL;AACE,oBAAIL,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrB,sBAAIqL,MAAM,GAAGP,KAAK,CAAC,CAAD,CAAlB;AACA,sBAAIQ,MAAM,GAAGD,MAAb;;AAEA,sBAAIP,KAAK,CAAC9K,MAAN,IAAgB,CAApB,EAAuB;AACrBsL,oBAAAA,MAAM,GAAGR,KAAK,CAAC,CAAD,CAAd;AACD;;AAEDrL,kBAAAA,gBAAgB,CAACsK,KAAjB,CAAuBsB,MAAvB,EAA+BC,MAA/B;AACD;;AAED;;AAEF,mBAAK,OAAL;AACE,oBAAIR,KAAK,CAAC9K,MAAN,KAAiB,CAArB,EAAwB;AACtBP,kBAAAA,gBAAgB,CAAC8L,GAAjB,CAAqB,CAArB,EAAwBhI,IAAI,CAACiI,GAAL,CAASV,KAAK,CAAC,CAAD,CAAL,GAAWvH,IAAI,CAACC,EAAhB,GAAqB,GAA9B,CAAxB,EAA4D,CAA5D,EAA+D,CAA/D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,EAA2E,CAA3E,EAA8E,CAA9E;AACD;;AAED;;AAEF,mBAAK,OAAL;AACE,oBAAIsH,KAAK,CAAC9K,MAAN,KAAiB,CAArB,EAAwB;AACtBP,kBAAAA,gBAAgB,CAAC8L,GAAjB,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8BhI,IAAI,CAACiI,GAAL,CAASV,KAAK,CAAC,CAAD,CAAL,GAAWvH,IAAI,CAACC,EAAhB,GAAqB,GAA9B,CAA9B,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,EAA2E,CAA3E,EAA8E,CAA9E;AACD;;AAED;;AAEF,mBAAK,QAAL;AACE,oBAAIsH,KAAK,CAAC9K,MAAN,KAAiB,CAArB,EAAwB;AACtBP,kBAAAA,gBAAgB,CAAC8L,GAAjB,CAAqBT,KAAK,CAAC,CAAD,CAA1B,EAA+BA,KAAK,CAAC,CAAD,CAApC,EAAyCA,KAAK,CAAC,CAAD,CAA9C,EAAmDA,KAAK,CAAC,CAAD,CAAxD,EAA6DA,KAAK,CAAC,CAAD,CAAlE,EAAuEA,KAAK,CAAC,CAAD,CAA5E,EAAiF,CAAjF,EAAoF,CAApF,EAAuF,CAAvF;AACD;;AAED;AAxEJ;AA0ED;;AAEDhN,UAAAA,SAAS,CAACoM,WAAV,CAAsBzK,gBAAtB;AACD;AACF;;AAED,aAAO3B,SAAP;AACD;;AAED,aAAS0B,aAAT,CAAuBzC,IAAvB,EAA6B0O,CAA7B,EAAgC;AAC9B,eAASC,UAAT,CAAoBC,EAApB,EAAwB;AACtBC,QAAAA,MAAM,CAACL,GAAP,CAAWI,EAAE,CAAClK,CAAd,EAAiBkK,EAAE,CAACjK,CAApB,EAAuB,CAAvB,EAA0BmK,YAA1B,CAAuCJ,CAAvC;AACAE,QAAAA,EAAE,CAACJ,GAAH,CAAOK,MAAM,CAACnK,CAAd,EAAiBmK,MAAM,CAAClK,CAAxB;AACD;;AAED,UAAIoK,SAAS,GAAGC,kBAAkB,CAACN,CAAD,CAAlC;AACA,UAAIjF,QAAQ,GAAGzJ,IAAI,CAACyJ,QAApB;;AAEA,WAAK,IAAIzG,CAAC,GAAG,CAAR,EAAW6J,CAAC,GAAGpD,QAAQ,CAACxG,MAA7B,EAAqCD,CAAC,GAAG6J,CAAzC,EAA4C7J,CAAC,EAA7C,EAAiD;AAC/C,YAAIiM,OAAO,GAAGxF,QAAQ,CAACzG,CAAD,CAAtB;AACA,YAAIwC,MAAM,GAAGyJ,OAAO,CAACzJ,MAArB;;AAEA,aAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,MAAM,CAACvC,MAA3B,EAAmCuB,CAAC,EAApC,EAAwC;AACtC,cAAI0K,KAAK,GAAG1J,MAAM,CAAChB,CAAD,CAAlB;;AAEA,cAAI0K,KAAK,CAACC,WAAV,EAAuB;AACrBR,YAAAA,UAAU,CAACO,KAAK,CAACE,EAAP,CAAV;AACAT,YAAAA,UAAU,CAACO,KAAK,CAACN,EAAP,CAAV;AACD,WAHD,MAGO,IAAIM,KAAK,CAACG,kBAAV,EAA8B;AACnCV,YAAAA,UAAU,CAACO,KAAK,CAACI,EAAP,CAAV;AACAX,YAAAA,UAAU,CAACO,KAAK,CAACE,EAAP,CAAV;AACAT,YAAAA,UAAU,CAACO,KAAK,CAACN,EAAP,CAAV;AACAD,YAAAA,UAAU,CAACO,KAAK,CAACK,EAAP,CAAV;AACD,WALM,MAKA,IAAIL,KAAK,CAACM,sBAAV,EAAkC;AACvCb,YAAAA,UAAU,CAACO,KAAK,CAACI,EAAP,CAAV;AACAX,YAAAA,UAAU,CAACO,KAAK,CAACE,EAAP,CAAV;AACAT,YAAAA,UAAU,CAACO,KAAK,CAACN,EAAP,CAAV;AACD,WAJM,MAIA,IAAIM,KAAK,CAACO,cAAV,EAA0B;AAC/B,gBAAIV,SAAJ,EAAe;AACbvO,cAAAA,OAAO,CAAC4B,IAAR,CAAa,4EAAb;AACD;;AAEDsN,YAAAA,MAAM,CAAClB,GAAP,CAAWU,KAAK,CAACS,EAAjB,EAAqBT,KAAK,CAACU,EAA3B;AACAjB,YAAAA,UAAU,CAACe,MAAD,CAAV;AACAR,YAAAA,KAAK,CAACS,EAAN,GAAWD,MAAM,CAAChL,CAAlB;AACAwK,YAAAA,KAAK,CAACU,EAAN,GAAWF,MAAM,CAAC/K,CAAlB;AACAuK,YAAAA,KAAK,CAACW,OAAN,IAAiBC,kBAAkB,CAACpB,CAAD,CAAnC;AACAQ,YAAAA,KAAK,CAACa,OAAN,IAAiBC,kBAAkB,CAACtB,CAAD,CAAnC;AACD;AACF;AACF;AACF;;AAED,aAASM,kBAAT,CAA4BN,CAA5B,EAA+B;AAC7B,aAAOA,CAAC,CAACuB,QAAF,CAAW,CAAX,MAAkB,CAAlB,IAAuBvB,CAAC,CAACuB,QAAF,CAAW,CAAX,MAAkB,CAAhD;AACD;;AAED,aAASH,kBAAT,CAA4BpB,CAA5B,EAA+B;AAC7B,UAAIwB,EAAE,GAAGxB,CAAC,CAACuB,QAAX;AACA,aAAOzJ,IAAI,CAACe,IAAL,CAAU2I,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAAV,GAAgBA,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAApC,CAAP;AACD;;AAED,aAASF,kBAAT,CAA4BtB,CAA5B,EAA+B;AAC7B,UAAIwB,EAAE,GAAGxB,CAAC,CAACuB,QAAX;AACA,aAAOzJ,IAAI,CAACe,IAAL,CAAU2I,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAAV,GAAgBA,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAApC,CAAP;AACD,KAxkCoB,CAwkCnB;;;AAGF,QAAIvN,KAAK,GAAG,EAAZ;AACA,QAAIwD,WAAW,GAAG,EAAlB;AACA,QAAIjD,cAAc,GAAG,EAArB;AACA,QAAIkK,cAAc,GAAG,IAAI7O,OAAJ,EAArB;AACA,QAAI0P,cAAc,GAAG,IAAI1P,OAAJ,EAArB;AACA,QAAI2P,cAAc,GAAG,IAAI3P,OAAJ,EAArB;AACA,QAAI6P,cAAc,GAAG,IAAI7P,OAAJ,EAArB;AACA,QAAImR,MAAM,GAAG,IAAIlR,OAAJ,EAAb;AACA,QAAIqQ,MAAM,GAAG,IAAIpQ,OAAJ,EAAb;AACA,QAAIiE,gBAAgB,GAAG,IAAInE,OAAJ,EAAvB;AACA,QAAI4R,GAAG,GAAG,IAAIC,SAAJ,GAAgBC,eAAhB,CAAgChQ,IAAhC,EAAsC,eAAtC,CAAV,CArlCqB,CAqlC6C;;AAElEM,IAAAA,SAAS,CAACwP,GAAG,CAACG,eAAL,EAAsB;AAC7BjO,MAAAA,IAAI,EAAE,MADuB;AAE7BkO,MAAAA,WAAW,EAAE,CAFgB;AAG7BC,MAAAA,aAAa,EAAE,CAHc;AAI7BC,MAAAA,WAAW,EAAE,CAJgB;AAK7BC,MAAAA,cAAc,EAAE,OALa;AAM7BC,MAAAA,aAAa,EAAE,MANc;AAO7BC,MAAAA,gBAAgB,EAAE;AAPW,KAAtB,CAAT;AASA,QAAIzM,IAAI,GAAG;AACTxB,MAAAA,KAAK,EAAEA,KADE;AAETwN,MAAAA,GAAG,EAAEA,GAAG,CAACG;AAFA,KAAX,CAhmCqB,CAmmClB;;AAEH,WAAOnM,IAAP;AACD;AA5nCkE,CAA/C,CAAtB;;AA+nCArF,SAAS,CAAC+R,cAAV,GAA2B,UAAUC,KAAV,EAAiBvO,KAAjB,EAAwBwO,QAAxB,EAAkCC,OAAlC,EAA2CC,UAA3C,EAAuD;AAChF;AACA;AACA;AACA;AACA;AACA;AACAH,EAAAA,KAAK,GAAGA,KAAK,KAAKxO,SAAV,GAAsBwO,KAAtB,GAA8B,CAAtC;AACAvO,EAAAA,KAAK,GAAGA,KAAK,KAAKD,SAAV,GAAsBC,KAAtB,GAA8B,MAAtC;AACAwO,EAAAA,QAAQ,GAAGA,QAAQ,KAAKzO,SAAb,GAAyByO,QAAzB,GAAoC,OAA/C;AACAC,EAAAA,OAAO,GAAGA,OAAO,KAAK1O,SAAZ,GAAwB0O,OAAxB,GAAkC,MAA5C;AACAC,EAAAA,UAAU,GAAGA,UAAU,KAAK3O,SAAf,GAA2B2O,UAA3B,GAAwC,CAArD;AACA,SAAO;AACLC,IAAAA,WAAW,EAAE3O,KADR;AAELkO,IAAAA,WAAW,EAAEK,KAFR;AAGLJ,IAAAA,cAAc,EAAEK,QAHX;AAILJ,IAAAA,aAAa,EAAEK,OAJV;AAKLJ,IAAAA,gBAAgB,EAAEK;AALb,GAAP;AAOD,CAnBD;;AAqBAnS,SAAS,CAACqS,cAAV,GAA2B,UAAUC,MAAV,EAAkBvQ,KAAlB,EAAyBwQ,YAAzB,EAAuCC,WAAvC,EAAoD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,GAAG,GAAG,EAAV;;AAEA,MAAI3S,SAAS,CAAC4S,yBAAV,CAAoCN,MAApC,EAA4CvQ,KAA5C,EAAmDwQ,YAAnD,EAAiEC,WAAjE,EAA8EC,QAA9E,EAAwFC,OAAxF,EAAiGC,GAAjG,MAA0G,CAA9G,EAAiH;AAC/G,WAAO,IAAP;AACD;;AAED,MAAIE,QAAQ,GAAG,IAAIjT,cAAJ,EAAf;AACAiT,EAAAA,QAAQ,CAACC,YAAT,CAAsB,UAAtB,EAAkC,IAAIjT,sBAAJ,CAA2B4S,QAA3B,EAAqC,CAArC,CAAlC;AACAI,EAAAA,QAAQ,CAACC,YAAT,CAAsB,QAAtB,EAAgC,IAAIjT,sBAAJ,CAA2B6S,OAA3B,EAAoC,CAApC,CAAhC;AACAG,EAAAA,QAAQ,CAACC,YAAT,CAAsB,IAAtB,EAA4B,IAAIjT,sBAAJ,CAA2B8S,GAA3B,EAAgC,CAAhC,CAA5B;AACA,SAAOE,QAAP;AACD,CArBD;;AAuBA7S,SAAS,CAAC4S,yBAAV,GAAsC,YAAY;AAChD,MAAIG,QAAQ,GAAG,IAAIrT,OAAJ,EAAf;AACA,MAAIsT,QAAQ,GAAG,IAAItT,OAAJ,EAAf;AACA,MAAIuT,QAAQ,GAAG,IAAIvT,OAAJ,EAAf;AACA,MAAIwT,QAAQ,GAAG,IAAIxT,OAAJ,EAAf;AACA,MAAIyT,QAAQ,GAAG,IAAIzT,OAAJ,EAAf;AACA,MAAI0T,QAAQ,GAAG,IAAI1T,OAAJ,EAAf;AACA,MAAI2T,QAAQ,GAAG,IAAI3T,OAAJ,EAAf;AACA,MAAI4T,UAAU,GAAG,IAAI5T,OAAJ,EAAjB;AACA,MAAI6T,UAAU,GAAG,IAAI7T,OAAJ,EAAjB;AACA,MAAI8T,OAAO,GAAG,IAAI9T,OAAJ,EAAd;AACA,MAAI+T,OAAO,GAAG,IAAI/T,OAAJ,EAAd;AACA,MAAIgU,aAAa,GAAG,IAAIhU,OAAJ,EAApB;AACA,MAAIiU,aAAa,GAAG,IAAIjU,OAAJ,EAApB;AACA,MAAIkU,UAAU,GAAG,IAAIlU,OAAJ,EAAjB;AACA,MAAImU,UAAU,GAAG,IAAInU,OAAJ,EAAjB;AACA,MAAIoU,UAAU,GAAG,IAAIpU,OAAJ,EAAjB;AACA,MAAIqU,UAAU,GAAG,IAAIrU,OAAJ,EAAjB;AACA,SAAO,UAAU4S,MAAV,EAAkBvQ,KAAlB,EAAyBwQ,YAAzB,EAAuCC,WAAvC,EAAoDC,QAApD,EAA8DC,OAA9D,EAAuEC,GAAvE,EAA4EqB,YAA5E,EAA0F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACAzB,IAAAA,YAAY,GAAGA,YAAY,KAAK/O,SAAjB,GAA6B+O,YAA7B,GAA4C,EAA3D;AACAC,IAAAA,WAAW,GAAGA,WAAW,KAAKhP,SAAhB,GAA4BgP,WAA5B,GAA0C,KAAxD;AACAwB,IAAAA,YAAY,GAAGA,YAAY,KAAKxQ,SAAjB,GAA6BwQ,YAA7B,GAA4C,CAA3D,CAT+F,CASjC;;AAE9D1B,IAAAA,MAAM,GAAG2B,sBAAsB,CAAC3B,MAAD,CAA/B;AACA,QAAI4B,SAAS,GAAG5B,MAAM,CAACnO,MAAvB;AACA,QAAI+P,SAAS,GAAG,CAAhB,EAAmB,OAAO,CAAP;AACnB,QAAIC,QAAQ,GAAG7B,MAAM,CAAC,CAAD,CAAN,CAAU8B,MAAV,CAAiB9B,MAAM,CAAC4B,SAAS,GAAG,CAAb,CAAvB,CAAf;AACA,QAAIvN,YAAJ;AACA,QAAI0N,aAAa,GAAG/B,MAAM,CAAC,CAAD,CAA1B;AACA,QAAIgC,SAAJ;AACA,QAAIC,YAAY,GAAGxS,KAAK,CAAC4P,WAAN,GAAoB,CAAvC;AACA,QAAI6C,MAAM,GAAG,KAAKN,SAAS,GAAG,CAAjB,CAAb;AACA,QAAIO,EAAE,GAAG,CAAT;AACA,QAAIC,iBAAJ;AACA,QAAIC,gBAAJ;AACA,QAAIC,OAAJ;AACA,QAAIC,uBAAuB,GAAG,KAA9B;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,iBAAiB,GAAGf,YAAY,GAAG,CAAvC;AACA,QAAIgB,mBAAmB,GAAGhB,YAAY,GAAG,CAAzC,CA3B+F,CA2BnD;;AAE5CiB,IAAAA,SAAS,CAAC3C,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB,EAAuBS,QAAvB,CAAT,CAA0CmC,cAA1C,CAAyDX,YAAzD;AACAjB,IAAAA,UAAU,CAAChP,IAAX,CAAgBgO,MAAM,CAAC,CAAD,CAAtB,EAA2B6C,GAA3B,CAA+BpC,QAA/B;AACAQ,IAAAA,UAAU,CAACjP,IAAX,CAAgBgO,MAAM,CAAC,CAAD,CAAtB,EAA2B8C,GAA3B,CAA+BrC,QAA/B;AACAS,IAAAA,OAAO,CAAClP,IAAR,CAAagP,UAAb;AACAG,IAAAA,OAAO,CAACnP,IAAR,CAAaiP,UAAb;;AAEA,SAAK,IAAI8B,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGnB,SAA9B,EAAyCmB,MAAM,EAA/C,EAAmD;AACjD1O,MAAAA,YAAY,GAAG2L,MAAM,CAAC+C,MAAD,CAArB,CADiD,CAClB;;AAE/B,UAAIA,MAAM,KAAKnB,SAAS,GAAG,CAA3B,EAA8B;AAC5B,YAAIC,QAAJ,EAAc;AACZ;AACAG,UAAAA,SAAS,GAAGhC,MAAM,CAAC,CAAD,CAAlB;AACD,SAHD,MAGOgC,SAAS,GAAG9Q,SAAZ;AACR,OALD,MAKO;AACL8Q,QAAAA,SAAS,GAAGhC,MAAM,CAAC+C,MAAM,GAAG,CAAV,CAAlB;AACD,OAVgD,CAU/C;;;AAGF,UAAIC,OAAO,GAAGvC,QAAd;AACAkC,MAAAA,SAAS,CAACZ,aAAD,EAAgB1N,YAAhB,EAA8B2O,OAA9B,CAAT;AACArC,MAAAA,QAAQ,CAAC3O,IAAT,CAAcgR,OAAd,EAAuBJ,cAAvB,CAAsCX,YAAtC;AACAb,MAAAA,aAAa,CAACpP,IAAd,CAAmBqC,YAAnB,EAAiCwO,GAAjC,CAAqClC,QAArC;AACAU,MAAAA,aAAa,CAACrP,IAAd,CAAmBqC,YAAnB,EAAiCyO,GAAjC,CAAqCnC,QAArC;AACA,UAAIsC,EAAE,GAAGd,EAAE,GAAGD,MAAd;AACAE,MAAAA,iBAAiB,GAAG,KAApB;;AAEA,UAAIJ,SAAS,KAAK9Q,SAAlB,EAA6B;AAC3B;AACAyR,QAAAA,SAAS,CAACtO,YAAD,EAAe2N,SAAf,EAA0BtB,QAA1B,CAAT;AACAC,QAAAA,QAAQ,CAAC3O,IAAT,CAAc0O,QAAd,EAAwBkC,cAAxB,CAAuCX,YAAvC;AACAX,QAAAA,UAAU,CAACtP,IAAX,CAAgBqC,YAAhB,EAA8BwO,GAA9B,CAAkClC,QAAlC;AACAY,QAAAA,UAAU,CAACvP,IAAX,CAAgBqC,YAAhB,EAA8ByO,GAA9B,CAAkCnC,QAAlC;AACA0B,QAAAA,gBAAgB,GAAG,IAAnB;AACA1B,QAAAA,QAAQ,CAACuC,UAAT,CAAoBlB,SAApB,EAA+BD,aAA/B;;AAEA,YAAIiB,OAAO,CAAC5L,GAAR,CAAYuJ,QAAZ,IAAwB,CAA5B,EAA+B;AAC7B0B,UAAAA,gBAAgB,GAAG,KAAnB;AACD;;AAED,YAAIU,MAAM,KAAK,CAAf,EAAkBR,uBAAuB,GAAGF,gBAA1B;AAClB1B,QAAAA,QAAQ,CAACuC,UAAT,CAAoBlB,SAApB,EAA+B3N,YAA/B;AACAsM,QAAAA,QAAQ,CAACwC,SAAT;AACA,YAAI/L,GAAG,GAAGhC,IAAI,CAACE,GAAL,CAAS0N,OAAO,CAAC5L,GAAR,CAAYuJ,QAAZ,CAAT,CAAV,CAhB2B,CAgBgB;;AAE3C,YAAIvJ,GAAG,KAAK,CAAZ,EAAe;AACb;AACA,cAAIgM,SAAS,GAAGnB,YAAY,GAAG7K,GAA/B;AACAuJ,UAAAA,QAAQ,CAACiC,cAAT,CAAwB,CAACQ,SAAzB;AACAxC,UAAAA,QAAQ,CAACsC,UAAT,CAAoB7O,YAApB,EAAkC0N,aAAlC;AACAlB,UAAAA,QAAQ,CAAC7O,IAAT,CAAc4O,QAAd,EAAwByC,SAAxB,CAAkCD,SAAlC,EAA6CN,GAA7C,CAAiDnC,QAAjD;AACAa,UAAAA,UAAU,CAACxP,IAAX,CAAgB6O,QAAhB,EAA0ByC,MAA1B;AACA,cAAIC,YAAY,GAAG1C,QAAQ,CAAChP,MAAT,EAAnB;AACA,cAAI2R,iBAAiB,GAAG5C,QAAQ,CAAC/O,MAAT,EAAxB;AACA+O,UAAAA,QAAQ,CAAC6C,YAAT,CAAsBD,iBAAtB;AACA1C,UAAAA,QAAQ,CAACoC,UAAT,CAAoBlB,SAApB,EAA+B3N,YAA/B;AACA,cAAIqP,iBAAiB,GAAG5C,QAAQ,CAACjP,MAAT,EAAxB;AACAiP,UAAAA,QAAQ,CAAC2C,YAAT,CAAsBC,iBAAtB,EAZa,CAY6B;;AAE1C,cAAI9C,QAAQ,CAACxJ,GAAT,CAAaoK,UAAb,IAA2BgC,iBAA3B,IAAgD1C,QAAQ,CAAC1J,GAAT,CAAaoK,UAAb,IAA2BkC,iBAA/E,EAAkG;AAChGtB,YAAAA,iBAAiB,GAAG,IAApB;AACD;;AAEDX,UAAAA,UAAU,CAACzP,IAAX,CAAgB6O,QAAhB,EAA0BiC,GAA1B,CAA8BzO,YAA9B;AACAmN,UAAAA,UAAU,CAACsB,GAAX,CAAezO,YAAf;AACAiO,UAAAA,OAAO,GAAG,KAAV;;AAEA,cAAIF,iBAAJ,EAAuB;AACrB,gBAAIC,gBAAJ,EAAsB;AACpBd,cAAAA,UAAU,CAACvP,IAAX,CAAgBwP,UAAhB;AACAH,cAAAA,aAAa,CAACrP,IAAd,CAAmBwP,UAAnB;AACD,aAHD,MAGO;AACLF,cAAAA,UAAU,CAACtP,IAAX,CAAgBwP,UAAhB;AACAJ,cAAAA,aAAa,CAACpP,IAAd,CAAmBwP,UAAnB;AACD;AACF,WARD,MAQO;AACL;AACAmC,YAAAA,oBAAoB;AACrB;;AAED,kBAAQlU,KAAK,CAAC6P,cAAd;AACE,iBAAK,OAAL;AACEsE,cAAAA,wBAAwB,CAACvB,gBAAD,EAAmBD,iBAAnB,EAAsCa,EAAtC,CAAxB;AACA;;AAEF,iBAAK,OAAL;AACE;AACAY,cAAAA,uCAAuC,CAACxB,gBAAD,EAAmBD,iBAAnB,CAAvC,CAFF,CAEgF;;AAE9E,kBAAIC,gBAAJ,EAAsB;AACpByB,gBAAAA,kBAAkB,CAACzP,YAAD,EAAe+M,aAAf,EAA8BE,UAA9B,EAA0C2B,EAA1C,EAA8C,CAA9C,CAAlB;AACD,eAFD,MAEO;AACLa,gBAAAA,kBAAkB,CAACzP,YAAD,EAAekN,UAAf,EAA2BF,aAA3B,EAA0C4B,EAA1C,EAA8C,CAA9C,CAAlB;AACD;;AAED;;AAEF,iBAAK,OAAL;AACA,iBAAK,YAAL;AACA;AACE,kBAAIc,aAAa,GAAG9B,YAAY,GAAGxS,KAAK,CAAC+P,gBAArB,GAAwC+D,YAA5D;;AAEA,kBAAIQ,aAAa,GAAG,CAApB,EAAuB;AACrB;AACA,oBAAItU,KAAK,CAAC6P,cAAN,KAAyB,YAA7B,EAA2C;AACzCsE,kBAAAA,wBAAwB,CAACvB,gBAAD,EAAmBD,iBAAnB,EAAsCa,EAAtC,CAAxB;AACA;AACD,iBAHD,MAGO;AACL;AACAY,kBAAAA,uCAAuC,CAACxB,gBAAD,EAAmBD,iBAAnB,CAAvC,CAFK,CAEyE;;AAE9E,sBAAIC,gBAAJ,EAAsB;AACpBvB,oBAAAA,QAAQ,CAACoC,UAAT,CAAoBzB,UAApB,EAAgCL,aAAhC,EAA+CwB,cAA/C,CAA8DmB,aAA9D,EAA6EjB,GAA7E,CAAiF1B,aAAjF;AACAL,oBAAAA,QAAQ,CAACmC,UAAT,CAAoBzB,UAApB,EAAgCH,UAAhC,EAA4CsB,cAA5C,CAA2DmB,aAA3D,EAA0EjB,GAA1E,CAA8ExB,UAA9E;AACA0C,oBAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,oBAAAA,SAAS,CAAClD,QAAD,EAAWmC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAClD,QAAD,EAAWmC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAACjD,QAAD,EAAWkC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAACjD,QAAD,EAAWkC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAAC1C,UAAD,EAAa2B,EAAb,EAAiB,CAAjB,CAAT;AACD,mBAZD,MAYO;AACLnC,oBAAAA,QAAQ,CAACoC,UAAT,CAAoBzB,UAApB,EAAgCJ,aAAhC,EAA+CuB,cAA/C,CAA8DmB,aAA9D,EAA6EjB,GAA7E,CAAiFzB,aAAjF;AACAN,oBAAAA,QAAQ,CAACmC,UAAT,CAAoBzB,UAApB,EAAgCF,UAAhC,EAA4CqB,cAA5C,CAA2DmB,aAA3D,EAA0EjB,GAA1E,CAA8EvB,UAA9E;AACAyC,oBAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACAe,oBAAAA,SAAS,CAAClD,QAAD,EAAWmC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAClD,QAAD,EAAWmC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAACjD,QAAD,EAAWkC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAACjD,QAAD,EAAWkC,EAAX,EAAe,CAAf,CAAT;AACAe,oBAAAA,SAAS,CAACzC,UAAD,EAAa0B,EAAb,EAAiB,CAAjB,CAAT;AACD;AACF;AACF,eAnCD,MAmCO;AACL;AACA,oBAAIb,iBAAJ,EAAuB;AACrB;AACA,sBAAIC,gBAAJ,EAAsB;AACpB2B,oBAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACD,mBAPD,MAOO;AACLe,oBAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,oBAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACD;;AAED,sBAAIZ,gBAAJ,EAAsB;AACpBf,oBAAAA,UAAU,CAACtP,IAAX,CAAgByP,UAAhB;AACD,mBAFD,MAEO;AACLF,oBAAAA,UAAU,CAACvP,IAAX,CAAgByP,UAAhB;AACD;AACF,iBAvBD,MAuBO;AACL;AACA,sBAAIY,gBAAJ,EAAsB;AACpB2B,oBAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAAC1C,UAAD,EAAa2B,EAAb,EAAiB,CAAjB,CAAT;AACD,mBAPD,MAOO;AACLe,oBAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACAe,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,oBAAAA,SAAS,CAACvC,UAAD,EAAawB,EAAb,EAAiB,CAAjB,CAAT;AACAe,oBAAAA,SAAS,CAACzC,UAAD,EAAa0B,EAAb,EAAiB,CAAjB,CAAT;AACD;AACF;;AAEDX,gBAAAA,OAAO,GAAG,IAAV;AACD;;AAED;AAxGJ;AA0GD,SA7ID,MA6IO;AACL;AACAqB,UAAAA,oBAAoB;AACrB;AACF,OAnKD,MAmKO;AACL;AACAA,QAAAA,oBAAoB;AACrB;;AAED,UAAI,CAAC9B,QAAD,IAAakB,MAAM,KAAKnB,SAAS,GAAG,CAAxC,EAA2C;AACzC;AACAqC,QAAAA,cAAc,CAACjE,MAAM,CAAC,CAAD,CAAP,EAAYkB,OAAZ,EAAqBC,OAArB,EAA8BkB,gBAA9B,EAAgD,IAAhD,EAAsDF,EAAtD,CAAd;AACD,OAhMgD,CAgM/C;;;AAGFA,MAAAA,EAAE,GAAGc,EAAL;AACAlB,MAAAA,aAAa,GAAG1N,YAAhB;AACA2M,MAAAA,UAAU,CAAChP,IAAX,CAAgBsP,UAAhB;AACAL,MAAAA,UAAU,CAACjP,IAAX,CAAgBuP,UAAhB;AACD;;AAED,QAAI,CAACM,QAAL,EAAe;AACb;AACAoC,MAAAA,cAAc,CAAC5P,YAAD,EAAe+M,aAAf,EAA8BC,aAA9B,EAA6CgB,gBAA7C,EAA+D,KAA/D,EAAsEY,EAAtE,CAAd;AACD,KAHD,MAGO,IAAIb,iBAAiB,IAAIjC,QAAzB,EAAmC;AACxC;AACA,UAAI+D,SAAS,GAAGzC,UAAhB;AACA,UAAI0C,SAAS,GAAG3C,UAAhB;;AAEA,UAAIe,uBAAuB,KAAKF,gBAAhC,EAAkD;AAChD6B,QAAAA,SAAS,GAAG1C,UAAZ;AACA2C,QAAAA,SAAS,GAAG1C,UAAZ;AACD;;AAED,UAAIY,gBAAJ,EAAsB;AACpB,YAAIC,OAAO,IAAIC,uBAAf,EAAwC;AACtC4B,UAAAA,SAAS,CAACC,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;AACAgE,UAAAA,SAAS,CAACC,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;;AAEA,cAAImC,OAAJ,EAAa;AACX4B,YAAAA,SAAS,CAACE,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;AACD;AACF;AACF,OATD,MASO;AACL,YAAImC,OAAO,IAAI,CAACC,uBAAhB,EAAyC;AACvC4B,UAAAA,SAAS,CAACC,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;AACAgE,UAAAA,SAAS,CAACC,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;;AAEA,cAAImC,OAAJ,EAAa;AACX4B,YAAAA,SAAS,CAACE,OAAV,CAAkBjE,QAAlB,EAA4B,IAAI,CAAhC;AACD;AACF;AACF;AACF;;AAED,WAAOqC,WAAP,CA9Q+F,CA8Q3E;AACpB;;AAEA,aAASG,SAAT,CAAmB0B,EAAnB,EAAuBC,EAAvB,EAA2BnK,MAA3B,EAAmC;AACjCA,MAAAA,MAAM,CAAC+I,UAAP,CAAkBoB,EAAlB,EAAsBD,EAAtB;AACA,aAAOlK,MAAM,CAACiD,GAAP,CAAW,CAACjD,MAAM,CAAC5G,CAAnB,EAAsB4G,MAAM,CAAC7G,CAA7B,EAAgC6P,SAAhC,EAAP;AACD;;AAED,aAASa,SAAT,CAAmBO,QAAnB,EAA6B7I,CAA7B,EAAgC1C,CAAhC,EAAmC;AACjC,UAAImH,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACsC,iBAAD,CAAR,GAA8B8B,QAAQ,CAACjR,CAAvC;AACA6M,QAAAA,QAAQ,CAACsC,iBAAiB,GAAG,CAArB,CAAR,GAAkC8B,QAAQ,CAAChR,CAA3C;AACA4M,QAAAA,QAAQ,CAACsC,iBAAiB,GAAG,CAArB,CAAR,GAAkC,CAAlC;;AAEA,YAAIrC,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACqC,iBAAD,CAAP,GAA6B,CAA7B;AACArC,UAAAA,OAAO,CAACqC,iBAAiB,GAAG,CAArB,CAAP,GAAiC,CAAjC;AACArC,UAAAA,OAAO,CAACqC,iBAAiB,GAAG,CAArB,CAAP,GAAiC,CAAjC;AACD;;AAEDA,QAAAA,iBAAiB,IAAI,CAArB;;AAEA,YAAIpC,GAAJ,EAAS;AACPA,UAAAA,GAAG,CAACqC,mBAAD,CAAH,GAA2BhH,CAA3B;AACA2E,UAAAA,GAAG,CAACqC,mBAAmB,GAAG,CAAvB,CAAH,GAA+B1J,CAA/B;AACA0J,UAAAA,mBAAmB,IAAI,CAAvB;AACD;AACF;;AAEDF,MAAAA,WAAW,IAAI,CAAf;AACD;;AAED,aAASsB,kBAAT,CAA4BU,MAA5B,EAAoCH,EAApC,EAAwCC,EAAxC,EAA4C5I,CAA5C,EAA+C1C,CAA/C,EAAkD;AAChD;AACA;AACAyH,MAAAA,QAAQ,CAACzO,IAAT,CAAcqS,EAAd,EAAkBxB,GAAlB,CAAsB2B,MAAtB,EAA8BrB,SAA9B;AACAzC,MAAAA,QAAQ,CAAC1O,IAAT,CAAcsS,EAAd,EAAkBzB,GAAlB,CAAsB2B,MAAtB,EAA8BrB,SAA9B;AACA,UAAIvG,KAAK,GAAGxH,IAAI,CAACC,EAAjB;AACA,UAAI+B,GAAG,GAAGqJ,QAAQ,CAACrJ,GAAT,CAAasJ,QAAb,CAAV;AACA,UAAItL,IAAI,CAACE,GAAL,CAAS8B,GAAT,IAAgB,CAApB,EAAuBwF,KAAK,GAAGxH,IAAI,CAACE,GAAL,CAASF,IAAI,CAACmC,IAAL,CAAUH,GAAV,CAAT,CAAR;AACvBwF,MAAAA,KAAK,IAAIqD,YAAT;AACAU,MAAAA,QAAQ,CAAC3O,IAAT,CAAcqS,EAAd;;AAEA,WAAK,IAAIzS,CAAC,GAAG,CAAR,EAAW6S,EAAE,GAAGxE,YAAY,GAAG,CAApC,EAAuCrO,CAAC,GAAG6S,EAA3C,EAA+C7S,CAAC,EAAhD,EAAoD;AAClDgP,QAAAA,QAAQ,CAAC5O,IAAT,CAAc2O,QAAd,EAAwB+D,YAAxB,CAAqCF,MAArC,EAA6C5H,KAA7C;AACAoH,QAAAA,SAAS,CAACrD,QAAD,EAAWjF,CAAX,EAAc1C,CAAd,CAAT;AACAgL,QAAAA,SAAS,CAACpD,QAAD,EAAWlF,CAAX,EAAc1C,CAAd,CAAT;AACAgL,QAAAA,SAAS,CAACQ,MAAD,EAAS9I,CAAT,EAAY,GAAZ,CAAT;AACAiF,QAAAA,QAAQ,CAAC3O,IAAT,CAAc4O,QAAd;AACD;;AAEDoD,MAAAA,SAAS,CAACpD,QAAD,EAAWlF,CAAX,EAAc1C,CAAd,CAAT;AACAgL,MAAAA,SAAS,CAACM,EAAD,EAAK5I,CAAL,EAAQ1C,CAAR,CAAT;AACAgL,MAAAA,SAAS,CAACQ,MAAD,EAAS9I,CAAT,EAAY,GAAZ,CAAT;AACD;;AAED,aAASiI,oBAAT,GAAgC;AAC9BK,MAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,MAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,MAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,MAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,MAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,MAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACD;;AAED,aAASW,wBAAT,CAAkCvB,gBAAlC,EAAoDD,iBAApD,EAAuE1G,CAAvE,EAA0E;AACxE,UAAI0G,iBAAJ,EAAuB;AACrB;AACA,YAAIC,gBAAJ,EAAsB;AACpB;AACA2B,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT,CAPoB,CAOU;;AAE9Be,UAAAA,SAAS,CAAC5C,aAAD,EAAgB1F,CAAhB,EAAmB,CAAnB,CAAT;AACAsI,UAAAA,SAAS,CAAC1C,UAAD,EAAa5F,CAAb,EAAgB,CAAhB,CAAT;AACAsI,UAAAA,SAAS,CAACxC,UAAD,EAAa9F,CAAb,EAAgB,GAAhB,CAAT;AACD,SAZD,MAYO;AACL;AACAsI,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT,CAPK,CAO4B;;AAEjCe,UAAAA,SAAS,CAAC3C,aAAD,EAAgB3F,CAAhB,EAAmB,CAAnB,CAAT;AACAsI,UAAAA,SAAS,CAACzC,UAAD,EAAa7F,CAAb,EAAgB,CAAhB,CAAT;AACAsI,UAAAA,SAAS,CAACxC,UAAD,EAAa9F,CAAb,EAAgB,GAAhB,CAAT;AACD;AACF,OA3BD,MA2BO;AACL;AACA,YAAI2G,gBAAJ,EAAsB;AACpB2B,UAAAA,SAAS,CAAC5C,aAAD,EAAgB1F,CAAhB,EAAmB,CAAnB,CAAT;AACAsI,UAAAA,SAAS,CAAC1C,UAAD,EAAa5F,CAAb,EAAgB,CAAhB,CAAT;AACAsI,UAAAA,SAAS,CAAC3P,YAAD,EAAeqH,CAAf,EAAkB,GAAlB,CAAT;AACD,SAJD,MAIO;AACLsI,UAAAA,SAAS,CAAC3C,aAAD,EAAgB3F,CAAhB,EAAmB,CAAnB,CAAT;AACAsI,UAAAA,SAAS,CAACzC,UAAD,EAAa7F,CAAb,EAAgB,CAAhB,CAAT;AACAsI,UAAAA,SAAS,CAAC3P,YAAD,EAAeqH,CAAf,EAAkB,GAAlB,CAAT;AACD;AACF;AACF;;AAED,aAASmI,uCAAT,CAAiDxB,gBAAjD,EAAmED,iBAAnE,EAAsF;AACpF,UAAIA,iBAAJ,EAAuB;AACrB,YAAIC,gBAAJ,EAAsB;AACpB2B,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC5C,aAAD,EAAgB6B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAAC5C,aAAD,EAAgBe,EAAhB,EAAoB,CAApB,CAAT;AACA6B,UAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,UAAAA,SAAS,CAAC1C,UAAD,EAAaa,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACD,SAbD,MAaO;AACLe,UAAAA,SAAS,CAAC/C,UAAD,EAAakB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAAChD,UAAD,EAAamB,EAAb,EAAiB,CAAjB,CAAT;AACA6B,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAAC3C,aAAD,EAAgB4B,EAAhB,EAAoB,CAApB,CAAT;AACAe,UAAAA,SAAS,CAAC3C,aAAD,EAAgBc,EAAhB,EAAoB,CAApB,CAAT;AACA6B,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,UAAAA,SAAS,CAAC3P,YAAD,EAAe4O,EAAf,EAAmB,GAAnB,CAAT;AACAe,UAAAA,SAAS,CAACxC,UAAD,EAAayB,EAAb,EAAiB,CAAjB,CAAT;AACAe,UAAAA,SAAS,CAACzC,UAAD,EAAaY,EAAb,EAAiB,CAAjB,CAAT;AACD;AACF;AACF;;AAED,aAAS8B,cAAT,CAAwBO,MAAxB,EAAgCH,EAAhC,EAAoCC,EAApC,EAAwCjC,gBAAxC,EAA0DtO,KAA1D,EAAiE2H,CAAjE,EAAoE;AAClE;AACA;AACA,cAAQjM,KAAK,CAAC8P,aAAd;AACE,aAAK,OAAL;AACE,cAAIxL,KAAJ,EAAW;AACT+P,YAAAA,kBAAkB,CAACU,MAAD,EAASF,EAAT,EAAaD,EAAb,EAAiB3I,CAAjB,EAAoB,GAApB,CAAlB;AACD,WAFD,MAEO;AACLoI,YAAAA,kBAAkB,CAACU,MAAD,EAASH,EAAT,EAAaC,EAAb,EAAiB5I,CAAjB,EAAoB,GAApB,CAAlB;AACD;;AAED;;AAEF,aAAK,QAAL;AACE,cAAI3H,KAAJ,EAAW;AACT0M,YAAAA,QAAQ,CAACyC,UAAT,CAAoBmB,EAApB,EAAwBG,MAAxB;AACA9D,YAAAA,QAAQ,CAACtD,GAAT,CAAaqD,QAAQ,CAAClN,CAAtB,EAAyB,CAACkN,QAAQ,CAACnN,CAAnC;AACAqN,YAAAA,QAAQ,CAACgE,UAAT,CAAoBlE,QAApB,EAA8BC,QAA9B,EAAwCoC,GAAxC,CAA4C0B,MAA5C;AACA5D,YAAAA,QAAQ,CAACsC,UAAT,CAAoBxC,QAApB,EAA8BD,QAA9B,EAAwCqC,GAAxC,CAA4C0B,MAA5C,EAJS,CAI4C;;AAErD,gBAAInC,gBAAJ,EAAsB;AACpB1B,cAAAA,QAAQ,CAACyD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACAS,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACAS,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACD,aAJD,MAIO;AACLQ,cAAAA,QAAQ,CAACyD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACAQ,cAAAA,QAAQ,CAACyD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACAS,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2B,IAAI,CAA/B;AACD;AACF,WAfD,MAeO;AACLM,YAAAA,QAAQ,CAACyC,UAAT,CAAoBoB,EAApB,EAAwBE,MAAxB;AACA9D,YAAAA,QAAQ,CAACtD,GAAT,CAAaqD,QAAQ,CAAClN,CAAtB,EAAyB,CAACkN,QAAQ,CAACnN,CAAnC;AACAqN,YAAAA,QAAQ,CAACgE,UAAT,CAAoBlE,QAApB,EAA8BC,QAA9B,EAAwCoC,GAAxC,CAA4C0B,MAA5C;AACA5D,YAAAA,QAAQ,CAACsC,UAAT,CAAoBxC,QAApB,EAA8BD,QAA9B,EAAwCqC,GAAxC,CAA4C0B,MAA5C;AACA,gBAAII,EAAE,GAAGzE,QAAQ,CAACtO,MAAlB,CALK,CAKqB;;AAE1B,gBAAIwQ,gBAAJ,EAAsB;AACpB1B,cAAAA,QAAQ,CAACyD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACAhE,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACAhE,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACD,aAJD,MAIO;AACLjE,cAAAA,QAAQ,CAACyD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACAhE,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACAhE,cAAAA,QAAQ,CAACwD,OAAT,CAAiBjE,QAAjB,EAA2ByE,EAAE,GAAG,IAAI,CAApC;AACD;AACF;;AAED;AA5CJ;AA8CD;;AAED,aAASjD,sBAAT,CAAgC3B,MAAhC,EAAwC;AACtC;AACA;AACA,UAAI6E,SAAS,GAAG,KAAhB;;AAEA,WAAK,IAAIjT,CAAC,GAAG,CAAR,EAAW6J,CAAC,GAAGuE,MAAM,CAACnO,MAAP,GAAgB,CAApC,EAAuCD,CAAC,GAAG6J,CAA3C,EAA8C7J,CAAC,EAA/C,EAAmD;AACjD,YAAIoO,MAAM,CAACpO,CAAD,CAAN,CAAUkT,UAAV,CAAqB9E,MAAM,CAACpO,CAAC,GAAG,CAAL,CAA3B,IAAsCsO,WAA1C,EAAuD;AACrD2E,UAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AAED,UAAI,CAACA,SAAL,EAAgB,OAAO7E,MAAP;AAChB,UAAI+E,SAAS,GAAG,EAAhB;AACAA,MAAAA,SAAS,CAACvT,IAAV,CAAewO,MAAM,CAAC,CAAD,CAArB;;AAEA,WAAK,IAAIpO,EAAC,GAAG,CAAR,EAAW6J,EAAC,GAAGuE,MAAM,CAACnO,MAAP,GAAgB,CAApC,EAAuCD,EAAC,GAAG6J,EAA3C,EAA8C7J,EAAC,EAA/C,EAAmD;AACjD,YAAIoO,MAAM,CAACpO,EAAD,CAAN,CAAUkT,UAAV,CAAqB9E,MAAM,CAACpO,EAAC,GAAG,CAAL,CAA3B,KAAuCsO,WAA3C,EAAwD;AACtD6E,UAAAA,SAAS,CAACvT,IAAV,CAAewO,MAAM,CAACpO,EAAD,CAArB;AACD;AACF;;AAEDmT,MAAAA,SAAS,CAACvT,IAAV,CAAewO,MAAM,CAACA,MAAM,CAACnO,MAAP,GAAgB,CAAjB,CAArB;AACA,aAAOkT,SAAP;AACD;AACF,GAreD;AAseD,CAxfqC,EAAtC;;AA0fA,SAASrX,SAAT","sourcesContent":["import { Loader, FileLoader, Matrix3, Vector2, Vector3, BufferGeometry, Float32BufferAttribute, ShapePath, Path } from 'three';\n\nvar SVGLoader = function (manager) {\n  Loader.call(this, manager); // Default dots per inch\n\n  this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n  this.defaultUnit = 'px';\n};\n\nSVGLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: SVGLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (text) {\n    var scope = this;\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      var transform = getNodeTransform(node);\n      var traverseChildNodes = true;\n      var path = null;\n\n      switch (node.nodeName) {\n        case 'svg':\n          break;\n\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case 'defs':\n          traverseChildNodes = false;\n          break;\n\n        case 'use':\n          style = parseStyle(node, style);\n          var usedNodeId = node.href.baseVal.substring(1);\n          var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n\n          break;\n\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n\n      if (traverseChildNodes) {\n        var nodes = node.childNodes;\n\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      var path = new ShapePath();\n      var point = new Vector2();\n      var control = new Vector2();\n      var firstPoint = new Vector2();\n      var isFirstPoint = true;\n      var doSetFirstPoint = false;\n      var d = node.getAttribute('d'); // console.log( d );\n\n      var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        var command = commands[i];\n        var type = command.charAt(0);\n        var data = command.substr(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        switch (type) {\n          case 'M':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'H':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'V':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'L':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'C':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'S':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Q':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'T':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'A':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              var start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'm':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'h':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'v':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'l':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'c':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 's':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'q':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 't':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'a':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              var start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        var stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      var dx2 = (start.x - end.x) / 2.0;\n      var dy2 = (start.y - end.y) / 2.0;\n      var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      var rxs = rx * rx;\n      var rys = ry * ry;\n      var x1ps = x1p * x1p;\n      var y1ps = y1p * y1p; // Ensure radii are large enough\n\n      var cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        var s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      var dq = rxs * y1ps + rys * x1ps;\n      var pq = (rxs * rys - dq) / dq;\n      var q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      var cxp = q * rx * y1p / ry;\n      var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      var dot = ux * vx + uy * vy;\n      var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n\n\n    function parseRectNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      var w = parseFloatWithUnits(node.getAttribute('width'));\n      var h = parseFloatWithUnits(node.getAttribute('height'));\n      var path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n\n      path.lineTo(x, y + 2 * ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var r = parseFloatWithUnits(node.getAttribute('r'));\n      var subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var rx = parseFloatWithUnits(node.getAttribute('rx'));\n      var ry = parseFloatWithUnits(node.getAttribute('ry'));\n      var subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseLineNode(node) {\n      var x1 = parseFloatWithUnits(node.getAttribute('x1'));\n      var y1 = parseFloatWithUnits(node.getAttribute('y1'));\n      var x2 = parseFloatWithUnits(node.getAttribute('x2'));\n      var y2 = parseFloatWithUnits(node.getAttribute('y2'));\n      var path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      var stylesheetStyles = {};\n\n      if (node.hasAttribute('class')) {\n        var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n    function parseFloats(input) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n\n      var RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i\n      }; // States\n\n      var SEP = 0;\n      var INT = 1;\n      var FLOAT = 2;\n      var EXP = 3;\n      var state = SEP;\n      var seenComma = true;\n      var result = [],\n          number = '',\n          exponent = '';\n\n      function throwSyntaxError(current, i, partial) {\n        var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = '';\n        exponent = '';\n      }\n\n      var current,\n          i = 0,\n          length = input.length;\n\n      for (i = 0; i < length; i++) {\n        current = input[i]; // parse until next number\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        } // parse integer part\n\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n\n        if (state == EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n\n      newNumber();\n      return result;\n    } // Units\n\n\n    var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    var unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n\n    function parseFloatWithUnits(string) {\n      var theUnit = 'px';\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          var u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      var scale = undefined;\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    } // Transforms\n\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n\n      var transform = parseNodeTransform(node);\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n\n    function parseNodeTransform(node) {\n      var transform = new Matrix3();\n      var currentTransform = tempTransform0;\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        var tx = parseFloatWithUnits(node.getAttribute('x'));\n        var ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n\n      if (node.hasAttribute('transform')) {\n        var transformsTexts = node.getAttribute('transform').split(')');\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          var transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          var openParPos = transformText.indexOf('(');\n          var closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            var transformType = transformText.substr(0, openParPos);\n            var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  var tx = array[0];\n                  var ty = tx;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                }\n\n                break;\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  var angle = 0;\n                  var cx = 0;\n                  var cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n\n                break;\n\n              case 'scale':\n                if (array.length >= 1) {\n                  var scaleX = array[0];\n                  var scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n\n      var isRotated = isTransformRotated(m);\n      var subPaths = path.subPaths;\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        var subPath = subPaths[i];\n        var curves = subPath.curves;\n\n        for (let j = 0; j < curves.length; j++) {\n          var curve = curves[j];\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n\n    function getTransformScaleX(m) {\n      var te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n\n    function getTransformScaleY(m) {\n      var te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n\n    var paths = [];\n    var stylesheets = {};\n    var transformStack = [];\n    var tempTransform0 = new Matrix3();\n    var tempTransform1 = new Matrix3();\n    var tempTransform2 = new Matrix3();\n    var tempTransform3 = new Matrix3();\n    var tempV2 = new Vector2();\n    var tempV3 = new Vector3();\n    var currentTransform = new Matrix3();\n    var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    var data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n});\n\nSVGLoader.getStrokeStyle = function (width, color, lineJoin, lineCap, miterLimit) {\n  // Param width: Stroke width\n  // Param color: As returned by THREE.Color.getStyle()\n  // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n  // Param lineCap: One of \"round\", \"square\" or \"butt\"\n  // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n  // Returns style object\n  width = width !== undefined ? width : 1;\n  color = color !== undefined ? color : '#000';\n  lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n  lineCap = lineCap !== undefined ? lineCap : 'butt';\n  miterLimit = miterLimit !== undefined ? miterLimit : 4;\n  return {\n    strokeColor: color,\n    strokeWidth: width,\n    strokeLineJoin: lineJoin,\n    strokeLineCap: lineCap,\n    strokeMiterLimit: miterLimit\n  };\n};\n\nSVGLoader.pointsToStroke = function (points, style, arcDivisions, minDistance) {\n  // Generates a stroke with some witdh around the given path.\n  // The path can be open or closed (last point equals to first point)\n  // Param points: Array of Vector2D (the path). Minimum 2 points.\n  // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n  // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n  // Param minDistance: Points closer to this distance will be merged. (Optional)\n  // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n\n  if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n    return null;\n  }\n\n  var geometry = new BufferGeometry();\n  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  return geometry;\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n  var tempV2_1 = new Vector2();\n  var tempV2_2 = new Vector2();\n  var tempV2_3 = new Vector2();\n  var tempV2_4 = new Vector2();\n  var tempV2_5 = new Vector2();\n  var tempV2_6 = new Vector2();\n  var tempV2_7 = new Vector2();\n  var lastPointL = new Vector2();\n  var lastPointR = new Vector2();\n  var point0L = new Vector2();\n  var point0R = new Vector2();\n  var currentPointL = new Vector2();\n  var currentPointR = new Vector2();\n  var nextPointL = new Vector2();\n  var nextPointR = new Vector2();\n  var innerPoint = new Vector2();\n  var outerPoint = new Vector2();\n  return function (points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    var numPoints = points.length;\n    if (numPoints < 2) return 0;\n    var isClosed = points[0].equals(points[numPoints - 1]);\n    var currentPoint;\n    var previousPoint = points[0];\n    var nextPoint;\n    var strokeWidth2 = style.strokeWidth / 2;\n    var deltaU = 1 / (numPoints - 1);\n    var u0 = 0;\n    var innerSideModified;\n    var joinIsOnLeftSide;\n    var isMiter;\n    var initialJoinIsOnLeftSide = false;\n    var numVertices = 0;\n    var currentCoordinate = vertexOffset * 3;\n    var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n\n      var normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      var u1 = u0 + deltaU;\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          var miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          var miterLength2 = tempV2_5.length();\n          var segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          var segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n\n              break;\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      var lastOuter = outerPoint;\n      var lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      var angle = Math.PI;\n      var dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            var vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      var dupPoints = false;\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n      var newPoints = [];\n      newPoints.push(points[0]);\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  };\n}();\n\nexport { SVGLoader };\n"]},"metadata":{},"sourceType":"module"}