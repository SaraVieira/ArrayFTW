{"ast":null,"code":"import _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Vector3, Matrix3, LineSegments, BufferGeometry, LineBasicMaterial, Float32BufferAttribute } from 'three';\n\nvar _v1 = new Vector3();\n\nvar _v2 = new Vector3();\n\nvar _normalMatrix = new Matrix3();\n\nvar VertexNormalsHelper = /*#__PURE__*/function (_LineSegments) {\n  _inherits(VertexNormalsHelper, _LineSegments);\n\n  var _super = _createSuper(VertexNormalsHelper);\n\n  function VertexNormalsHelper(object, size, hex) {\n    var _this;\n\n    _classCallCheck(this, VertexNormalsHelper);\n\n    var geometry = new BufferGeometry();\n    var color = hex !== undefined ? hex : 0xff0000;\n    _this = _super.call(this, geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this.object = object;\n    _this.size = size !== undefined ? size : 0.1;\n    var nNormals = 0;\n    var objGeometry = _this.object.geometry;\n\n    if (objGeometry && objGeometry.isGeometry) {\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n      return _possibleConstructorReturn(_this);\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\n      nNormals = objGeometry.attributes.normal.count;\n    } //\n\n\n    var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n    geometry.setAttribute('position', positions);\n    _this.type = 'VertexNormalsHelper'; //\n\n    _this.matrixAutoUpdate = false;\n\n    _this.update();\n\n    return _this;\n  }\n\n  _createClass(VertexNormalsHelper, [{\n    key: \"update\",\n    value: function update() {\n      this.object.updateMatrixWorld(true);\n\n      _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n      var matrixWorld = this.object.matrixWorld;\n      var position = this.geometry.attributes.position; //\n\n      var objGeometry = this.object.geometry;\n\n      if (objGeometry && objGeometry.isGeometry) {\n        console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n        return;\n      } else if (objGeometry && objGeometry.isBufferGeometry) {\n        var objPos = objGeometry.attributes.position;\n        var objNorm = objGeometry.attributes.normal;\n        var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\n\n        for (var j = 0, jl = objPos.count; j < jl; j++) {\n          _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n\n          _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n\n          _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n          position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n          idx = idx + 1;\n          position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n          idx = idx + 1;\n        }\n      }\n\n      position.needsUpdate = true;\n    }\n  }]);\n\n  return VertexNormalsHelper;\n}(LineSegments);\n\nexport { VertexNormalsHelper };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/helpers/VertexNormalsHelper.js"],"names":["Vector3","Matrix3","LineSegments","BufferGeometry","LineBasicMaterial","Float32BufferAttribute","_v1","_v2","_normalMatrix","VertexNormalsHelper","object","size","hex","geometry","color","undefined","toneMapped","nNormals","objGeometry","isGeometry","console","error","isBufferGeometry","attributes","normal","count","positions","setAttribute","type","matrixAutoUpdate","update","updateMatrixWorld","getNormalMatrix","matrixWorld","position","objPos","objNorm","idx","j","jl","set","getX","getY","getZ","applyMatrix4","applyMatrix3","normalize","multiplyScalar","add","setXYZ","x","y","z","needsUpdate"],"mappings":"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","sourcesContent":["import { Vector3, Matrix3, LineSegments, BufferGeometry, LineBasicMaterial, Float32BufferAttribute } from 'three';\n\nconst _v1 = new Vector3();\n\nconst _v2 = new Vector3();\n\nconst _normalMatrix = new Matrix3();\n\nclass VertexNormalsHelper extends LineSegments {\n  constructor(object, size, hex) {\n    const geometry = new BufferGeometry();\n    const color = hex !== undefined ? hex : 0xff0000;\n    super(geometry, new LineBasicMaterial({\n      color,\n      toneMapped: false\n    }));\n    this.object = object;\n    this.size = size !== undefined ? size : 0.1;\n    let nNormals = 0;\n    const objGeometry = this.object.geometry;\n\n    if (objGeometry && objGeometry.isGeometry) {\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n      return;\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\n      nNormals = objGeometry.attributes.normal.count;\n    } //\n\n\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n    geometry.setAttribute('position', positions);\n    this.type = 'VertexNormalsHelper'; //\n\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true);\n\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n    const matrixWorld = this.object.matrixWorld;\n    const position = this.geometry.attributes.position; //\n\n    const objGeometry = this.object.geometry;\n\n    if (objGeometry && objGeometry.isGeometry) {\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n      return;\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\n      const objPos = objGeometry.attributes.position;\n      const objNorm = objGeometry.attributes.normal;\n      let idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\n\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\n        _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n\n        _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n        idx = idx + 1;\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n        idx = idx + 1;\n      }\n    }\n\n    position.needsUpdate = true;\n  }\n\n}\n\nexport { VertexNormalsHelper };\n"]},"metadata":{},"sourceType":"module"}