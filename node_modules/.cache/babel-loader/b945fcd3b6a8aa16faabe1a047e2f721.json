{"ast":null,"code":"import { BackSide } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { Vector2Node } from '../inputs/Vector2Node.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { UVNode } from '../accessors/UVNode.js';\nimport { NormalNode } from '../accessors/NormalNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\n\nfunction NormalMapNode(value, scale) {\n  TempNode.call(this, 'v3');\n  this.value = value;\n  this.scale = scale || new Vector2Node(1, 1);\n}\n\nNormalMapNode.Nodes = function () {\n  var perturbNormal2Arb = new FunctionNode( // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n  \"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\\n\\n\\t\\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\n\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n\\n\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\n\\t\\tvec3 mapN = map * 2.0 - 1.0;\\n\\n\\t\\tmapN.xy *= normalScale;\\n\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n\\n\\t\\t\\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\\n\\n\\t\\t#else\\n\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\n\\t\\t#endif\\n\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\n\\t}\", null, {\n    derivatives: true\n  });\n  return {\n    perturbNormal2Arb: perturbNormal2Arb\n  };\n}();\n\nNormalMapNode.prototype = Object.create(TempNode.prototype);\nNormalMapNode.prototype.constructor = NormalMapNode;\nNormalMapNode.prototype.nodeType = 'NormalMap';\n\nNormalMapNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var perturbNormal2Arb = builder.include(NormalMapNode.Nodes.perturbNormal2Arb);\n    this.normal = this.normal || new NormalNode();\n    this.position = this.position || new PositionNode(PositionNode.VIEW);\n    this.uv = this.uv || new UVNode();\n    var scale = this.scale.build(builder, 'v2');\n\n    if (builder.material.side === BackSide) {\n      scale = '-' + scale;\n    }\n\n    return builder.format(perturbNormal2Arb + '( -' + this.position.build(builder, 'v3') + ', ' + this.normal.build(builder, 'v3') + ', ' + this.value.build(builder, 'v3') + ', ' + this.uv.build(builder, 'v2') + ', ' + scale + ' )', this.getType(builder), output);\n  } else {\n    console.warn('THREE.NormalMapNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.getType(builder), output);\n  }\n};\n\nNormalMapNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.value = source.value;\n  this.scale = source.scale;\n  return this;\n};\n\nNormalMapNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.scale = this.scale.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { NormalMapNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/misc/NormalMapNode.js"],"names":["BackSide","TempNode","Vector2Node","FunctionNode","UVNode","NormalNode","PositionNode","NormalMapNode","value","scale","call","Nodes","perturbNormal2Arb","derivatives","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","include","normal","position","VIEW","uv","build","material","side","format","getType","console","warn","shader","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { BackSide } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { Vector2Node } from '../inputs/Vector2Node.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { UVNode } from '../accessors/UVNode.js';\nimport { NormalNode } from '../accessors/NormalNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\n\nfunction NormalMapNode(value, scale) {\n  TempNode.call(this, 'v3');\n  this.value = value;\n  this.scale = scale || new Vector2Node(1, 1);\n}\n\nNormalMapNode.Nodes = function () {\n  var perturbNormal2Arb = new FunctionNode( // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n  `vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = map * 2.0 - 1.0;\n\n\t\tmapN.xy *= normalScale;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n\t\t\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\n\n\t\t#else\n\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}`, null, {\n    derivatives: true\n  });\n  return {\n    perturbNormal2Arb: perturbNormal2Arb\n  };\n}();\n\nNormalMapNode.prototype = Object.create(TempNode.prototype);\nNormalMapNode.prototype.constructor = NormalMapNode;\nNormalMapNode.prototype.nodeType = 'NormalMap';\n\nNormalMapNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var perturbNormal2Arb = builder.include(NormalMapNode.Nodes.perturbNormal2Arb);\n    this.normal = this.normal || new NormalNode();\n    this.position = this.position || new PositionNode(PositionNode.VIEW);\n    this.uv = this.uv || new UVNode();\n    var scale = this.scale.build(builder, 'v2');\n\n    if (builder.material.side === BackSide) {\n      scale = '-' + scale;\n    }\n\n    return builder.format(perturbNormal2Arb + '( -' + this.position.build(builder, 'v3') + ', ' + this.normal.build(builder, 'v3') + ', ' + this.value.build(builder, 'v3') + ', ' + this.uv.build(builder, 'v2') + ', ' + scale + ' )', this.getType(builder), output);\n  } else {\n    console.warn('THREE.NormalMapNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.getType(builder), output);\n  }\n};\n\nNormalMapNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.value = source.value;\n  this.scale = source.scale;\n  return this;\n};\n\nNormalMapNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.scale = this.scale.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { NormalMapNode };\n"]},"metadata":{},"sourceType":"module"}