{"ast":null,"code":"import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function MorphBlendMesh(geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function createAnimation(name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function autoCreateAnimations(fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (var key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (var _name in frameRanges) {\n      var range = frameRanges[_name];\n      this.createAnimation(_name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function setAnimationDirectionForward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function setAnimationDirectionBackward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function setAnimationFPS(name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function setAnimationDuration(name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function setAnimationWeight(name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function setAnimationTime(name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function getAnimationTime(name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function getAnimationDuration(name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function playAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function stopAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function update(delta) {\n    for (var i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\nexport { MorphBlendMesh };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"names":["Mesh","MathUtils","MorphBlendMesh","geometry","material","call","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"mappings":"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","sourcesContent":["import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function (name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function (fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (let key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (let name in frameRanges) {\n      var range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function (name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function (name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function (name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function (name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function (name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function (name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function (delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\n\nexport { MorphBlendMesh };\n"]},"metadata":{},"sourceType":"module"}