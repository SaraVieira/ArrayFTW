{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nvar SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\n  '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\n  '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\n  // fetch the 3x3 neighbourhood of a fragment\n  // first column\n  '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\n  '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\n  '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\n  '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\n  '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\n  '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\n')\n};\nexport { SobelOperatorShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/SobelOperatorShader.js"],"names":["Vector2","SobelOperatorShader","uniforms","tDiffuse","value","resolution","vertexShader","join","fragmentShader"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,mBAAmB,GAAG;AACxBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAE;AADC,KADF;AAIRC,IAAAA,UAAU,EAAE;AACVD,MAAAA,KAAK,EAAE,IAAIJ,OAAJ;AADG;AAJJ,GADc;AASxBM,EAAAA,YAAY,EAAE,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,YAAvC,EAAqD,4EAArD,EAAmI,GAAnI,EAAwIC,IAAxI,CAA6I,IAA7I,CATU;AAUxBC,EAAAA,cAAc,EAAE,CAAC,6BAAD,EAAgC,0BAAhC,EAA4D,mBAA5D,EAAiF,eAAjF,EAAkG,+DAAlG,EAAmK;AACnL,0DADgB,EAC0C;AAC1D,0DAFgB,EAE0C;AAC1D;AACA;AACA,yEALgB,EAKyD,uEALzD,EAKkI,uEALlI,EAK2M;AAC3N,yEANgB,EAMyD,uEANzD,EAMkI,uEANlI,EAM2M;AAC3N,yEAPgB,EAOyD,uEAPzD,EAOkI,uEAPlI,EAO2M;AAC3N,8EARgB,EAQ8D,6DAR9D,EAQ6H,4DAR7H,EAQ2L;AAC3M,8EATgB,EAS8D,6DAT9D,EAS6H,4DAT7H,EAS2L;AAC3M,qEAVgB,EAUqD,uCAVrD,EAU8F,GAV9F,EAUmGD,IAVnG,CAUwG,IAVxG;AAVQ,CAA1B;AAuBA,SAASN,mBAAT","sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nvar SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\n  '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\n  '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\n  // fetch the 3x3 neighbourhood of a fragment\n  // first column\n  '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\n  '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\n  '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\n  '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\n  '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\n  '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\n')\n};\n\nexport { SobelOperatorShader };\n"]},"metadata":{},"sourceType":"module"}