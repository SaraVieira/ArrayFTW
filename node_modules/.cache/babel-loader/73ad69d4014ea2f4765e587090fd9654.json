{"ast":null,"code":"/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\nvar HalftoneShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    shape: {\n      value: 1\n    },\n    radius: {\n      value: 4\n    },\n    rotateR: {\n      value: Math.PI / 12 * 1\n    },\n    rotateG: {\n      value: Math.PI / 12 * 2\n    },\n    rotateB: {\n      value: Math.PI / 12 * 3\n    },\n    scatter: {\n      value: 0\n    },\n    width: {\n      value: 1\n    },\n    height: {\n      value: 1\n    },\n    blending: {\n      value: 1\n    },\n    blendingMode: {\n      value: 1\n    },\n    greyscale: {\n      value: false\n    },\n    disable: {\n      value: false\n    }\n  },\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\n'),\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\n  '\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\n  '\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\n  '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\tfloat rad = channel;', '\tif ( shape == SHAPE_DOT ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t} else if ( shape == SHAPE_ELLIPSE ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t\tif ( dist != 0.0 ) {', '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\t\t}', '\t} else if ( shape == SHAPE_LINE ) {', '\t\trad = pow( abs( rad ), 1.5) * rad_max;', '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\t} else if ( shape == SHAPE_SQUARE ) {', '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\t\tfloat sin_t = abs( sin( theta ) );', '\t\tfloat cos_t = abs( cos( theta ) );', '\t\trad = pow( abs( rad ), 1.4 );', '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\t}', '\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\n  '\tvec2 normal;', '\tvec2 p1;', '\tvec2 p2;', '\tvec2 p3;', '\tvec2 p4;', '\tfloat samp2;', '\tfloat samp1;', '\tfloat samp3;', '\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\n  '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\tfloat step = PI2 / float( samples );', '\tfloat dist = radius * 0.66;', '\tfor ( int i = 0; i < samples; ++i ) {', '\t\tfloat r = base + step * float( i );', '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\t}', '\ttex /= float( samples ) + 1.0;', '\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\n  '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\tif ( channel == 0 ) {', '\t\tc.samp1 = getSample( c.p1 ).r;', '\t\tc.samp2 = getSample( c.p2 ).r;', '\t\tc.samp3 = getSample( c.p3 ).r;', '\t\tc.samp4 = getSample( c.p4 ).r;', '\t} else if (channel == 1) {', '\t\tc.samp1 = getSample( c.p1 ).g;', '\t\tc.samp2 = getSample( c.p2 ).g;', '\t\tc.samp3 = getSample( c.p3 ).g;', '\t\tc.samp4 = getSample( c.p4 ).g;', '\t} else {', '\t\tc.samp1 = getSample( c.p1 ).b;', '\t\tc.samp3 = getSample( c.p3 ).b;', '\t\tc.samp2 = getSample( c.p2 ).b;', '\t\tc.samp4 = getSample( c.p4 ).b;', '\t}', '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\tres = clamp( res, 0.0, 1.0 );', '\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\n  '\tCell c;', // calc grid\n  '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\tfloat threshold = step * 0.5;', '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\n  '\tc.normal = n;', '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\n  '\tif ( scatter != 0.0 ) {', '\t\tfloat off_mag = scatter * threshold * 0.5;', '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\t\tc.p1.x += cos( off_angle ) * off_mag;', '\t\tc.p1.y += sin( off_angle ) * off_mag;', '\t}', // find corners\n  '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\tc.p2.x = c.p1.x - n.x * normal_step;', '\tc.p2.y = c.p1.y - n.y * normal_step;', '\tc.p3.x = c.p1.x + n.y * line_step;', '\tc.p3.y = c.p1.y - n.x * line_step;', '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\n  '\tif ( blendingMode == BLENDING_LINEAR ) {', '\t\treturn blend( a, b, 1.0 - t );', '\t} else if ( blendingMode == BLENDING_ADD ) {', '\t\treturn blend( a, min( 1.0, a + b ), t );', '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\t\treturn blend( a, max( 0.0, a * b ), t );', '\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\t\treturn blend( a, max( a, b ), t );', '\t} else if ( blendingMode == BLENDING_DARKER ) {', '\t\treturn blend( a, min( a, b ), t );', '\t} else {', '\t\treturn blend( a, b, 1.0 - t );', '\t}', '}', 'void main() {', '\tif ( ! disable ) {', // setup\n  '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\t\tvec2 origin = vec2( 0, 0 );', '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\n  '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\n  '\t\tvec4 colour = texture2D( tDiffuse, vUV );', '\t\tr = blendColour( r, colour.r, blending );', '\t\tg = blendColour( g, colour.g, blending );', '\t\tb = blendColour( b, colour.b, blending );', '\t\tif ( greyscale ) {', '\t\t\tr = g = b = (r + b + g) / 3.0;', '\t\t}', '\t\tgl_FragColor = vec4( r, g, b, 1.0 );', '\t} else {', '\t\tgl_FragColor = texture2D( tDiffuse, vUV );', '\t}', '}'].join('\\n')\n};\nexport { HalftoneShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/HalftoneShader.js"],"names":["HalftoneShader","uniforms","tDiffuse","value","shape","radius","rotateR","Math","PI","rotateG","rotateB","scatter","width","height","blending","blendingMode","greyscale","disable","vertexShader","join","fragmentShader"],"mappings":"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","sourcesContent":["/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\nvar HalftoneShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    shape: {\n      value: 1\n    },\n    radius: {\n      value: 4\n    },\n    rotateR: {\n      value: Math.PI / 12 * 1\n    },\n    rotateG: {\n      value: Math.PI / 12 * 2\n    },\n    rotateB: {\n      value: Math.PI / 12 * 3\n    },\n    scatter: {\n      value: 0\n    },\n    width: {\n      value: 1\n    },\n    height: {\n      value: 1\n    },\n    blending: {\n      value: 1\n    },\n    blendingMode: {\n      value: 1\n    },\n    greyscale: {\n      value: false\n    },\n    disable: {\n      value: false\n    }\n  },\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\n'),\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\n  '\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\n  '\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\n  '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\tfloat rad = channel;', '\tif ( shape == SHAPE_DOT ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t} else if ( shape == SHAPE_ELLIPSE ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t\tif ( dist != 0.0 ) {', '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\t\t}', '\t} else if ( shape == SHAPE_LINE ) {', '\t\trad = pow( abs( rad ), 1.5) * rad_max;', '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\t} else if ( shape == SHAPE_SQUARE ) {', '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\t\tfloat sin_t = abs( sin( theta ) );', '\t\tfloat cos_t = abs( cos( theta ) );', '\t\trad = pow( abs( rad ), 1.4 );', '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\t}', '\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\n  '\tvec2 normal;', '\tvec2 p1;', '\tvec2 p2;', '\tvec2 p3;', '\tvec2 p4;', '\tfloat samp2;', '\tfloat samp1;', '\tfloat samp3;', '\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\n  '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\tfloat step = PI2 / float( samples );', '\tfloat dist = radius * 0.66;', '\tfor ( int i = 0; i < samples; ++i ) {', '\t\tfloat r = base + step * float( i );', '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\t}', '\ttex /= float( samples ) + 1.0;', '\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\n  '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\tif ( channel == 0 ) {', '\t\tc.samp1 = getSample( c.p1 ).r;', '\t\tc.samp2 = getSample( c.p2 ).r;', '\t\tc.samp3 = getSample( c.p3 ).r;', '\t\tc.samp4 = getSample( c.p4 ).r;', '\t} else if (channel == 1) {', '\t\tc.samp1 = getSample( c.p1 ).g;', '\t\tc.samp2 = getSample( c.p2 ).g;', '\t\tc.samp3 = getSample( c.p3 ).g;', '\t\tc.samp4 = getSample( c.p4 ).g;', '\t} else {', '\t\tc.samp1 = getSample( c.p1 ).b;', '\t\tc.samp3 = getSample( c.p3 ).b;', '\t\tc.samp2 = getSample( c.p2 ).b;', '\t\tc.samp4 = getSample( c.p4 ).b;', '\t}', '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\tres = clamp( res, 0.0, 1.0 );', '\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\n  '\tCell c;', // calc grid\n  '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\tfloat threshold = step * 0.5;', '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\n  '\tc.normal = n;', '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\n  '\tif ( scatter != 0.0 ) {', '\t\tfloat off_mag = scatter * threshold * 0.5;', '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\t\tc.p1.x += cos( off_angle ) * off_mag;', '\t\tc.p1.y += sin( off_angle ) * off_mag;', '\t}', // find corners\n  '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\tc.p2.x = c.p1.x - n.x * normal_step;', '\tc.p2.y = c.p1.y - n.y * normal_step;', '\tc.p3.x = c.p1.x + n.y * line_step;', '\tc.p3.y = c.p1.y - n.x * line_step;', '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\n  '\tif ( blendingMode == BLENDING_LINEAR ) {', '\t\treturn blend( a, b, 1.0 - t );', '\t} else if ( blendingMode == BLENDING_ADD ) {', '\t\treturn blend( a, min( 1.0, a + b ), t );', '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\t\treturn blend( a, max( 0.0, a * b ), t );', '\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\t\treturn blend( a, max( a, b ), t );', '\t} else if ( blendingMode == BLENDING_DARKER ) {', '\t\treturn blend( a, min( a, b ), t );', '\t} else {', '\t\treturn blend( a, b, 1.0 - t );', '\t}', '}', 'void main() {', '\tif ( ! disable ) {', // setup\n  '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\t\tvec2 origin = vec2( 0, 0 );', '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\n  '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\n  '\t\tvec4 colour = texture2D( tDiffuse, vUV );', '\t\tr = blendColour( r, colour.r, blending );', '\t\tg = blendColour( g, colour.g, blending );', '\t\tb = blendColour( b, colour.b, blending );', '\t\tif ( greyscale ) {', '\t\t\tr = g = b = (r + b + g) / 3.0;', '\t\t}', '\t\tgl_FragColor = vec4( r, g, b, 1.0 );', '\t} else {', '\t\tgl_FragColor = texture2D( tDiffuse, vUV );', '\t}', '}'].join('\\n')\n};\n\nexport { HalftoneShader };\n"]},"metadata":{},"sourceType":"module"}