{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from 'three';\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new Vector3();\n\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function setFromPoints(points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n\n      this.makeEmpty();\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n      return this;\n    },\n    setFromObject: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function containsPoint(point) {\n      var faces = this.faces;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    },\n    intersectRay: function intersectRay(ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    },\n    intersectsRay: function intersectsRay(ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function computeExtremes() {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new Line3();\n          plane = new Plane();\n          closestPoint = new Vector3();\n        }\n\n        var vertex,\n            vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n            maxDistance = 0;\n        var index = 0;\n\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n\n        var faces = [];\n\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function reindexFaces() {\n      var activeFaces = [];\n\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function nextVertexToAdd() {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function compute() {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  Object.assign(Face, {\n    create: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function getEdge(i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  Object.assign(HalfEdge.prototype, {\n    head: function head() {\n      return this.vertex;\n    },\n    tail: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function length() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    },\n    lengthSquared: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    },\n    setTwin: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  Object.assign(VertexList.prototype, {\n    first: function first() {\n      return this.head;\n    },\n    last: function last() {\n      return this.tail;\n    },\n    clear: function clear() {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    },\n    isEmpty: function isEmpty() {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\n\nexport { ConvexHull };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/math/ConvexHull.js"],"names":["Vector3","Line3","Plane","Triangle","ConvexHull","Visible","Deleted","v1","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","point","geometry","undefined","isGeometry","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","j","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","line3","plane","closestPoint","extremes","v0","v2","v3","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"mappings":"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","sourcesContent":["import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new Vector3();\n\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function (points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n      return this;\n    },\n    setFromObject: function (object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function (point) {\n      var faces = this.faces;\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    },\n    intersectRay: function (ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    },\n    intersectsRay: function (ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function () {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function (vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function (vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function (face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function (face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function (newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (let i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function () {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new Line3();\n          plane = new Plane();\n          closestPoint = new Vector3();\n        }\n\n        var vertex,\n            vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n            maxDistance = 0;\n        var index = 0;\n\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n\n        var faces = [];\n\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function () {\n      var activeFaces = [];\n\n      for (let i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function () {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function (eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function (eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function (eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (let i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function (eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function () {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function () {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  Object.assign(Face, {\n    create: function (a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function (i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function (point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  Object.assign(HalfEdge.prototype, {\n    head: function () {\n      return this.vertex;\n    },\n    tail: function () {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function () {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    },\n    lengthSquared: function () {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    },\n    setTwin: function (edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  Object.assign(VertexList.prototype, {\n    first: function () {\n      return this.head;\n    },\n    last: function () {\n      return this.tail;\n    },\n    clear: function () {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function (target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function (target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function (vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function (a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    },\n    isEmpty: function () {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\n\nexport { ConvexHull };\n"]},"metadata":{},"sourceType":"module"}