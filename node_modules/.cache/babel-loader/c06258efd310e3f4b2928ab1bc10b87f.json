{"ast":null,"code":"import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (var i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (var _i = 0; _i < this.nMips; _i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n    this.separableBlurMaterials[_i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function dispose() {\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n      this.renderTargetsVertical[_i2].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function setSize(width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}'\n    });\n  },\n  getCompositeMaterial: function getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js"],"names":["Vector2","Color","WebGLRenderTarget","UniformsUtils","ShaderMaterial","Vector3","AdditiveBlending","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomRadius"],"mappings":"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","sourcesContent":["import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (let i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (let i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function () {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}'\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\n\nexport { UnrealBloomPass };\n"]},"metadata":{},"sourceType":"module"}