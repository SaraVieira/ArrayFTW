{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * TODO\n */\n\nvar DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nvar BlurShaderUtils = {\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n    var gaussian = function gaussian(x, stdDev) {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    var weights = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n    var offsets = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"names":["Vector2","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate"],"mappings":"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","sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * TODO\n */\n\nvar DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nvar BlurShaderUtils = {\n  createSampleWeights: function (kernelRadius, stdDev) {\n    var gaussian = function (x, stdDev) {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    var weights = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: function (kernelRadius, uvIncrement) {\n    var offsets = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: function (material, kernelRadius, stdDev, uvIncrement) {\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n};\n\nexport { BlurShaderUtils, DepthLimitedBlurShader };\n"]},"metadata":{},"sourceType":"module"}