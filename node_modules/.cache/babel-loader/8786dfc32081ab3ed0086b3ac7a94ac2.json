{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\nexport { AdaptiveToneMappingPass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"names":["UniformsUtils","ShaderMaterial","NoBlending","WebGLRenderTarget","LinearMipmapLinearFilter","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","console","error","copyShader","copyUniforms","clone","uniforms","materialCopy","vertexShader","fragmentShader","blending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","magFilter","format","name","generateMipmaps","luminanceMap","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"mappings":"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","sourcesContent":["import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function () {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function (adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function (rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function (minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function (maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function (avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function (middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function () {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\n\nexport { AdaptiveToneMappingPass };\n"]},"metadata":{},"sourceType":"module"}