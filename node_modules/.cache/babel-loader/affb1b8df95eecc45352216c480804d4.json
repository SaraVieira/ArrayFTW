{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = \"reflect( -normalize( \".concat(viewPosition, \" ), \").concat(viewNormal, \" )\");\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = \"normalize( mix( \".concat(method, \", \").concat(viewNormal, \", \").concat(roughness, \" * \").concat(roughness, \" ) )\");\n        }\n\n        var code = \"inverseTransformDirection( \".concat(method, \", viewMatrix )\");\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectVec = \".concat(code, \";\"));\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectCubeVec = \".concat(code, \";\"));\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec2 reflectSphereVec = \".concat(code, \";\"));\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/accessors/ReflectNode.js"],"names":["TempNode","PositionNode","NormalNode","ReflectNode","scope","call","CUBE","SPHERE","VECTOR","prototype","Object","create","constructor","nodeType","getUnique","builder","context","viewNormal","getType","type","generate","output","isUnique","isShader","result","viewNormalNode","VIEW","roughnessNode","roughness","build","viewPosition","undefined","method","code","addNodeCode","reflectVec","format","console","warn","shader","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":"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","sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = `reflect( -normalize( ${viewPosition} ), ${viewNormal} )`;\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = `normalize( mix( ${method}, ${viewNormal}, ${roughness} * ${roughness} ) )`;\n        }\n\n        var code = `inverseTransformDirection( ${method}, viewMatrix )`;\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectVec = ${code};`);\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectCubeVec = ${code};`);\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec2 reflectSphereVec = ${code};`);\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };\n"]},"metadata":{},"sourceType":"module"}