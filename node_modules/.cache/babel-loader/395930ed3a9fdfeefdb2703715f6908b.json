{"ast":null,"code":"import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function TAARenderPass(scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (var i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\nexport { TAARenderPass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/TAARenderPass.js"],"names":["WebGLRenderTarget","SSAARenderPass","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","console","error","call","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","j","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight"],"mappings":"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","sourcesContent":["import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (let i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\n\nexport { TAARenderPass };\n"]},"metadata":{},"sourceType":"module"}