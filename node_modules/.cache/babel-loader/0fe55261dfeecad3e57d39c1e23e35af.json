{"ast":null,"code":"import { Scene, Camera, Mesh, PlaneGeometry, ShaderMaterial, WebGLRenderTarget, RGBAFormat, DataTexture, FloatType, NearestFilter, ClampToEdgeWrapping } from 'three';\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\n\nvar GPUComputationRenderer = function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n      return 'No OES_texture_float support for float textures.';\n    }\n\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return 'No support for vertex shader textures.';\n    }\n\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i]; // Creates rendertargets and initialize them with input texture\n\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]); // Adds dependencies uniforms to the ShaderMaterial\n\n      var material = variable.material;\n      var uniforms = material.uniforms;\n\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n\n          if (depVar.name !== variable.name) {\n            // Checks if variable exists\n            var found = false;\n\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n            }\n          }\n\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n        }\n      }\n    }\n\n    this.currentTextureIndex = 0;\n    return null;\n  };\n\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i]; // Sets texture dependencies uniforms\n\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      } // Performs the computation for this variable\n\n\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n\n    this.currentTextureIndex = nextTextureIndex;\n  };\n\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )';\n  }\n\n  this.addResolutionDefine = addResolutionDefine; // The following functions can be used to compute things manually\n\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n\n  this.createShaderMaterial = createShaderMaterial;\n\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    return new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n  };\n\n  this.renderTexture = function (input, output) {\n    // Takes a texture, and render out in rendertarget\n    // input = Texture\n    // output = RenderTarget\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.setRenderTarget(currentRenderTarget);\n  }; // Shaders\n\n\n  function getPassThroughVertexShader() {\n    return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n';\n  }\n\n  function getPassThroughFragmentShader() {\n    return 'uniform sampler2D passThruTexture;\\n' + '\\n' + 'void main() {\\n' + '\\n' + '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' + '\\n' + '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' + '\\n' + '}\\n';\n  }\n};\n\nexport { GPUComputationRenderer };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/misc/GPUComputationRenderer.js"],"names":["Scene","Camera","Mesh","PlaneGeometry","ShaderMaterial","WebGLRenderTarget","RGBAFormat","DataTexture","FloatType","NearestFilter","ClampToEdgeWrapping","GPUComputationRenderer","sizeX","sizeY","renderer","variables","currentTextureIndex","dataType","scene","camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","add","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","renderTarget","format","depthBuffer","createTexture","data","Float32Array","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render"],"mappings":"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","sourcesContent":["import { Scene, Camera, Mesh, PlaneGeometry, ShaderMaterial, WebGLRenderTarget, RGBAFormat, DataTexture, FloatType, NearestFilter, ClampToEdgeWrapping } from 'three';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\n\nvar GPUComputationRenderer = function (sizeX, sizeY, renderer) {\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n      return 'No OES_texture_float support for float textures.';\n    }\n\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return 'No support for vertex shader textures.';\n    }\n\n    for (let i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i]; // Creates rendertargets and initialize them with input texture\n\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]); // Adds dependencies uniforms to the ShaderMaterial\n\n      var material = variable.material;\n      var uniforms = material.uniforms;\n\n      if (variable.dependencies !== null) {\n        for (let d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n\n          if (depVar.name !== variable.name) {\n            // Checks if variable exists\n            var found = false;\n\n            for (let j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n            }\n          }\n\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n        }\n      }\n    }\n\n    this.currentTextureIndex = 0;\n    return null;\n  };\n\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n    for (let i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i]; // Sets texture dependencies uniforms\n\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n\n        for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      } // Performs the computation for this variable\n\n\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n\n    this.currentTextureIndex = nextTextureIndex;\n  };\n\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )';\n  }\n\n  this.addResolutionDefine = addResolutionDefine; // The following functions can be used to compute things manually\n\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n\n  this.createShaderMaterial = createShaderMaterial;\n\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    return new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n  };\n\n  this.renderTexture = function (input, output) {\n    // Takes a texture, and render out in rendertarget\n    // input = Texture\n    // output = RenderTarget\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.setRenderTarget(currentRenderTarget);\n  }; // Shaders\n\n\n  function getPassThroughVertexShader() {\n    return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n';\n  }\n\n  function getPassThroughFragmentShader() {\n    return 'uniform sampler2D passThruTexture;\\n' + '\\n' + 'void main() {\\n' + '\\n' + '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' + '\\n' + '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' + '\\n' + '}\\n';\n  }\n};\n\nexport { GPUComputationRenderer };\n"]},"metadata":{},"sourceType":"module"}