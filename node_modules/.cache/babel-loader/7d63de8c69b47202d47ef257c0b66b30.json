{"ast":null,"code":"import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar Reflector = function Reflector(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader; //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Reflector };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/Reflector.js"],"names":["Mesh","Color","Plane","Vector3","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","LinearFilter","RGBFormat","Reflector","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor","tDiffuse","join"],"mappings":"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","sourcesContent":["import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar Reflector = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader; //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexport { Reflector };\n"]},"metadata":{},"sourceType":"module"}