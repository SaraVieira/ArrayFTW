{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { StructNode } from '../core/StructNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { FunctionCallNode } from '../core/FunctionCallNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { MathNode } from '../math/MathNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\n\nfunction TextureCubeUVNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\n\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new StructNode(\"struct TextureCubeUVData {\\n\\t\\t\\tvec4 tl;\\n\\t\\t\\tvec4 tr;\\n\\t\\t\\tvec4 br;\\n\\t\\t\\tvec4 bl;\\n\\t\\t\\tvec2 f;\\n\\t\\t}\");\n  var cubeUV_maxMipLevel = new ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new FunctionNode(\"float getFace(vec3 direction) {\\n\\t\\t\\t\\tvec3 absDirection = abs(direction);\\n\\t\\t\\t\\tfloat face = -1.0;\\n\\t\\t\\t\\tif (absDirection.x > absDirection.z) {\\n\\t\\t\\t\\t\\tif (absDirection.x > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (absDirection.z > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn face;\\n\\t\\t}\");\n  getFace.useKeywords = false;\n  var getUV = new FunctionNode(\"vec2 getUV(vec3 direction, float face) {\\n\\t\\t\\t\\tvec2 uv;\\n\\t\\t\\t\\tif (face == 0.0) {\\n\\t\\t\\t\\t\\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\\n\\t\\t\\t\\t} else if (face == 1.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\\n\\t\\t\\t\\t} else if (face == 2.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\\n\\t\\t\\t\\t} else if (face == 3.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\\n\\t\\t\\t\\t} else if (face == 4.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 0.5 * (uv + 1.0);\\n\\t\\t}\");\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new FunctionNode(\"TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\n\\n\\t\\t\\tfloat face = getFace(direction);\\n\\t\\t\\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\\n\\t\\t\\tmipInt = max(mipInt, cubeUV_minMipLevel);\\n\\t\\t\\tfloat faceSize = exp2(mipInt);\\n\\n\\t\\t\\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\\n\\n\\t\\t\\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\\n\\t\\t\\tvec2 f = fract(uv);\\n\\t\\t\\tuv += 0.5 - f;\\n\\t\\t\\tif (face > 2.0) {\\n\\t\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\t\\tface -= 3.0;\\n\\t\\t\\t}\\n\\t\\t\\tuv.x += face * faceSize;\\n\\t\\t\\tif(mipInt < cubeUV_maxMipLevel){\\n\\t\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t\\t}\\n\\t\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\t\\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\n\\t\\t\\tuv *= texelSize;\\n\\n\\t\\t\\tvec4 tl = texture2D(envMap, uv);\\n\\t\\t\\tuv.x += texelSize;\\n\\t\\t\\tvec4 tr = texture2D(envMap, uv);\\n\\t\\t\\tuv.y += texelSize;\\n\\t\\t\\tvec4 br = texture2D(envMap, uv);\\n\\t\\t\\tuv.x -= texelSize;\\n\\t\\t\\tvec4 bl = texture2D(envMap, uv);\\n\\n\\t\\t\\treturn TextureCubeUVData( tl, tr, br, bl, f );\\n\\t\\t}\", [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new ConstNode('float r0 1.0', true);\n  var v0 = new ConstNode('float v0 0.339', true);\n  var m0 = new ConstNode('float m0 -2.0', true);\n  var r1 = new ConstNode('float r1 0.8', true);\n  var v1 = new ConstNode('float v1 0.276', true);\n  var m1 = new ConstNode('float m1 -1.0', true);\n  var r4 = new ConstNode('float r4 0.4', true);\n  var v4 = new ConstNode('float v4 0.046', true);\n  var m4 = new ConstNode('float m4 2.0', true);\n  var r5 = new ConstNode('float r5 0.305', true);\n  var v5 = new ConstNode('float v5 0.016', true);\n  var m5 = new ConstNode('float m5 3.0', true);\n  var r6 = new ConstNode('float r6 0.21', true);\n  var v6 = new ConstNode('float v6 0.0038', true);\n  var m6 = new ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new FunctionNode(\"float roughnessToMip(float roughness) {\\n\\t\\t\\tfloat mip = 0.0;\\n\\t\\t\\tif (roughness >= r1) {\\n\\t\\t\\t\\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\n\\t\\t\\t} else if (roughness >= r4) {\\n\\t\\t\\t\\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\n\\t\\t\\t} else if (roughness >= r5) {\\n\\t\\t\\t\\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\n\\t\\t\\t} else if (roughness >= r6) {\\n\\t\\t\\t\\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\\n\\t\\t\\t}\\n\\t\\t\\treturn mip;\\n\\t\\t}\", defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\n\nTextureCubeUVNode.prototype = Object.create(TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\n\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\n\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n    var mipInt = new MathNode(mip, MathNode.FLOOR);\n    var mipF = new MathNode(mip, MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n    var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeUVNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/misc/TextureCubeUVNode.js"],"names":["TempNode","ConstNode","StructNode","FunctionNode","FunctionCallNode","ExpressionNode","FloatNode","OperatorNode","MathNode","ColorSpaceNode","TextureCubeUVNode","value","uv","bias","call","Nodes","TextureCubeUVData","cubeUV_maxMipLevel","cubeUV_minMipLevel","cubeUV_maxTileSize","cubeUV_minTileSize","getFace","useKeywords","getUV","bilinearCubeUV","r0","v0","m0","r1","v1","m1","r4","v4","m4","r5","v5","m5","r6","v6","m6","defines","roughnessToMip","prototype","Object","create","constructor","nodeType","builder","texture","mipInt","colorSpaceTL","fromDecoding","getTextureEncodingFromMap","input","parse","build","colorSpaceTR","colorSpaceBL","colorSpaceBR","context","include","isShader","ignoreCache","addContext","colorSpaceTLExp","colorSpaceTRExp","colorSpaceBLExp","colorSpaceBRExp","removeContext","output","keywords","generate","roughness","mipV","mip","CLAMP","FLOOR","mipF","FRACT","color0","color1","setReadonly","ADD","color1Mix","MIX","format","console","warn","shader","getType","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { StructNode } from '../core/StructNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { FunctionCallNode } from '../core/FunctionCallNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { MathNode } from '../math/MathNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\n\nfunction TextureCubeUVNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\n\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new StructNode(`struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}`);\n  var cubeUV_maxMipLevel = new ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new FunctionNode(`float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}`);\n  getFace.useKeywords = false;\n  var getUV = new FunctionNode(`vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}`);\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new FunctionNode(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}`, [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new ConstNode('float r0 1.0', true);\n  var v0 = new ConstNode('float v0 0.339', true);\n  var m0 = new ConstNode('float m0 -2.0', true);\n  var r1 = new ConstNode('float r1 0.8', true);\n  var v1 = new ConstNode('float v1 0.276', true);\n  var m1 = new ConstNode('float m1 -1.0', true);\n  var r4 = new ConstNode('float r4 0.4', true);\n  var v4 = new ConstNode('float v4 0.046', true);\n  var m4 = new ConstNode('float m4 2.0', true);\n  var r5 = new ConstNode('float r5 0.305', true);\n  var v5 = new ConstNode('float v5 0.016', true);\n  var m5 = new ConstNode('float m5 3.0', true);\n  var r6 = new ConstNode('float r6 0.21', true);\n  var v6 = new ConstNode('float v6 0.0038', true);\n  var m6 = new ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new FunctionNode(`float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}`, defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\n\nTextureCubeUVNode.prototype = Object.create(TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\n\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\n\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n    var mipInt = new MathNode(mip, MathNode.FLOOR);\n    var mipF = new MathNode(mip, MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n    var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeUVNode };\n"]},"metadata":{},"sourceType":"module"}