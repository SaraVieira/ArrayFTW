{"ast":null,"code":"import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\nvar LDrawLoader = function () {\n  var conditionalLineVertShader =\n  /* glsl */\n  \"\\n\\tattribute vec3 control0;\\n\\tattribute vec3 control1;\\n\\tattribute vec3 direction;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_vertex>\\n\\t#include <fog_pars_vertex>\\n\\t#include <logdepthbuf_pars_vertex>\\n\\t#include <clipping_planes_pars_vertex>\\n\\tvoid main() {\\n\\t\\t#include <color_vertex>\\n\\n\\t\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t// Transform the line segment ends and control points into camera clip space\\n\\t\\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\\n\\t\\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\\n\\t\\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\\n\\n\\t\\tc0.xy /= c0.w;\\n\\t\\tc1.xy /= c1.w;\\n\\t\\tp0.xy /= p0.w;\\n\\t\\tp1.xy /= p1.w;\\n\\n\\t\\t// Get the direction of the segment and an orthogonal vector\\n\\t\\tvec2 dir = p1.xy - p0.xy;\\n\\t\\tvec2 norm = vec2( -dir.y, dir.x );\\n\\n\\t\\t// Get control point directions from the line\\n\\t\\tvec2 c0dir = c0.xy - p1.xy;\\n\\t\\tvec2 c1dir = c1.xy - p1.xy;\\n\\n\\t\\t// If the vectors to the controls points are pointed in different directions away\\n\\t\\t// from the line segment then the line should not be drawn.\\n\\t\\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\\n\\t\\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\\n\\t\\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\\n\\n\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t#include <clipping_planes_vertex>\\n\\t\\t#include <fog_vertex>\\n\\t}\\n\\t\";\n  var conditionalLineFragShader =\n  /* glsl */\n  \"\\n\\tuniform vec3 diffuse;\\n\\tuniform float opacity;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_fragment>\\n\\t#include <fog_pars_fragment>\\n\\t#include <logdepthbuf_pars_fragment>\\n\\t#include <clipping_planes_pars_fragment>\\n\\tvoid main() {\\n\\n\\t\\tif ( discardFlag > 0.5 ) discard;\\n\\n\\t\\t#include <clipping_planes_fragment>\\n\\t\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t#include <color_fragment>\\n\\t\\toutgoingLight = diffuseColor.rgb; // simple shader\\n\\t\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t\\t#include <tonemapping_fragment>\\n\\t\\t#include <encodings_fragment>\\n\\t\\t#include <fog_fragment>\\n\\t\\t#include <premultiplied_alpha_fragment>\\n\\t}\\n\\t\";\n  var tempVec0 = new Vector3();\n  var tempVec1 = new Vector3();\n\n  function smoothNormals(triangles, lineSegments) {\n    function hashVertex(v) {\n      // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n      // to be smoothed as expected (see minifig arms). The errors between edges\n      // could be due to matrix multiplication.\n      var x = ~~(v.x * 1e2);\n      var y = ~~(v.y * 1e2);\n      var z = ~~(v.z * 1e2);\n      return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n    }\n\n    function hashEdge(v0, v1) {\n      return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n    }\n\n    var hardEdges = new Set();\n    var halfEdgeList = {};\n    var fullHalfEdgeList = {};\n    var normals = []; // Save the list of hard edges by hash\n\n    for (var _i = 0, l = lineSegments.length; _i < l; _i++) {\n      var ls = lineSegments[_i];\n      var v0 = ls.v0;\n      var v1 = ls.v1;\n      hardEdges.add(hashEdge(v0, v1));\n      hardEdges.add(hashEdge(v1, v0));\n    } // track the half edges associated with each triangle\n\n\n    for (var _i2 = 0, _l = triangles.length; _i2 < _l; _i2++) {\n      var tri = triangles[_i2];\n\n      for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\n        var index = i2;\n        var next = (i2 + 1) % 3;\n        var v0 = tri[\"v\".concat(index)];\n        var v1 = tri[\"v\".concat(next)];\n        var hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n        if (hardEdges.has(hash)) continue;\n        halfEdgeList[hash] = tri;\n        fullHalfEdgeList[hash] = tri;\n      }\n    } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n    // quads provide more \"influence\" to some vertex normals than a triangle due to\n    // the fact that a quad is made up of two triangles and all triangles are weighted\n    // equally. To fix this quads could be tracked separately so their vertex normals\n    // are weighted appropriately or we could try only adding a normal direction\n    // once per normal.\n    // Iterate until we've tried to connect all triangles to share normals\n\n\n    while (true) {\n      // Stop if there are no more triangles left\n      var halfEdges = Object.keys(halfEdgeList);\n      if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n      var i = 0;\n      var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n      while (i < queue.length) {\n        // initialize all vertex normals in this triangle\n        var tri = queue[i];\n        i++;\n        var faceNormal = tri.faceNormal;\n\n        if (tri.n0 === null) {\n          tri.n0 = faceNormal.clone();\n          normals.push(tri.n0);\n        }\n\n        if (tri.n1 === null) {\n          tri.n1 = faceNormal.clone();\n          normals.push(tri.n1);\n        }\n\n        if (tri.n2 === null) {\n          tri.n2 = faceNormal.clone();\n          normals.push(tri.n2);\n        } // Check if any edge is connected to another triangle edge\n\n\n        for (var _i3 = 0, _l2 = 3; _i3 < _l2; _i3++) {\n          var index = _i3;\n          var next = (_i3 + 1) % 3;\n          var v0 = tri[\"v\".concat(index)];\n          var v1 = tri[\"v\".concat(next)]; // delete this triangle from the list so it won't be found again\n\n          var hash = hashEdge(v0, v1);\n          delete halfEdgeList[hash];\n          var reverseHash = hashEdge(v1, v0);\n          var otherTri = fullHalfEdgeList[reverseHash];\n\n          if (otherTri) {\n            // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n            // hard edge. There are some cases where the line segments do not line up exactly\n            // with or span multiple triangle edges (see Lunar Vehicle wheels).\n            if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n              continue;\n            } // if this triangle has already been traversed then it won't be in\n            // the halfEdgeList. If it has not then add it to the queue and delete\n            // it so it won't be found again.\n\n\n            if (reverseHash in halfEdgeList) {\n              queue.push(otherTri);\n              delete halfEdgeList[reverseHash];\n            } // Find the matching edge in this triangle and copy the normal vector over\n\n\n            for (var i3 = 0, l3 = 3; i3 < l3; i3++) {\n              var otherIndex = i3;\n              var otherNext = (i3 + 1) % 3;\n              var otherV0 = otherTri[\"v\".concat(otherIndex)];\n              var otherV1 = otherTri[\"v\".concat(otherNext)];\n              var otherHash = hashEdge(otherV0, otherV1);\n\n              if (otherHash === reverseHash) {\n                if (otherTri[\"n\".concat(otherIndex)] === null) {\n                  var norm = tri[\"n\".concat(next)];\n                  otherTri[\"n\".concat(otherIndex)] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                if (otherTri[\"n\".concat(otherNext)] === null) {\n                  var norm = tri[\"n\".concat(index)];\n                  otherTri[\"n\".concat(otherNext)] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n    for (var _i4 = 0, _l3 = normals.length; _i4 < _l3; _i4++) {\n      normals[_i4].normalize();\n    }\n  }\n\n  function isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === 'Subpart';\n  }\n\n  function LineParser(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  LineParser.prototype = {\n    constructor: LineParser,\n    seekNonSpace: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    },\n    getToken: function getToken() {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    },\n    getRemainingString: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    },\n    isAtTheEnd: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    },\n    setToEnd: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    },\n    getLineNumberString: function getLineNumberString() {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  };\n\n  function sortByMaterial(a, b) {\n    if (a.colourCode === b.colourCode) {\n      return 0;\n    }\n\n    if (a.colourCode < b.colourCode) {\n      return -1;\n    }\n\n    return 1;\n  }\n\n  function createObject(elements, elementSize, isConditionalSegments) {\n    // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the triangles or line segments by colour code to make later the mesh groups\n    elements.sort(sortByMaterial);\n    var positions = [];\n    var normals = [];\n    var materials = [];\n    var bufferGeometry = new BufferGeometry();\n    var prevMaterial = null;\n    var index0 = 0;\n    var numGroupVerts = 0;\n\n    for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n      var elem = elements[iElem];\n      var v0 = elem.v0;\n      var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n      positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n      if (elementSize === 3) {\n        positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n        var n0 = elem.n0 || elem.faceNormal;\n        var n1 = elem.n1 || elem.faceNormal;\n        var n2 = elem.n2 || elem.faceNormal;\n        normals.push(n0.x, n0.y, n0.z);\n        normals.push(n1.x, n1.y, n1.z);\n        normals.push(n2.x, n2.y, n2.z);\n      }\n\n      if (prevMaterial !== elem.material) {\n        if (prevMaterial !== null) {\n          bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n        }\n\n        materials.push(elem.material);\n        prevMaterial = elem.material;\n        index0 = iElem * elementSize;\n        numGroupVerts = elementSize;\n      } else {\n        numGroupVerts += elementSize;\n      }\n    }\n\n    if (numGroupVerts > 0) {\n      bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    }\n\n    bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n    if (elementSize === 3) {\n      bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    }\n\n    var object3d = null;\n\n    if (elementSize === 2) {\n      object3d = new LineSegments(bufferGeometry, materials);\n    } else if (elementSize === 3) {\n      object3d = new Mesh(bufferGeometry, materials);\n    }\n\n    if (isConditionalSegments) {\n      object3d.isConditionalLine = true;\n      var controlArray0 = new Float32Array(elements.length * 3 * 2);\n      var controlArray1 = new Float32Array(elements.length * 3 * 2);\n      var directionArray = new Float32Array(elements.length * 3 * 2);\n\n      for (var i = 0, l = elements.length; i < l; i++) {\n        var os = elements[i];\n        var c0 = os.c0;\n        var c1 = os.c1;\n        var v0 = os.v0;\n        var v1 = os.v1;\n        var index = i * 3 * 2;\n        controlArray0[index + 0] = c0.x;\n        controlArray0[index + 1] = c0.y;\n        controlArray0[index + 2] = c0.z;\n        controlArray0[index + 3] = c0.x;\n        controlArray0[index + 4] = c0.y;\n        controlArray0[index + 5] = c0.z;\n        controlArray1[index + 0] = c1.x;\n        controlArray1[index + 1] = c1.y;\n        controlArray1[index + 2] = c1.z;\n        controlArray1[index + 3] = c1.x;\n        controlArray1[index + 4] = c1.y;\n        controlArray1[index + 5] = c1.z;\n        directionArray[index + 0] = v1.x - v0.x;\n        directionArray[index + 1] = v1.y - v0.y;\n        directionArray[index + 2] = v1.z - v0.z;\n        directionArray[index + 3] = v1.x - v0.x;\n        directionArray[index + 4] = v1.y - v0.y;\n        directionArray[index + 5] = v1.z - v0.z;\n      }\n\n      bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n      bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n      bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n    }\n\n    return object3d;\n  } //\n\n\n  function LDrawLoader(manager) {\n    Loader.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  } // Special surface finish tag types.\n  // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\n\n  LDrawLoader.FINISH_TYPE_DEFAULT = 0;\n  LDrawLoader.FINISH_TYPE_CHROME = 1;\n  LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;\n  LDrawLoader.FINISH_TYPE_RUBBER = 3;\n  LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;\n  LDrawLoader.FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n  // The LDraw standard establishes these various possible subfolders.\n\n  LDrawLoader.FILE_LOCATION_AS_IS = 0;\n  LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;\n  LDrawLoader.FILE_LOCATION_TRY_P = 2;\n  LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;\n  LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;\n  LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;\n  LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;\n  LDrawLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: LDrawLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    },\n    parse: function parse(text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    },\n    setMaterials: function setMaterials(materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    },\n    setFileMap: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    },\n    newParseScopeLevel: function newParseScopeLevel(materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (var i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new Matrix4(),\n        matrix: new Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    },\n    removeScopeLevel: function removeScopeLevel() {\n      this.parseScopesStack.pop();\n      return this;\n    },\n    addMaterial: function addMaterial(material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    },\n    getMaterial: function getMaterial(colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n\n      for (var i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    },\n    getParentParseScope: function getParentParseScope() {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    },\n    getCurrentParseScope: function getCurrentParseScope() {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    },\n    parseColourMetaDirective: function parseColourMetaDirective(lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = LDrawLoader.FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = LDrawLoader.FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = LDrawLoader.FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case LDrawLoader.FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: UniformsUtils.merge([UniformsLib.fog, {\n            diffuse: {\n              value: new Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    },\n    //\n    objectParse: function objectParse(text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var lineIndex = 0;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  var matrix = currentParseScope.matrix;\n\n                  if (matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  var material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            var material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: LDrawLoader.FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, v3, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    },\n    computeConstructionSteps: function computeConstructionSteps(model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    },\n    processObject: function processObject(text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          var objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (var i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (var _i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n            var os = conditionalSegments[_i5];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (var _i6 = 0, _l5 = triangles.length; _i6 < _l5; _i6++) {\n            var tri = triangles[_i6];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n              tempVec0.subVectors(tri.v1, tri.v0);\n              tempVec1.subVectors(tri.v2, tri.v1);\n              tri.faceNormal.crossVectors(tempVec0, tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case LDrawLoader.FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case LDrawLoader.FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  });\n  return LDrawLoader;\n}();\n\nexport { LDrawLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/LDrawLoader.js"],"names":["Vector3","Loader","FileLoader","Matrix4","MeshStandardMaterial","Color","MeshPhongMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Group","BufferGeometry","Float32BufferAttribute","LineSegments","Mesh","BufferAttribute","LDrawLoader","conditionalLineVertShader","conditionalLineFragShader","tempVec0","tempVec1","smoothNormals","triangles","lineSegments","hashVertex","v","x","y","z","hashEdge","v0","v1","hardEdges","Set","halfEdgeList","fullHalfEdgeList","normals","i","l","length","ls","add","tri","i2","l2","index","next","hash","has","halfEdges","Object","keys","queue","faceNormal","n0","clone","push","n1","n2","reverseHash","otherTri","Math","abs","dot","i3","l3","otherIndex","otherNext","otherV0","otherV1","otherHash","norm","normalize","isPrimitiveType","type","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","prototype","constructor","seekNonSpace","charAt","getToken","pos0","pos1","substring","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","sortByMaterial","a","b","colourCode","createObject","elements","elementSize","isConditionalSegments","sort","positions","materials","bufferGeometry","prevMaterial","index0","numGroupVerts","iElem","nElem","elem","v2","material","addGroup","Infinity","setAttribute","object3d","isConditionalLine","controlArray0","Float32Array","controlArray1","directionArray","os","c0","c1","manager","call","parseScopesStack","subobjectCache","fileMap","setMaterials","parseColourMetaDirective","separateObjects","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","assign","create","load","url","onLoad","onProgress","onError","scope","fileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","processObject","parse","newParseScopeLevel","getCurrentParseScope","isFromParse","setFileMap","matLib","n","userData","code","topParseScope","newParseScope","lib","subobjects","numSubobjects","subobjectIndex","inverted","category","keywords","currentFileName","mainColourCode","mainEdgeColourCode","currentMatrix","matrix","conditionalSegments","startingConstructionStep","removeScopeLevel","pop","addMaterial","getMaterial","startsWith","colour","getParentParseScope","lineParser","edgeColour","alpha","isTransparent","luminance","finishType","canHaveEnvMap","edgeMaterial","name","token","toUpperCase","parseInt","isNaN","max","min","color","roughness","envMapIntensity","metalness","specular","hsl","getHSL","h","s","setHSL","shininess","reflectivity","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","set","multiplyScalar","conditionalEdgeMaterial","vertexShader","fragmentShader","uniforms","merge","fog","diffuse","value","objectParse","parentParseScope","currentParseScope","indexOf","replace","lines","split","numLines","lineIndex","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","parseColourCode","forEdge","parseVector","lp","parseFloat","applyMatrix4","toLowerCase","lineType","meta","isRoot","groupObject","determinant","console","warn","newKeywords","forEach","keyword","trim","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","fileName","originalFileName","locationState","triedLowerCase","segment","ccw","doubleSided","subVectors","crossVectors","v3","computeConstructionSteps","model","stepNumber","traverse","c","isGroup","constructionStep","numConstructionSteps","onProcessed","subobject","parseScope","multiplyMatrices","copy","undefined","finishedCount","onSubobjectFinish","finalizeObject","Promise","resolve","then","loadSubobject","objGroup","decompose","position","quaternion","scale","parentLineSegments","parentConditionalSegments","parentTriangles","cached","subobjectGroup","onSubobjectLoaded","subobjectURL","newLocationState","lastIndexOf","err","onSubobjectError"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,MAAlB,EAA0BC,UAA1B,EAAsCC,OAAtC,EAA+CC,oBAA/C,EAAqEC,KAArE,EAA4EC,iBAA5E,EAA+FC,iBAA/F,EAAkHC,cAAlH,EAAkIC,aAAlI,EAAiJC,WAAjJ,EAA8JC,KAA9J,EAAqKC,cAArK,EAAqLC,sBAArL,EAA6MC,YAA7M,EAA2NC,IAA3N,EAAiOC,eAAjO,QAAwP,OAAxP;;AAEA,IAAIC,WAAW,GAAG,YAAY;AAC5B,MAAIC,yBAAyB;AAC7B;AAD6B,0lDAA7B;AAiDA,MAAIC,yBAAyB;AAC7B;AAD6B,mxBAA7B;AA6BA,MAAIC,QAAQ,GAAG,IAAIpB,OAAJ,EAAf;AACA,MAAIqB,QAAQ,GAAG,IAAIrB,OAAJ,EAAf;;AAEA,WAASsB,aAAT,CAAuBC,SAAvB,EAAkCC,YAAlC,EAAgD;AAC9C,aAASC,UAAT,CAAoBC,CAApB,EAAuB;AACrB;AACA;AACA;AACA,UAAIC,CAAC,GAAG,CAAC,EAAED,CAAC,CAACC,CAAF,GAAM,GAAR,CAAT;AACA,UAAIC,CAAC,GAAG,CAAC,EAAEF,CAAC,CAACE,CAAF,GAAM,GAAR,CAAT;AACA,UAAIC,CAAC,GAAG,CAAC,EAAEH,CAAC,CAACG,CAAF,GAAM,GAAR,CAAT;AACA,uBAAUF,CAAV,cAAeC,CAAf,cAAoBC,CAApB;AACD;;AAED,aAASC,QAAT,CAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AACxB,uBAAUP,UAAU,CAACM,EAAD,CAApB,cAA4BN,UAAU,CAACO,EAAD,CAAtC;AACD;;AAED,QAAIC,SAAS,GAAG,IAAIC,GAAJ,EAAhB;AACA,QAAIC,YAAY,GAAG,EAAnB;AACA,QAAIC,gBAAgB,GAAG,EAAvB;AACA,QAAIC,OAAO,GAAG,EAAd,CAlB8C,CAkB5B;;AAElB,SAAK,IAAIC,EAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,YAAY,CAACgB,MAAjC,EAAyCF,EAAC,GAAGC,CAA7C,EAAgDD,EAAC,EAAjD,EAAqD;AACnD,UAAIG,EAAE,GAAGjB,YAAY,CAACc,EAAD,CAArB;AACA,UAAIP,EAAE,GAAGU,EAAE,CAACV,EAAZ;AACA,UAAIC,EAAE,GAAGS,EAAE,CAACT,EAAZ;AACAC,MAAAA,SAAS,CAACS,GAAV,CAAcZ,QAAQ,CAACC,EAAD,EAAKC,EAAL,CAAtB;AACAC,MAAAA,SAAS,CAACS,GAAV,CAAcZ,QAAQ,CAACE,EAAD,EAAKD,EAAL,CAAtB;AACD,KA1B6C,CA0B5C;;;AAGF,SAAK,IAAIO,GAAC,GAAG,CAAR,EAAWC,EAAC,GAAGhB,SAAS,CAACiB,MAA9B,EAAsCF,GAAC,GAAGC,EAA1C,EAA6CD,GAAC,EAA9C,EAAkD;AAChD,UAAIK,GAAG,GAAGpB,SAAS,CAACe,GAAD,CAAnB;;AAEA,WAAK,IAAIM,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,CAAtB,EAAyBD,EAAE,GAAGC,EAA9B,EAAkCD,EAAE,EAApC,EAAwC;AACtC,YAAIE,KAAK,GAAGF,EAAZ;AACA,YAAIG,IAAI,GAAG,CAACH,EAAE,GAAG,CAAN,IAAW,CAAtB;AACA,YAAIb,EAAE,GAAGY,GAAG,YAAKG,KAAL,EAAZ;AACA,YAAId,EAAE,GAAGW,GAAG,YAAKI,IAAL,EAAZ;AACA,YAAIC,IAAI,GAAGlB,QAAQ,CAACC,EAAD,EAAKC,EAAL,CAAnB,CALsC,CAKT;;AAE7B,YAAIC,SAAS,CAACgB,GAAV,CAAcD,IAAd,CAAJ,EAAyB;AACzBb,QAAAA,YAAY,CAACa,IAAD,CAAZ,GAAqBL,GAArB;AACAP,QAAAA,gBAAgB,CAACY,IAAD,CAAhB,GAAyBL,GAAzB;AACD;AACF,KA3C6C,CA2C5C;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGA,WAAO,IAAP,EAAa;AACX;AACA,UAAIO,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYjB,YAAZ,CAAhB;AACA,UAAIe,SAAS,CAACV,MAAV,KAAqB,CAAzB,EAA4B,MAHjB,CAGwB;;AAEnC,UAAIF,CAAC,GAAG,CAAR;AACA,UAAIe,KAAK,GAAG,CAACjB,gBAAgB,CAACc,SAAS,CAAC,CAAD,CAAV,CAAjB,CAAZ;;AAEA,aAAOZ,CAAC,GAAGe,KAAK,CAACb,MAAjB,EAAyB;AACvB;AACA,YAAIG,GAAG,GAAGU,KAAK,CAACf,CAAD,CAAf;AACAA,QAAAA,CAAC;AACD,YAAIgB,UAAU,GAAGX,GAAG,CAACW,UAArB;;AAEA,YAAIX,GAAG,CAACY,EAAJ,KAAW,IAAf,EAAqB;AACnBZ,UAAAA,GAAG,CAACY,EAAJ,GAASD,UAAU,CAACE,KAAX,EAAT;AACAnB,UAAAA,OAAO,CAACoB,IAAR,CAAad,GAAG,CAACY,EAAjB;AACD;;AAED,YAAIZ,GAAG,CAACe,EAAJ,KAAW,IAAf,EAAqB;AACnBf,UAAAA,GAAG,CAACe,EAAJ,GAASJ,UAAU,CAACE,KAAX,EAAT;AACAnB,UAAAA,OAAO,CAACoB,IAAR,CAAad,GAAG,CAACe,EAAjB;AACD;;AAED,YAAIf,GAAG,CAACgB,EAAJ,KAAW,IAAf,EAAqB;AACnBhB,UAAAA,GAAG,CAACgB,EAAJ,GAASL,UAAU,CAACE,KAAX,EAAT;AACAnB,UAAAA,OAAO,CAACoB,IAAR,CAAad,GAAG,CAACgB,EAAjB;AACD,SAnBsB,CAmBrB;;;AAGF,aAAK,IAAIf,GAAE,GAAG,CAAT,EAAYC,GAAE,GAAG,CAAtB,EAAyBD,GAAE,GAAGC,GAA9B,EAAkCD,GAAE,EAApC,EAAwC;AACtC,cAAIE,KAAK,GAAGF,GAAZ;AACA,cAAIG,IAAI,GAAG,CAACH,GAAE,GAAG,CAAN,IAAW,CAAtB;AACA,cAAIb,EAAE,GAAGY,GAAG,YAAKG,KAAL,EAAZ;AACA,cAAId,EAAE,GAAGW,GAAG,YAAKI,IAAL,EAAZ,CAJsC,CAIZ;;AAE1B,cAAIC,IAAI,GAAGlB,QAAQ,CAACC,EAAD,EAAKC,EAAL,CAAnB;AACA,iBAAOG,YAAY,CAACa,IAAD,CAAnB;AACA,cAAIY,WAAW,GAAG9B,QAAQ,CAACE,EAAD,EAAKD,EAAL,CAA1B;AACA,cAAI8B,QAAQ,GAAGzB,gBAAgB,CAACwB,WAAD,CAA/B;;AAEA,cAAIC,QAAJ,EAAc;AACZ;AACA;AACA;AACA,gBAAIC,IAAI,CAACC,GAAL,CAASF,QAAQ,CAACP,UAAT,CAAoBU,GAApB,CAAwBrB,GAAG,CAACW,UAA5B,CAAT,IAAoD,IAAxD,EAA8D;AAC5D;AACD,aANW,CAMV;AACF;AACA;;;AAGA,gBAAIM,WAAW,IAAIzB,YAAnB,EAAiC;AAC/BkB,cAAAA,KAAK,CAACI,IAAN,CAAWI,QAAX;AACA,qBAAO1B,YAAY,CAACyB,WAAD,CAAnB;AACD,aAdW,CAcV;;;AAGF,iBAAK,IAAIK,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,CAAtB,EAAyBD,EAAE,GAAGC,EAA9B,EAAkCD,EAAE,EAApC,EAAwC;AACtC,kBAAIE,UAAU,GAAGF,EAAjB;AACA,kBAAIG,SAAS,GAAG,CAACH,EAAE,GAAG,CAAN,IAAW,CAA3B;AACA,kBAAII,OAAO,GAAGR,QAAQ,YAAKM,UAAL,EAAtB;AACA,kBAAIG,OAAO,GAAGT,QAAQ,YAAKO,SAAL,EAAtB;AACA,kBAAIG,SAAS,GAAGzC,QAAQ,CAACuC,OAAD,EAAUC,OAAV,CAAxB;;AAEA,kBAAIC,SAAS,KAAKX,WAAlB,EAA+B;AAC7B,oBAAIC,QAAQ,YAAKM,UAAL,EAAR,KAA+B,IAAnC,EAAyC;AACvC,sBAAIK,IAAI,GAAG7B,GAAG,YAAKI,IAAL,EAAd;AACAc,kBAAAA,QAAQ,YAAKM,UAAL,EAAR,GAA6BK,IAA7B;AACAA,kBAAAA,IAAI,CAAC9B,GAAL,CAASmB,QAAQ,CAACP,UAAlB;AACD;;AAED,oBAAIO,QAAQ,YAAKO,SAAL,EAAR,KAA8B,IAAlC,EAAwC;AACtC,sBAAII,IAAI,GAAG7B,GAAG,YAAKG,KAAL,EAAd;AACAe,kBAAAA,QAAQ,YAAKO,SAAL,EAAR,GAA4BI,IAA5B;AACAA,kBAAAA,IAAI,CAAC9B,GAAL,CAASmB,QAAQ,CAACP,UAAlB;AACD;;AAED;AACD;AACF;AACF;AACF;AACF;AACF,KAxI6C,CAwI5C;;;AAGF,SAAK,IAAIhB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGF,OAAO,CAACG,MAA5B,EAAoCF,GAAC,GAAGC,GAAxC,EAA2CD,GAAC,EAA5C,EAAgD;AAC9CD,MAAAA,OAAO,CAACC,GAAD,CAAP,CAAWmC,SAAX;AACD;AACF;;AAED,WAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC7B,WAAO,aAAaC,IAAb,CAAkBD,IAAlB,KAA2BA,IAAI,KAAK,SAA3C;AACD;;AAED,WAASE,UAAT,CAAoBC,IAApB,EAA0BC,UAA1B,EAAsC;AACpC,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKE,UAAL,GAAkBF,IAAI,CAACtC,MAAvB;AACA,SAAKyC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,WAAL,GAAmB,GAAnB;AACA,SAAKH,UAAL,GAAkBA,UAAlB;AACD;;AAEDF,EAAAA,UAAU,CAACM,SAAX,GAAuB;AACrBC,IAAAA,WAAW,EAAEP,UADQ;AAErBQ,IAAAA,YAAY,EAAE,wBAAY;AACxB,aAAO,KAAKJ,gBAAL,GAAwB,KAAKD,UAApC,EAAgD;AAC9C,aAAKE,WAAL,GAAmB,KAAKJ,IAAL,CAAUQ,MAAV,CAAiB,KAAKL,gBAAtB,CAAnB;;AAEA,YAAI,KAAKC,WAAL,KAAqB,GAArB,IAA4B,KAAKA,WAAL,KAAqB,IAArD,EAA2D;AACzD;AACD;;AAED,aAAKD,gBAAL;AACD;AACF,KAZoB;AAarBM,IAAAA,QAAQ,EAAE,oBAAY;AACpB,UAAIC,IAAI,GAAG,KAAKP,gBAAL,EAAX,CADoB,CACgB;;AAEpC,aAAO,KAAKA,gBAAL,GAAwB,KAAKD,UAApC,EAAgD;AAC9C,aAAKE,WAAL,GAAmB,KAAKJ,IAAL,CAAUQ,MAAV,CAAiB,KAAKL,gBAAtB,CAAnB;;AAEA,YAAI,KAAKC,WAAL,KAAqB,GAArB,IAA4B,KAAKA,WAAL,KAAqB,IAArD,EAA2D;AACzD;AACD;;AAED,aAAKD,gBAAL;AACD;;AAED,UAAIQ,IAAI,GAAG,KAAKR,gBAAhB;AACA,WAAKI,YAAL;AACA,aAAO,KAAKP,IAAL,CAAUY,SAAV,CAAoBF,IAApB,EAA0BC,IAA1B,CAAP;AACD,KA7BoB;AA8BrBE,IAAAA,kBAAkB,EAAE,8BAAY;AAC9B,aAAO,KAAKb,IAAL,CAAUY,SAAV,CAAoB,KAAKT,gBAAzB,EAA2C,KAAKD,UAAhD,CAAP;AACD,KAhCoB;AAiCrBY,IAAAA,UAAU,EAAE,sBAAY;AACtB,aAAO,KAAKX,gBAAL,IAAyB,KAAKD,UAArC;AACD,KAnCoB;AAoCrBa,IAAAA,QAAQ,EAAE,oBAAY;AACpB,WAAKZ,gBAAL,GAAwB,KAAKD,UAA7B;AACD,KAtCoB;AAuCrBc,IAAAA,mBAAmB,EAAE,+BAAY;AAC/B,aAAO,KAAKf,UAAL,IAAmB,CAAnB,GAAuB,cAAc,KAAKA,UAA1C,GAAuD,EAA9D;AACD;AAzCoB,GAAvB;;AA4CA,WAASgB,cAAT,CAAwBC,CAAxB,EAA2BC,CAA3B,EAA8B;AAC5B,QAAID,CAAC,CAACE,UAAF,KAAiBD,CAAC,CAACC,UAAvB,EAAmC;AACjC,aAAO,CAAP;AACD;;AAED,QAAIF,CAAC,CAACE,UAAF,GAAeD,CAAC,CAACC,UAArB,EAAiC;AAC/B,aAAO,CAAC,CAAR;AACD;;AAED,WAAO,CAAP;AACD;;AAED,WAASC,YAAT,CAAsBC,QAAtB,EAAgCC,WAAhC,EAA6CC,qBAA7C,EAAoE;AAClE;AACA;AACA;AACAF,IAAAA,QAAQ,CAACG,IAAT,CAAcR,cAAd;AACA,QAAIS,SAAS,GAAG,EAAhB;AACA,QAAInE,OAAO,GAAG,EAAd;AACA,QAAIoE,SAAS,GAAG,EAAhB;AACA,QAAIC,cAAc,GAAG,IAAI9F,cAAJ,EAArB;AACA,QAAI+F,YAAY,GAAG,IAAnB;AACA,QAAIC,MAAM,GAAG,CAAb;AACA,QAAIC,aAAa,GAAG,CAApB;;AAEA,SAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,KAAK,GAAGX,QAAQ,CAAC5D,MAArC,EAA6CsE,KAAK,GAAGC,KAArD,EAA4DD,KAAK,EAAjE,EAAqE;AACnE,UAAIE,IAAI,GAAGZ,QAAQ,CAACU,KAAD,CAAnB;AACA,UAAI/E,EAAE,GAAGiF,IAAI,CAACjF,EAAd;AACA,UAAIC,EAAE,GAAGgF,IAAI,CAAChF,EAAd,CAHmE,CAGjD;;AAElBwE,MAAAA,SAAS,CAAC/C,IAAV,CAAe1B,EAAE,CAACJ,CAAlB,EAAqBI,EAAE,CAACH,CAAxB,EAA2BG,EAAE,CAACF,CAA9B,EAAiCG,EAAE,CAACL,CAApC,EAAuCK,EAAE,CAACJ,CAA1C,EAA6CI,EAAE,CAACH,CAAhD;;AAEA,UAAIwE,WAAW,KAAK,CAApB,EAAuB;AACrBG,QAAAA,SAAS,CAAC/C,IAAV,CAAeuD,IAAI,CAACC,EAAL,CAAQtF,CAAvB,EAA0BqF,IAAI,CAACC,EAAL,CAAQrF,CAAlC,EAAqCoF,IAAI,CAACC,EAAL,CAAQpF,CAA7C;AACA,YAAI0B,EAAE,GAAGyD,IAAI,CAACzD,EAAL,IAAWyD,IAAI,CAAC1D,UAAzB;AACA,YAAII,EAAE,GAAGsD,IAAI,CAACtD,EAAL,IAAWsD,IAAI,CAAC1D,UAAzB;AACA,YAAIK,EAAE,GAAGqD,IAAI,CAACrD,EAAL,IAAWqD,IAAI,CAAC1D,UAAzB;AACAjB,QAAAA,OAAO,CAACoB,IAAR,CAAaF,EAAE,CAAC5B,CAAhB,EAAmB4B,EAAE,CAAC3B,CAAtB,EAAyB2B,EAAE,CAAC1B,CAA5B;AACAQ,QAAAA,OAAO,CAACoB,IAAR,CAAaC,EAAE,CAAC/B,CAAhB,EAAmB+B,EAAE,CAAC9B,CAAtB,EAAyB8B,EAAE,CAAC7B,CAA5B;AACAQ,QAAAA,OAAO,CAACoB,IAAR,CAAaE,EAAE,CAAChC,CAAhB,EAAmBgC,EAAE,CAAC/B,CAAtB,EAAyB+B,EAAE,CAAC9B,CAA5B;AACD;;AAED,UAAI8E,YAAY,KAAKK,IAAI,CAACE,QAA1B,EAAoC;AAClC,YAAIP,YAAY,KAAK,IAArB,EAA2B;AACzBD,UAAAA,cAAc,CAACS,QAAf,CAAwBP,MAAxB,EAAgCC,aAAhC,EAA+CJ,SAAS,CAACjE,MAAV,GAAmB,CAAlE;AACD;;AAEDiE,QAAAA,SAAS,CAAChD,IAAV,CAAeuD,IAAI,CAACE,QAApB;AACAP,QAAAA,YAAY,GAAGK,IAAI,CAACE,QAApB;AACAN,QAAAA,MAAM,GAAGE,KAAK,GAAGT,WAAjB;AACAQ,QAAAA,aAAa,GAAGR,WAAhB;AACD,OATD,MASO;AACLQ,QAAAA,aAAa,IAAIR,WAAjB;AACD;AACF;;AAED,QAAIQ,aAAa,GAAG,CAApB,EAAuB;AACrBH,MAAAA,cAAc,CAACS,QAAf,CAAwBP,MAAxB,EAAgCQ,QAAhC,EAA0CX,SAAS,CAACjE,MAAV,GAAmB,CAA7D;AACD;;AAEDkE,IAAAA,cAAc,CAACW,YAAf,CAA4B,UAA5B,EAAwC,IAAIxG,sBAAJ,CAA2B2F,SAA3B,EAAsC,CAAtC,CAAxC;;AAEA,QAAIH,WAAW,KAAK,CAApB,EAAuB;AACrBK,MAAAA,cAAc,CAACW,YAAf,CAA4B,QAA5B,EAAsC,IAAIxG,sBAAJ,CAA2BwB,OAA3B,EAAoC,CAApC,CAAtC;AACD;;AAED,QAAIiF,QAAQ,GAAG,IAAf;;AAEA,QAAIjB,WAAW,KAAK,CAApB,EAAuB;AACrBiB,MAAAA,QAAQ,GAAG,IAAIxG,YAAJ,CAAiB4F,cAAjB,EAAiCD,SAAjC,CAAX;AACD,KAFD,MAEO,IAAIJ,WAAW,KAAK,CAApB,EAAuB;AAC5BiB,MAAAA,QAAQ,GAAG,IAAIvG,IAAJ,CAAS2F,cAAT,EAAyBD,SAAzB,CAAX;AACD;;AAED,QAAIH,qBAAJ,EAA2B;AACzBgB,MAAAA,QAAQ,CAACC,iBAAT,GAA6B,IAA7B;AACA,UAAIC,aAAa,GAAG,IAAIC,YAAJ,CAAiBrB,QAAQ,CAAC5D,MAAT,GAAkB,CAAlB,GAAsB,CAAvC,CAApB;AACA,UAAIkF,aAAa,GAAG,IAAID,YAAJ,CAAiBrB,QAAQ,CAAC5D,MAAT,GAAkB,CAAlB,GAAsB,CAAvC,CAApB;AACA,UAAImF,cAAc,GAAG,IAAIF,YAAJ,CAAiBrB,QAAQ,CAAC5D,MAAT,GAAkB,CAAlB,GAAsB,CAAvC,CAArB;;AAEA,WAAK,IAAIF,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG6D,QAAQ,CAAC5D,MAA7B,EAAqCF,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,YAAIsF,EAAE,GAAGxB,QAAQ,CAAC9D,CAAD,CAAjB;AACA,YAAIuF,EAAE,GAAGD,EAAE,CAACC,EAAZ;AACA,YAAIC,EAAE,GAAGF,EAAE,CAACE,EAAZ;AACA,YAAI/F,EAAE,GAAG6F,EAAE,CAAC7F,EAAZ;AACA,YAAIC,EAAE,GAAG4F,EAAE,CAAC5F,EAAZ;AACA,YAAIc,KAAK,GAAGR,CAAC,GAAG,CAAJ,GAAQ,CAApB;AACAkF,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAAClG,CAA9B;AACA6F,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAACjG,CAA9B;AACA4F,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAAChG,CAA9B;AACA2F,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAAClG,CAA9B;AACA6F,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAACjG,CAA9B;AACA4F,QAAAA,aAAa,CAAC1E,KAAK,GAAG,CAAT,CAAb,GAA2B+E,EAAE,CAAChG,CAA9B;AACA6F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAACnG,CAA9B;AACA+F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAAClG,CAA9B;AACA8F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAACjG,CAA9B;AACA6F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAACnG,CAA9B;AACA+F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAAClG,CAA9B;AACA8F,QAAAA,aAAa,CAAC5E,KAAK,GAAG,CAAT,CAAb,GAA2BgF,EAAE,CAACjG,CAA9B;AACA8F,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACL,CAAH,GAAOI,EAAE,CAACJ,CAAtC;AACAgG,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACJ,CAAH,GAAOG,EAAE,CAACH,CAAtC;AACA+F,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACH,CAAH,GAAOE,EAAE,CAACF,CAAtC;AACA8F,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACL,CAAH,GAAOI,EAAE,CAACJ,CAAtC;AACAgG,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACJ,CAAH,GAAOG,EAAE,CAACH,CAAtC;AACA+F,QAAAA,cAAc,CAAC7E,KAAK,GAAG,CAAT,CAAd,GAA4Bd,EAAE,CAACH,CAAH,GAAOE,EAAE,CAACF,CAAtC;AACD;;AAED6E,MAAAA,cAAc,CAACW,YAAf,CAA4B,UAA5B,EAAwC,IAAIrG,eAAJ,CAAoBwG,aAApB,EAAmC,CAAnC,EAAsC,KAAtC,CAAxC;AACAd,MAAAA,cAAc,CAACW,YAAf,CAA4B,UAA5B,EAAwC,IAAIrG,eAAJ,CAAoB0G,aAApB,EAAmC,CAAnC,EAAsC,KAAtC,CAAxC;AACAhB,MAAAA,cAAc,CAACW,YAAf,CAA4B,WAA5B,EAAyC,IAAIrG,eAAJ,CAAoB2G,cAApB,EAAoC,CAApC,EAAuC,KAAvC,CAAzC;AACD;;AAED,WAAOL,QAAP;AACD,GA3Y2B,CA2Y1B;;;AAGF,WAASrG,WAAT,CAAqB8G,OAArB,EAA8B;AAC5B9H,IAAAA,MAAM,CAAC+H,IAAP,CAAY,IAAZ,EAAkBD,OAAlB,EAD4B,CACA;AAC5B;AACA;AACA;;AAEA,SAAKE,gBAAL,GAAwB,IAAxB,CAN4B,CAME;;AAE9B,SAAKxB,SAAL,GAAiB,EAAjB,CAR4B,CAQP;AACrB;;AAEA,SAAKyB,cAAL,GAAsB,EAAtB,CAX4B,CAWF;;AAE1B,SAAKC,OAAL,GAAe,IAAf,CAb4B,CAaP;;AAErB,SAAKC,YAAL,CAAkB,CAAC,KAAKC,wBAAL,CAA8B,IAAIxD,UAAJ,CAAe,gDAAf,CAA9B,CAAD,EAAkG,KAAKwD,wBAAL,CAA8B,IAAIxD,UAAJ,CAAe,gDAAf,CAA9B,CAAlG,CAAlB,EAf4B,CAe2L;AACvN;;AAEA,SAAKyD,eAAL,GAAuB,KAAvB,CAlB4B,CAkBE;;AAE9B,SAAKhH,aAAL,GAAqB,IAArB;AACD,GAna2B,CAma1B;AACF;;;AAGAL,EAAAA,WAAW,CAACsH,mBAAZ,GAAkC,CAAlC;AACAtH,EAAAA,WAAW,CAACuH,kBAAZ,GAAiC,CAAjC;AACAvH,EAAAA,WAAW,CAACwH,uBAAZ,GAAsC,CAAtC;AACAxH,EAAAA,WAAW,CAACyH,kBAAZ,GAAiC,CAAjC;AACAzH,EAAAA,WAAW,CAAC0H,0BAAZ,GAAyC,CAAzC;AACA1H,EAAAA,WAAW,CAAC2H,iBAAZ,GAAgC,CAAhC,CA5a4B,CA4aO;AACnC;;AAEA3H,EAAAA,WAAW,CAAC4H,mBAAZ,GAAkC,CAAlC;AACA5H,EAAAA,WAAW,CAAC6H,uBAAZ,GAAsC,CAAtC;AACA7H,EAAAA,WAAW,CAAC8H,mBAAZ,GAAkC,CAAlC;AACA9H,EAAAA,WAAW,CAAC+H,wBAAZ,GAAuC,CAAvC;AACA/H,EAAAA,WAAW,CAACgI,0BAAZ,GAAyC,CAAzC;AACAhI,EAAAA,WAAW,CAACiI,0BAAZ,GAAyC,CAAzC;AACAjI,EAAAA,WAAW,CAACkI,uBAAZ,GAAsC,CAAtC;AACAlI,EAAAA,WAAW,CAACkE,SAAZ,GAAwBhC,MAAM,CAACiG,MAAP,CAAcjG,MAAM,CAACkG,MAAP,CAAcpJ,MAAM,CAACkF,SAArB,CAAd,EAA+C;AACrEC,IAAAA,WAAW,EAAEnE,WADwD;AAErEqI,IAAAA,IAAI,EAAE,cAAUC,GAAV,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,OAAnC,EAA4C;AAChD,UAAI,CAAC,KAAKvB,OAAV,EAAmB;AACjB,aAAKA,OAAL,GAAe,EAAf;AACD;;AAED,UAAIwB,KAAK,GAAG,IAAZ;AACA,UAAIC,UAAU,GAAG,IAAI1J,UAAJ,CAAe,KAAK6H,OAApB,CAAjB;AACA6B,MAAAA,UAAU,CAACC,OAAX,CAAmB,KAAKC,IAAxB;AACAF,MAAAA,UAAU,CAACG,gBAAX,CAA4B,KAAKC,aAAjC;AACAJ,MAAAA,UAAU,CAACK,kBAAX,CAA8B,KAAKC,eAAnC;AACAN,MAAAA,UAAU,CAACN,IAAX,CAAgBC,GAAhB,EAAqB,UAAUY,IAAV,EAAgB;AACnCR,QAAAA,KAAK,CAACS,aAAN,CAAoBD,IAApB,EAA0BX,MAA1B,EAAkC,IAAlC,EAAwCD,GAAxC;AACD,OAFD,EAEGE,UAFH,EAEeC,OAFf;AAGD,KAfoE;AAgBrEW,IAAAA,KAAK,EAAE,eAAUF,IAAV,EAAgBL,IAAhB,EAAsBN,MAAtB,EAA8B;AACnC;AACA,WAAKY,aAAL,CAAmBD,IAAnB,EAAyBX,MAAzB,EAAiC,IAAjC,EAAuCM,IAAvC;AACD,KAnBoE;AAoBrE1B,IAAAA,YAAY,EAAE,sBAAU3B,SAAV,EAAqB;AACjC;AACA,WAAKwB,gBAAL,GAAwB,EAAxB;AACA,WAAKqC,kBAAL,CAAwB7D,SAAxB;AACA,WAAK8D,oBAAL,GAA4BC,WAA5B,GAA0C,KAA1C;AACA,WAAK/D,SAAL,GAAiBA,SAAjB;AACA,aAAO,IAAP;AACD,KA3BoE;AA4BrEgE,IAAAA,UAAU,EAAE,oBAAUtC,OAAV,EAAmB;AAC7B,WAAKA,OAAL,GAAeA,OAAf;AACA,aAAO,IAAP;AACD,KA/BoE;AAgCrEmC,IAAAA,kBAAkB,EAAE,4BAAU7D,SAAV,EAAqB;AACvC;AACA,UAAIiE,MAAM,GAAG,EAAb;;AAEA,UAAIjE,SAAJ,EAAe;AACb,aAAK,IAAInE,CAAC,GAAG,CAAR,EAAWqI,CAAC,GAAGlE,SAAS,CAACjE,MAA9B,EAAsCF,CAAC,GAAGqI,CAA1C,EAA6CrI,CAAC,EAA9C,EAAkD;AAChD,cAAI4E,QAAQ,GAAGT,SAAS,CAACnE,CAAD,CAAxB;AACAoI,UAAAA,MAAM,CAACxD,QAAQ,CAAC0D,QAAT,CAAkBC,IAAnB,CAAN,GAAiC3D,QAAjC;AACD;AACF;;AAED,UAAI4D,aAAa,GAAG,KAAKP,oBAAL,EAApB;AACA,UAAIQ,aAAa,GAAG;AAClBC,QAAAA,GAAG,EAAEN,MADa;AAElBnB,QAAAA,GAAG,EAAE,IAFa;AAGlB;AACA0B,QAAAA,UAAU,EAAE,IAJM;AAKlBC,QAAAA,aAAa,EAAE,CALG;AAMlBC,QAAAA,cAAc,EAAE,CANE;AAOlBC,QAAAA,QAAQ,EAAE,KAPQ;AAQlBC,QAAAA,QAAQ,EAAE,IARQ;AASlBC,QAAAA,QAAQ,EAAE,IATQ;AAUlB;AACAC,QAAAA,eAAe,EAAE,IAXC;AAYlBC,QAAAA,cAAc,EAAEV,aAAa,GAAGA,aAAa,CAACU,cAAjB,GAAkC,IAZ7C;AAalBC,QAAAA,kBAAkB,EAAEX,aAAa,GAAGA,aAAa,CAACW,kBAAjB,GAAsC,IAbrD;AAclBC,QAAAA,aAAa,EAAE,IAAIvL,OAAJ,EAdG;AAelBwL,QAAAA,MAAM,EAAE,IAAIxL,OAAJ,EAfU;AAgBlB;AACAqK,QAAAA,WAAW,EAAE,IAjBK;AAkBlBjJ,QAAAA,SAAS,EAAE,IAlBO;AAmBlBC,QAAAA,YAAY,EAAE,IAnBI;AAoBlBoK,QAAAA,mBAAmB,EAAE,IApBH;AAqBlB;AACAC,QAAAA,wBAAwB,EAAE;AAtBR,OAApB;AAwBA,WAAK5D,gBAAL,CAAsBxE,IAAtB,CAA2BsH,aAA3B;AACA,aAAOA,aAAP;AACD,KAtEoE;AAuErEe,IAAAA,gBAAgB,EAAE,4BAAY;AAC5B,WAAK7D,gBAAL,CAAsB8D,GAAtB;AACA,aAAO,IAAP;AACD,KA1EoE;AA2ErEC,IAAAA,WAAW,EAAE,qBAAU9E,QAAV,EAAoB;AAC/B;AACA,UAAIwD,MAAM,GAAG,KAAKH,oBAAL,GAA4BS,GAAzC;;AAEA,UAAI,CAACN,MAAM,CAACxD,QAAQ,CAAC0D,QAAT,CAAkBC,IAAnB,CAAX,EAAqC;AACnC,aAAKpE,SAAL,CAAehD,IAAf,CAAoByD,QAApB;AACD;;AAEDwD,MAAAA,MAAM,CAACxD,QAAQ,CAAC0D,QAAT,CAAkBC,IAAnB,CAAN,GAAiC3D,QAAjC;AACA,aAAO,IAAP;AACD,KArFoE;AAsFrE+E,IAAAA,WAAW,EAAE,qBAAU/F,UAAV,EAAsB;AACjC;AACA,UAAIA,UAAU,CAACgG,UAAX,CAAsB,KAAtB,CAAJ,EAAkC;AAChC;AACA,YAAIC,MAAM,GAAGjG,UAAU,CAACR,SAAX,CAAqB,CAArB,CAAb;AACA,eAAO,KAAK2C,wBAAL,CAA8B,IAAIxD,UAAJ,CAAe,kBAAkBsH,MAAlB,GAA2B,kBAA3B,GAAgDA,MAAhD,GAAyD,SAAzD,GAAqEA,MAArE,GAA8E,EAA7F,CAA9B,CAAP;AACD;;AAED,WAAK,IAAI7J,CAAC,GAAG,KAAK2F,gBAAL,CAAsBzF,MAAtB,GAA+B,CAA5C,EAA+CF,CAAC,IAAI,CAApD,EAAuDA,CAAC,EAAxD,EAA4D;AAC1D,YAAI4E,QAAQ,GAAG,KAAKe,gBAAL,CAAsB3F,CAAtB,EAAyB0I,GAAzB,CAA6B9E,UAA7B,CAAf;;AAEA,YAAIgB,QAAJ,EAAc;AACZ,iBAAOA,QAAP;AACD;AACF,OAdgC,CAc/B;;;AAGF,aAAO,IAAP;AACD,KAxGoE;AAyGrEkF,IAAAA,mBAAmB,EAAE,+BAAY;AAC/B,UAAI,KAAKnE,gBAAL,CAAsBzF,MAAtB,GAA+B,CAAnC,EAAsC;AACpC,eAAO,KAAKyF,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBzF,MAAtB,GAA+B,CAArD,CAAP;AACD;;AAED,aAAO,IAAP;AACD,KA/GoE;AAgHrE+H,IAAAA,oBAAoB,EAAE,gCAAY;AAChC,UAAI,KAAKtC,gBAAL,CAAsBzF,MAAtB,GAA+B,CAAnC,EAAsC;AACpC,eAAO,KAAKyF,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBzF,MAAtB,GAA+B,CAArD,CAAP;AACD;;AAED,aAAO,IAAP;AACD,KAtHoE;AAuHrE6F,IAAAA,wBAAwB,EAAE,kCAAUgE,UAAV,EAAsB;AAC9C;AACA,UAAIxB,IAAI,GAAG,IAAX,CAF8C,CAE7B;;AAEjB,UAAIsB,MAAM,GAAG,QAAb;AACA,UAAIG,UAAU,GAAG,QAAjB,CAL8C,CAKnB;;AAE3B,UAAIC,KAAK,GAAG,CAAZ;AACA,UAAIC,aAAa,GAAG,KAApB,CAR8C,CAQnB;;AAE3B,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,UAAU,GAAGzL,WAAW,CAACsH,mBAA7B;AACA,UAAIoE,aAAa,GAAG,IAApB;AACA,UAAIC,YAAY,GAAG,IAAnB;AACA,UAAIC,IAAI,GAAGR,UAAU,CAAC9G,QAAX,EAAX;;AAEA,UAAI,CAACsH,IAAL,EAAW;AACT,cAAM,+DAA+DR,UAAU,CAACvG,mBAAX,EAA/D,GAAkG,GAAxG;AACD,OAlB6C,CAkB5C;;;AAGF,UAAIgH,KAAK,GAAG,IAAZ;;AAEA,aAAO,IAAP,EAAa;AACXA,QAAAA,KAAK,GAAGT,UAAU,CAAC9G,QAAX,EAAR;;AAEA,YAAI,CAACuH,KAAL,EAAY;AACV;AACD;;AAED,gBAAQA,KAAK,CAACC,WAAN,EAAR;AACE,eAAK,MAAL;AACElC,YAAAA,IAAI,GAAGwB,UAAU,CAAC9G,QAAX,EAAP;AACA;;AAEF,eAAK,OAAL;AACE4G,YAAAA,MAAM,GAAGE,UAAU,CAAC9G,QAAX,EAAT;;AAEA,gBAAI4G,MAAM,CAACD,UAAP,CAAkB,IAAlB,CAAJ,EAA6B;AAC3BC,cAAAA,MAAM,GAAG,MAAMA,MAAM,CAACzG,SAAP,CAAiB,CAAjB,CAAf;AACD,aAFD,MAEO,IAAI,CAACyG,MAAM,CAACD,UAAP,CAAkB,GAAlB,CAAL,EAA6B;AAClC,oBAAM,uDAAuDG,UAAU,CAACvG,mBAAX,EAAvD,GAA0F,GAAhG;AACD;;AAED;;AAEF,eAAK,MAAL;AACEwG,YAAAA,UAAU,GAAGD,UAAU,CAAC9G,QAAX,EAAb;;AAEA,gBAAI+G,UAAU,CAACJ,UAAX,CAAsB,IAAtB,CAAJ,EAAiC;AAC/BI,cAAAA,UAAU,GAAG,MAAMA,UAAU,CAAC5G,SAAX,CAAqB,CAArB,CAAnB;AACD,aAFD,MAEO,IAAI,CAAC4G,UAAU,CAACJ,UAAX,CAAsB,GAAtB,CAAL,EAAiC;AACtC;AACAU,cAAAA,YAAY,GAAG,KAAKX,WAAL,CAAiBK,UAAjB,CAAf;;AAEA,kBAAI,CAACM,YAAL,EAAmB;AACjB,sBAAM,4DAA4DP,UAAU,CAACvG,mBAAX,EAA5D,GAA+F,GAArG;AACD,eANqC,CAMpC;;;AAGF8G,cAAAA,YAAY,GAAGA,YAAY,CAAChC,QAAb,CAAsBgC,YAArC;AACD;;AAED;;AAEF,eAAK,OAAL;AACEL,YAAAA,KAAK,GAAGS,QAAQ,CAACX,UAAU,CAAC9G,QAAX,EAAD,CAAhB;;AAEA,gBAAI0H,KAAK,CAACV,KAAD,CAAT,EAAkB;AAChB,oBAAM,4DAA4DF,UAAU,CAACvG,mBAAX,EAA5D,GAA+F,GAArG;AACD;;AAEDyG,YAAAA,KAAK,GAAGzI,IAAI,CAACoJ,GAAL,CAAS,CAAT,EAAYpJ,IAAI,CAACqJ,GAAL,CAAS,CAAT,EAAYZ,KAAK,GAAG,GAApB,CAAZ,CAAR;;AAEA,gBAAIA,KAAK,GAAG,CAAZ,EAAe;AACbC,cAAAA,aAAa,GAAG,IAAhB;AACD;;AAED;;AAEF,eAAK,WAAL;AACEC,YAAAA,SAAS,GAAGO,QAAQ,CAACX,UAAU,CAAC9G,QAAX,EAAD,CAApB;;AAEA,gBAAI0H,KAAK,CAACR,SAAD,CAAT,EAAsB;AACpB,oBAAM,gEAAgE5H,UAAU,CAACiB,mBAAX,EAAhE,GAAmG,GAAzG;AACD;;AAED2G,YAAAA,SAAS,GAAG3I,IAAI,CAACoJ,GAAL,CAAS,CAAT,EAAYpJ,IAAI,CAACqJ,GAAL,CAAS,CAAT,EAAYV,SAAS,GAAG,GAAxB,CAAZ,CAAZ;AACA;;AAEF,eAAK,QAAL;AACEC,YAAAA,UAAU,GAAGzL,WAAW,CAACuH,kBAAzB;AACA;;AAEF,eAAK,aAAL;AACEkE,YAAAA,UAAU,GAAGzL,WAAW,CAACwH,uBAAzB;AACA;;AAEF,eAAK,QAAL;AACEiE,YAAAA,UAAU,GAAGzL,WAAW,CAACyH,kBAAzB;AACA;;AAEF,eAAK,gBAAL;AACEgE,YAAAA,UAAU,GAAGzL,WAAW,CAAC0H,0BAAzB;AACA;;AAEF,eAAK,OAAL;AACE+D,YAAAA,UAAU,GAAGzL,WAAW,CAAC2H,iBAAzB;AACA;;AAEF,eAAK,UAAL;AACE;AACAyD,YAAAA,UAAU,CAACxG,QAAX;AACA;;AAEF;AACE,kBAAM,iCAAiCiH,KAAjC,GAAyC,0BAAzC,GAAsET,UAAU,CAACvG,mBAAX,EAAtE,GAAyG,GAA/G;AAtFJ;AAwFD;;AAED,UAAIoB,QAAQ,GAAG,IAAf;;AAEA,cAAQwF,UAAR;AACE,aAAKzL,WAAW,CAACsH,mBAAjB;AACErB,UAAAA,QAAQ,GAAG,IAAI9G,oBAAJ,CAAyB;AAClCgN,YAAAA,KAAK,EAAEjB,MAD2B;AAElCkB,YAAAA,SAAS,EAAE,GAFuB;AAGlCC,YAAAA,eAAe,EAAE,GAHiB;AAIlCC,YAAAA,SAAS,EAAE;AAJuB,WAAzB,CAAX;AAMA;;AAEF,aAAKtM,WAAW,CAACwH,uBAAjB;AACE;AACA,cAAI+E,QAAQ,GAAG,IAAInN,KAAJ,CAAU8L,MAAV,CAAf;AACA,cAAIsB,GAAG,GAAGD,QAAQ,CAACE,MAAT,CAAgB;AACxBC,YAAAA,CAAC,EAAE,CADqB;AAExBC,YAAAA,CAAC,EAAE,CAFqB;AAGxBrL,YAAAA,CAAC,EAAE;AAHqB,WAAhB,CAAV;AAKAkL,UAAAA,GAAG,CAACE,CAAJ,GAAQ,CAACF,GAAG,CAACE,CAAJ,GAAQ,GAAT,IAAgB,CAAxB;AACAF,UAAAA,GAAG,CAAClL,CAAJ,GAAQuB,IAAI,CAACqJ,GAAL,CAAS,CAAT,EAAYM,GAAG,CAAClL,CAAJ,GAAQ,CAAC,IAAIkL,GAAG,CAAClL,CAAT,IAAc,GAAlC,CAAR;AACAiL,UAAAA,QAAQ,CAACK,MAAT,CAAgBJ,GAAG,CAACE,CAApB,EAAuBF,GAAG,CAACG,CAA3B,EAA8BH,GAAG,CAAClL,CAAlC;AACA2E,UAAAA,QAAQ,GAAG,IAAI5G,iBAAJ,CAAsB;AAC/B8M,YAAAA,KAAK,EAAEjB,MADwB;AAE/BqB,YAAAA,QAAQ,EAAEA,QAFqB;AAG/BM,YAAAA,SAAS,EAAE,EAHoB;AAI/BC,YAAAA,YAAY,EAAE;AAJiB,WAAtB,CAAX;AAMA;;AAEF,aAAK9M,WAAW,CAACuH,kBAAjB;AACE;AACAtB,UAAAA,QAAQ,GAAG,IAAI9G,oBAAJ,CAAyB;AAClCgN,YAAAA,KAAK,EAAEjB,MAD2B;AAElCkB,YAAAA,SAAS,EAAE,CAFuB;AAGlCE,YAAAA,SAAS,EAAE;AAHuB,WAAzB,CAAX;AAKA;;AAEF,aAAKtM,WAAW,CAACyH,kBAAjB;AACE;AACAxB,UAAAA,QAAQ,GAAG,IAAI9G,oBAAJ,CAAyB;AAClCgN,YAAAA,KAAK,EAAEjB,MAD2B;AAElCkB,YAAAA,SAAS,EAAE,GAFuB;AAGlCE,YAAAA,SAAS,EAAE;AAHuB,WAAzB,CAAX;AAKAZ,UAAAA,aAAa,GAAG,KAAhB;AACA;;AAEF,aAAK1L,WAAW,CAAC0H,0BAAjB;AACE;AACAzB,UAAAA,QAAQ,GAAG,IAAI9G,oBAAJ,CAAyB;AAClCgN,YAAAA,KAAK,EAAEjB,MAD2B;AAElCkB,YAAAA,SAAS,EAAE,GAFuB;AAGlCE,YAAAA,SAAS,EAAE;AAHuB,WAAzB,CAAX;AAKA;;AAEF,aAAKtM,WAAW,CAAC2H,iBAAjB;AACE;AACA1B,UAAAA,QAAQ,GAAG,IAAI9G,oBAAJ,CAAyB;AAClCgN,YAAAA,KAAK,EAAEjB,MAD2B;AAElCkB,YAAAA,SAAS,EAAE,GAFuB;AAGlCE,YAAAA,SAAS,EAAE;AAHuB,WAAzB,CAAX;AAKA;AAhEJ;;AAmEArG,MAAAA,QAAQ,CAAC8G,WAAT,GAAuBxB,aAAvB;AACAtF,MAAAA,QAAQ,CAAC+G,kBAAT,GAA8B,IAA9B;AACA/G,MAAAA,QAAQ,CAACgH,OAAT,GAAmB3B,KAAnB;AACArF,MAAAA,QAAQ,CAACiH,UAAT,GAAsB,CAAC3B,aAAvB;AACAtF,MAAAA,QAAQ,CAACkH,aAAT,GAAyB,IAAzB;AACAlH,MAAAA,QAAQ,CAACmH,mBAAT,GAA+B,CAA/B;AACAnH,MAAAA,QAAQ,CAAC0D,QAAT,CAAkB+B,aAAlB,GAAkCA,aAAlC;;AAEA,UAAIF,SAAS,KAAK,CAAlB,EAAqB;AACnBvF,QAAAA,QAAQ,CAACoH,QAAT,CAAkBC,GAAlB,CAAsBrH,QAAQ,CAACkG,KAA/B,EAAsCoB,cAAtC,CAAqD/B,SAArD;AACD;;AAED,UAAI,CAACG,YAAL,EAAmB;AACjB;AACAA,QAAAA,YAAY,GAAG,IAAIrM,iBAAJ,CAAsB;AACnC6M,UAAAA,KAAK,EAAEd,UAD4B;AAEnC0B,UAAAA,WAAW,EAAExB,aAFsB;AAGnC0B,UAAAA,OAAO,EAAE3B,KAH0B;AAInC4B,UAAAA,UAAU,EAAE,CAAC3B;AAJsB,SAAtB,CAAf;AAMAI,QAAAA,YAAY,CAAChC,QAAb,CAAsBC,IAAtB,GAA6BA,IAA7B;AACA+B,QAAAA,YAAY,CAACC,IAAb,GAAoBA,IAAI,GAAG,SAA3B;AACAD,QAAAA,YAAY,CAAChC,QAAb,CAAsB+B,aAAtB,GAAsC,KAAtC,CAViB,CAU4B;;AAE7CC,QAAAA,YAAY,CAAChC,QAAb,CAAsB6D,uBAAtB,GAAgD,IAAIjO,cAAJ,CAAmB;AACjEkO,UAAAA,YAAY,EAAExN,yBADmD;AAEjEyN,UAAAA,cAAc,EAAExN,yBAFiD;AAGjEyN,UAAAA,QAAQ,EAAEnO,aAAa,CAACoO,KAAd,CAAoB,CAACnO,WAAW,CAACoO,GAAb,EAAkB;AAC9CC,YAAAA,OAAO,EAAE;AACPC,cAAAA,KAAK,EAAE,IAAI3O,KAAJ,CAAUiM,UAAV;AADA,aADqC;AAI9C4B,YAAAA,OAAO,EAAE;AACPc,cAAAA,KAAK,EAAEzC;AADA;AAJqC,WAAlB,CAApB,CAHuD;AAWjEuC,UAAAA,GAAG,EAAE,IAX4D;AAYjEd,UAAAA,WAAW,EAAExB,aAZoD;AAajE2B,UAAAA,UAAU,EAAE,CAAC3B;AAboD,SAAnB,CAAhD;AAeAI,QAAAA,YAAY,CAAChC,QAAb,CAAsB6D,uBAAtB,CAA8C7D,QAA9C,CAAuD+B,aAAvD,GAAuE,KAAvE;AACD;;AAEDzF,MAAAA,QAAQ,CAAC0D,QAAT,CAAkBC,IAAlB,GAAyBA,IAAzB;AACA3D,MAAAA,QAAQ,CAAC2F,IAAT,GAAgBA,IAAhB;AACA3F,MAAAA,QAAQ,CAAC0D,QAAT,CAAkBgC,YAAlB,GAAiCA,YAAjC;AACA,aAAO1F,QAAP;AACD,KAlWoE;AAmWrE;AACA+H,IAAAA,WAAW,EAAE,qBAAU9E,IAAV,EAAgB;AAC3B;AACA,UAAI+E,gBAAgB,GAAG,KAAK9C,mBAAL,EAAvB,CAF2B,CAEwB;;AAEnD,UAAIZ,cAAc,GAAG0D,gBAAgB,CAAC1D,cAAtC;AACA,UAAIC,kBAAkB,GAAGyD,gBAAgB,CAACzD,kBAA1C;AACA,UAAI0D,iBAAiB,GAAG,KAAK5E,oBAAL,EAAxB,CAN2B,CAM0B;;AAErD,UAAIhJ,SAAJ;AACA,UAAIC,YAAJ;AACA,UAAIoK,mBAAJ;AACA,UAAIX,UAAU,GAAG,EAAjB;AACA,UAAII,QAAQ,GAAG,IAAf;AACA,UAAIC,QAAQ,GAAG,IAAf;;AAEA,UAAInB,IAAI,CAACiF,OAAL,CAAa,MAAb,MAAyB,CAAC,CAA9B,EAAiC;AAC/B;AACAjF,QAAAA,IAAI,GAAGA,IAAI,CAACkF,OAAL,CAAa,OAAb,EAAsB,IAAtB,CAAP;AACD;;AAED,UAAIC,KAAK,GAAGnF,IAAI,CAACoF,KAAL,CAAW,IAAX,CAAZ;AACA,UAAIC,QAAQ,GAAGF,KAAK,CAAC9M,MAArB;AACA,UAAIiN,SAAS,GAAG,CAAhB;AACA,UAAIC,oBAAoB,GAAG,KAA3B;AACA,UAAIC,uBAAuB,GAAG,IAA9B;AACA,UAAIC,mBAAmB,GAAG,IAA1B;AACA,UAAIC,YAAY,GAAG,KAAnB;AACA,UAAIC,MAAM,GAAG,IAAb;AACA,UAAIC,WAAW,GAAG,KAAlB;AACA,UAAIC,OAAO,GAAG,IAAd;AACA,UAAIrL,IAAI,GAAG,EAAX;AACA,UAAIkH,wBAAwB,GAAG,KAA/B;AACA,UAAIlC,KAAK,GAAG,IAAZ;;AAEA,eAASsG,eAAT,CAAyB5D,UAAzB,EAAqC6D,OAArC,EAA8C;AAC5C;AACA,YAAIhK,UAAU,GAAGmG,UAAU,CAAC9G,QAAX,EAAjB;;AAEA,YAAI,CAAC2K,OAAD,IAAYhK,UAAU,KAAK,IAA/B,EAAqC;AACnCA,UAAAA,UAAU,GAAGsF,cAAb;AACD;;AAED,YAAI0E,OAAO,IAAIhK,UAAU,KAAK,IAA9B,EAAoC;AAClCA,UAAAA,UAAU,GAAGuF,kBAAb;AACD;;AAED,YAAIvE,QAAQ,GAAGyC,KAAK,CAACsC,WAAN,CAAkB/F,UAAlB,CAAf;;AAEA,YAAI,CAACgB,QAAL,EAAe;AACb,gBAAM,uCAAuChB,UAAvC,GAAoD,WAApD,GAAkEmG,UAAU,CAACvG,mBAAX,EAAlE,GAAqG,qCAA3G;AACD;;AAED,eAAOoB,QAAP;AACD;;AAED,eAASiJ,WAAT,CAAqBC,EAArB,EAAyB;AACvB,YAAI1O,CAAC,GAAG,IAAI1B,OAAJ,CAAYqQ,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAtB,EAAuC8K,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAjD,EAAkE8K,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAA5E,CAAR;;AAEA,YAAI,CAACoE,KAAK,CAACrB,eAAX,EAA4B;AAC1B5G,UAAAA,CAAC,CAAC4O,YAAF,CAAenB,iBAAiB,CAACzD,aAAjC;AACD;;AAED,eAAOhK,CAAP;AACD,OA/D0B,CA+DzB;;;AAGF,WAAK+N,SAAS,GAAG,CAAjB,EAAoBA,SAAS,GAAGD,QAAhC,EAA0CC,SAAS,EAAnD,EAAuD;AACrD,YAAI3K,IAAI,GAAGwK,KAAK,CAACG,SAAD,CAAhB;AACA,YAAI3K,IAAI,CAACtC,MAAL,KAAgB,CAApB,EAAuB;;AAEvB,YAAIkN,oBAAJ,EAA0B;AACxB,cAAI5K,IAAI,CAACoH,UAAL,CAAgB,SAAhB,CAAJ,EAAgC;AAC9B;AACA,iBAAKhE,cAAL,CAAoByH,uBAAuB,CAACY,WAAxB,EAApB,IAA6DX,mBAA7D,CAF8B,CAEoD;;AAElFD,YAAAA,uBAAuB,GAAG7K,IAAI,CAACY,SAAL,CAAe,CAAf,CAA1B;AACAkK,YAAAA,mBAAmB,GAAG,EAAtB;AACD,WAND,MAMO;AACLA,YAAAA,mBAAmB,IAAI9K,IAAI,GAAG,IAA9B;AACD;;AAED;AACD;;AAED,YAAIsL,EAAE,GAAG,IAAIvL,UAAJ,CAAeC,IAAf,EAAqB2K,SAAS,GAAG,CAAjC,CAAT;AACAW,QAAAA,EAAE,CAAC/K,YAAH;;AAEA,YAAI+K,EAAE,CAACxK,UAAH,EAAJ,EAAqB;AACnB;AACA;AACD,SAxBoD,CAwBnD;;;AAGF,YAAI4K,QAAQ,GAAGJ,EAAE,CAAC7K,QAAH,EAAf;;AAEA,gBAAQiL,QAAR;AACE;AACA,eAAK,GAAL;AACE;AACA,gBAAIC,IAAI,GAAGL,EAAE,CAAC7K,QAAH,EAAX;;AAEA,gBAAIkL,IAAJ,EAAU;AACR,sBAAQA,IAAR;AACE,qBAAK,YAAL;AACE9L,kBAAAA,IAAI,GAAGyL,EAAE,CAAC7K,QAAH,EAAP;AACA4J,kBAAAA,iBAAiB,CAAC5N,SAAlB,GAA8B,EAA9B;AACA4N,kBAAAA,iBAAiB,CAAC3N,YAAlB,GAAiC,EAAjC;AACA2N,kBAAAA,iBAAiB,CAACvD,mBAAlB,GAAwC,EAAxC;AACAuD,kBAAAA,iBAAiB,CAACxK,IAAlB,GAAyBA,IAAzB;AACA,sBAAI+L,MAAM,GAAG,CAACxB,gBAAgB,CAAC1E,WAA/B;;AAEA,sBAAIkG,MAAM,IAAI/G,KAAK,CAACrB,eAAN,IAAyB,CAAC5D,eAAe,CAACC,IAAD,CAAvD,EAA+D;AAC7DwK,oBAAAA,iBAAiB,CAACwB,WAAlB,GAAgC,IAAIhQ,KAAJ,EAAhC;AACAwO,oBAAAA,iBAAiB,CAACwB,WAAlB,CAA8B/F,QAA9B,CAAuCiB,wBAAvC,GAAkEsD,iBAAiB,CAACtD,wBAApF;AACD,mBAXH,CAWI;AACF;;;AAGA,sBAAIF,MAAM,GAAGwD,iBAAiB,CAACxD,MAA/B;;AAEA,sBAAIA,MAAM,CAACiF,WAAP,KAAuB,CAAvB,KAA6BjH,KAAK,CAACrB,eAAN,IAAyB5D,eAAe,CAACC,IAAD,CAAxC,IAAkD,CAACgF,KAAK,CAACrB,eAAtF,CAAJ,EAA4G;AAC1G6G,oBAAAA,iBAAiB,CAAC/D,QAAlB,GAA6B,CAAC+D,iBAAiB,CAAC/D,QAAhD;AACD;;AAED7J,kBAAAA,SAAS,GAAG4N,iBAAiB,CAAC5N,SAA9B;AACAC,kBAAAA,YAAY,GAAG2N,iBAAiB,CAAC3N,YAAjC;AACAoK,kBAAAA,mBAAmB,GAAGuD,iBAAiB,CAACvD,mBAAxC;AACA;;AAEF,qBAAK,SAAL;AACE,sBAAI1E,QAAQ,GAAG,KAAKmB,wBAAL,CAA8B+H,EAA9B,CAAf;;AAEA,sBAAIlJ,QAAJ,EAAc;AACZ,yBAAK8E,WAAL,CAAiB9E,QAAjB;AACD,mBAFD,MAEO;AACL2J,oBAAAA,OAAO,CAACC,IAAR,CAAa,wCAAwCV,EAAE,CAACtK,mBAAH,EAArD;AACD;;AAED;;AAEF,qBAAK,WAAL;AACEuF,kBAAAA,QAAQ,GAAG+E,EAAE,CAAC7K,QAAH,EAAX;AACA;;AAEF,qBAAK,WAAL;AACE,sBAAIwL,WAAW,GAAGX,EAAE,CAACzK,kBAAH,GAAwB4J,KAAxB,CAA8B,GAA9B,CAAlB;;AAEA,sBAAIwB,WAAW,CAACvO,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,wBAAI,CAAC8I,QAAL,EAAe;AACbA,sBAAAA,QAAQ,GAAG,EAAX;AACD;;AAEDyF,oBAAAA,WAAW,CAACC,OAAZ,CAAoB,UAAUC,OAAV,EAAmB;AACrC3F,sBAAAA,QAAQ,CAAC7H,IAAT,CAAcwN,OAAO,CAACC,IAAR,EAAd;AACD,qBAFD;AAGD;;AAED;;AAEF,qBAAK,MAAL;AACE,sBAAIzB,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACAC,oBAAAA,oBAAoB,GAAG,IAAvB;AACAC,oBAAAA,uBAAuB,GAAGS,EAAE,CAACzK,kBAAH,EAA1B;AACAiK,oBAAAA,mBAAmB,GAAG,EAAtB;AACAC,oBAAAA,YAAY,GAAG,KAAf;AACAC,oBAAAA,MAAM,GAAG,IAAT;AACD;;AAED;;AAEF,qBAAK,KAAL;AACE;AACA,yBAAO,CAACM,EAAE,CAACxK,UAAH,EAAR,EAAyB;AACvB,wBAAIkH,KAAK,GAAGsD,EAAE,CAAC7K,QAAH,EAAZ;;AAEA,4BAAQuH,KAAR;AACE,2BAAK,SAAL;AACA,2BAAK,WAAL;AACE+C,wBAAAA,YAAY,GAAG/C,KAAK,KAAK,SAAzB;AACAgD,wBAAAA,MAAM,GAAG,IAAT;AACA;;AAEF,2BAAK,IAAL;AACA,2BAAK,KAAL;AACEA,wBAAAA,MAAM,GAAGhD,KAAK,KAAK,KAAnB;AACA;;AAEF,2BAAK,YAAL;AACEiD,wBAAAA,WAAW,GAAG,IAAd;AACA;;AAEF,2BAAK,MAAL;AACA,2BAAK,QAAL;AACEC,wBAAAA,OAAO,GAAGlD,KAAK,KAAK,MAApB;AACA;;AAEF;AACE+D,wBAAAA,OAAO,CAACC,IAAR,CAAa,uCAAuChE,KAAvC,GAA+C,eAA5D;AACA;AAvBJ;AAyBD;;AAED;;AAEF,qBAAK,MAAL;AACEjB,kBAAAA,wBAAwB,GAAG,IAA3B;AACA;AAzGJ;AA2GD;;AAED;AACF;;AAEA,eAAK,GAAL;AACE,gBAAI3E,QAAQ,GAAG+I,eAAe,CAACG,EAAD,CAA9B;AACA,gBAAIe,IAAI,GAAGd,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAArB;AACA,gBAAI6L,IAAI,GAAGf,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAArB;AACA,gBAAI8L,IAAI,GAAGhB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAArB;AACA,gBAAI+L,EAAE,GAAGjB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIgM,EAAE,GAAGlB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIiM,EAAE,GAAGnB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIkM,EAAE,GAAGpB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAImM,EAAE,GAAGrB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIoM,EAAE,GAAGtB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIqM,EAAE,GAAGvB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIsM,EAAE,GAAGxB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIuM,EAAE,GAAGzB,UAAU,CAACD,EAAE,CAAC7K,QAAH,EAAD,CAAnB;AACA,gBAAIoG,MAAM,GAAG,IAAIxL,OAAJ,GAAcoO,GAAd,CAAkB+C,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BL,IAA9B,EAAoCM,EAApC,EAAwCC,EAAxC,EAA4CC,EAA5C,EAAgDP,IAAhD,EAAsDQ,EAAtD,EAA0DC,EAA1D,EAA8DC,EAA9D,EAAkET,IAAlE,EAAwE,CAAxE,EAA2E,CAA3E,EAA8E,CAA9E,EAAiF,CAAjF,CAAb;AACA,gBAAIU,QAAQ,GAAG3B,EAAE,CAACzK,kBAAH,GAAwBuL,IAAxB,GAA+B7B,OAA/B,CAAuC,KAAvC,EAA8C,GAA9C,CAAf;;AAEA,gBAAI1F,KAAK,CAACxB,OAAN,CAAc4J,QAAd,CAAJ,EAA6B;AAC3B;AACAA,cAAAA,QAAQ,GAAGpI,KAAK,CAACxB,OAAN,CAAc4J,QAAd,CAAX;AACD,aAHD,MAGO;AACL;AACA,kBAAIA,QAAQ,CAAC7F,UAAT,CAAoB,IAApB,CAAJ,EAA+B;AAC7B6F,gBAAAA,QAAQ,GAAG,WAAWA,QAAtB;AACD,eAFD,MAEO,IAAIA,QAAQ,CAAC7F,UAAT,CAAoB,KAApB,CAAJ,EAAgC;AACrC6F,gBAAAA,QAAQ,GAAG,OAAOA,QAAlB;AACD;AACF;;AAED9G,YAAAA,UAAU,CAACxH,IAAX,CAAgB;AACdyD,cAAAA,QAAQ,EAAEA,QADI;AAEdyE,cAAAA,MAAM,EAAEA,MAFM;AAGdoG,cAAAA,QAAQ,EAAEA,QAHI;AAIdC,cAAAA,gBAAgB,EAAED,QAJJ;AAKdE,cAAAA,aAAa,EAAEhR,WAAW,CAAC4H,mBALb;AAMdU,cAAAA,GAAG,EAAE,IANS;AAOd2I,cAAAA,cAAc,EAAE,KAPF;AAQd9G,cAAAA,QAAQ,EAAE2E,WAAW,KAAKZ,iBAAiB,CAAC/D,QAR9B;AASdS,cAAAA,wBAAwB,EAAEA;AATZ,aAAhB;AAWAkE,YAAAA,WAAW,GAAG,KAAd;AACA;AACF;;AAEA,eAAK,GAAL;AACE,gBAAI7I,QAAQ,GAAG+I,eAAe,CAACG,EAAD,EAAK,IAAL,CAA9B;AACA,gBAAI+B,OAAO,GAAG;AACZjL,cAAAA,QAAQ,EAAEA,QAAQ,CAAC0D,QAAT,CAAkBgC,YADhB;AAEZ1G,cAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFlB;AAGZ9I,cAAAA,EAAE,EAAEoO,WAAW,CAACC,EAAD,CAHH;AAIZpO,cAAAA,EAAE,EAAEmO,WAAW,CAACC,EAAD;AAJH,aAAd;AAMA5O,YAAAA,YAAY,CAACiC,IAAb,CAAkB0O,OAAlB;AACA;AACF;;AAEA,eAAK,GAAL;AACE,gBAAIjL,QAAQ,GAAG+I,eAAe,CAACG,EAAD,EAAK,IAAL,CAA9B;AACA,gBAAI+B,OAAO,GAAG;AACZjL,cAAAA,QAAQ,EAAEA,QAAQ,CAAC0D,QAAT,CAAkBgC,YAAlB,CAA+BhC,QAA/B,CAAwC6D,uBADtC;AAEZvI,cAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFlB;AAGZ9I,cAAAA,EAAE,EAAEoO,WAAW,CAACC,EAAD,CAHH;AAIZpO,cAAAA,EAAE,EAAEmO,WAAW,CAACC,EAAD,CAJH;AAKZvI,cAAAA,EAAE,EAAEsI,WAAW,CAACC,EAAD,CALH;AAMZtI,cAAAA,EAAE,EAAEqI,WAAW,CAACC,EAAD;AANH,aAAd;AAQAxE,YAAAA,mBAAmB,CAACnI,IAApB,CAAyB0O,OAAzB;AACA;AACF;;AAEA,eAAK,GAAL;AACE,gBAAIjL,QAAQ,GAAG+I,eAAe,CAACG,EAAD,CAA9B;AACA,gBAAIhF,QAAQ,GAAG+D,iBAAiB,CAAC/D,QAAjC;AACA,gBAAIgH,GAAG,GAAGtC,MAAM,KAAK1E,QAArB;AACA,gBAAIiH,WAAW,GAAG,CAACxC,YAAD,IAAiB,CAACG,OAApC;AACA,gBAAIjO,EAAJ,EAAQC,EAAR,EAAYiF,EAAZ,EAAgB3D,UAAhB;;AAEA,gBAAI8O,GAAG,KAAK,IAAZ,EAAkB;AAChBrQ,cAAAA,EAAE,GAAGoO,WAAW,CAACC,EAAD,CAAhB;AACApO,cAAAA,EAAE,GAAGmO,WAAW,CAACC,EAAD,CAAhB;AACAnJ,cAAAA,EAAE,GAAGkJ,WAAW,CAACC,EAAD,CAAhB;AACD,aAJD,MAIO;AACLnJ,cAAAA,EAAE,GAAGkJ,WAAW,CAACC,EAAD,CAAhB;AACApO,cAAAA,EAAE,GAAGmO,WAAW,CAACC,EAAD,CAAhB;AACArO,cAAAA,EAAE,GAAGoO,WAAW,CAACC,EAAD,CAAhB;AACD;;AAEDhP,YAAAA,QAAQ,CAACkR,UAAT,CAAoBtQ,EAApB,EAAwBD,EAAxB;AACAV,YAAAA,QAAQ,CAACiR,UAAT,CAAoBrL,EAApB,EAAwBjF,EAAxB;AACAsB,YAAAA,UAAU,GAAG,IAAItD,OAAJ,GAAcuS,YAAd,CAA2BnR,QAA3B,EAAqCC,QAArC,EAA+CoD,SAA/C,EAAb;AACAlD,YAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,cAAAA,QAAQ,EAAEA,QADG;AAEbhB,cAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,cAAAA,EAAE,EAAEA,EAHS;AAIbC,cAAAA,EAAE,EAAEA,EAJS;AAKbiF,cAAAA,EAAE,EAAEA,EALS;AAMb3D,cAAAA,UAAU,EAAEA,UANC;AAObC,cAAAA,EAAE,EAAE,IAPS;AAQbG,cAAAA,EAAE,EAAE,IARS;AASbC,cAAAA,EAAE,EAAE;AATS,aAAf;;AAYA,gBAAI0O,WAAW,KAAK,IAApB,EAA0B;AACxB9Q,cAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,gBAAAA,QAAQ,EAAEA,QADG;AAEbhB,gBAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,gBAAAA,EAAE,EAAEA,EAHS;AAIbC,gBAAAA,EAAE,EAAEiF,EAJS;AAKbA,gBAAAA,EAAE,EAAEjF,EALS;AAMbsB,gBAAAA,UAAU,EAAEA,UANC;AAObC,gBAAAA,EAAE,EAAE,IAPS;AAQbG,gBAAAA,EAAE,EAAE,IARS;AASbC,gBAAAA,EAAE,EAAE;AATS,eAAf;AAWD;;AAED;AACF;;AAEA,eAAK,GAAL;AACE,gBAAIuD,QAAQ,GAAG+I,eAAe,CAACG,EAAD,CAA9B;AACA,gBAAIhF,QAAQ,GAAG+D,iBAAiB,CAAC/D,QAAjC;AACA,gBAAIgH,GAAG,GAAGtC,MAAM,KAAK1E,QAArB;AACA,gBAAIiH,WAAW,GAAG,CAACxC,YAAD,IAAiB,CAACG,OAApC;AACA,gBAAIjO,EAAJ,EAAQC,EAAR,EAAYiF,EAAZ,EAAgBuL,EAAhB,EAAoBlP,UAApB;;AAEA,gBAAI8O,GAAG,KAAK,IAAZ,EAAkB;AAChBrQ,cAAAA,EAAE,GAAGoO,WAAW,CAACC,EAAD,CAAhB;AACApO,cAAAA,EAAE,GAAGmO,WAAW,CAACC,EAAD,CAAhB;AACAnJ,cAAAA,EAAE,GAAGkJ,WAAW,CAACC,EAAD,CAAhB;AACAoC,cAAAA,EAAE,GAAGrC,WAAW,CAACC,EAAD,CAAhB;AACD,aALD,MAKO;AACLoC,cAAAA,EAAE,GAAGrC,WAAW,CAACC,EAAD,CAAhB;AACAnJ,cAAAA,EAAE,GAAGkJ,WAAW,CAACC,EAAD,CAAhB;AACApO,cAAAA,EAAE,GAAGmO,WAAW,CAACC,EAAD,CAAhB;AACArO,cAAAA,EAAE,GAAGoO,WAAW,CAACC,EAAD,CAAhB;AACD;;AAEDhP,YAAAA,QAAQ,CAACkR,UAAT,CAAoBtQ,EAApB,EAAwBD,EAAxB;AACAV,YAAAA,QAAQ,CAACiR,UAAT,CAAoBrL,EAApB,EAAwBjF,EAAxB;AACAsB,YAAAA,UAAU,GAAG,IAAItD,OAAJ,GAAcuS,YAAd,CAA2BnR,QAA3B,EAAqCC,QAArC,EAA+CoD,SAA/C,EAAb;AACAlD,YAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,cAAAA,QAAQ,EAAEA,QADG;AAEbhB,cAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,cAAAA,EAAE,EAAEA,EAHS;AAIbC,cAAAA,EAAE,EAAEA,EAJS;AAKbiF,cAAAA,EAAE,EAAEA,EALS;AAMb3D,cAAAA,UAAU,EAAEA,UANC;AAObC,cAAAA,EAAE,EAAE,IAPS;AAQbG,cAAAA,EAAE,EAAE,IARS;AASbC,cAAAA,EAAE,EAAE;AATS,aAAf;AAWApC,YAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,cAAAA,QAAQ,EAAEA,QADG;AAEbhB,cAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,cAAAA,EAAE,EAAEA,EAHS;AAIbC,cAAAA,EAAE,EAAEiF,EAJS;AAKbA,cAAAA,EAAE,EAAEuL,EALS;AAMblP,cAAAA,UAAU,EAAEA,UANC;AAObC,cAAAA,EAAE,EAAE,IAPS;AAQbG,cAAAA,EAAE,EAAE,IARS;AASbC,cAAAA,EAAE,EAAE;AATS,aAAf;;AAYA,gBAAI0O,WAAW,KAAK,IAApB,EAA0B;AACxB9Q,cAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,gBAAAA,QAAQ,EAAEA,QADG;AAEbhB,gBAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,gBAAAA,EAAE,EAAEA,EAHS;AAIbC,gBAAAA,EAAE,EAAEiF,EAJS;AAKbA,gBAAAA,EAAE,EAAEjF,EALS;AAMbsB,gBAAAA,UAAU,EAAEA,UANC;AAObC,gBAAAA,EAAE,EAAE,IAPS;AAQbG,gBAAAA,EAAE,EAAE,IARS;AASbC,gBAAAA,EAAE,EAAE;AATS,eAAf;AAWApC,cAAAA,SAAS,CAACkC,IAAV,CAAe;AACbyD,gBAAAA,QAAQ,EAAEA,QADG;AAEbhB,gBAAAA,UAAU,EAAEgB,QAAQ,CAAC0D,QAAT,CAAkBC,IAFjB;AAGb9I,gBAAAA,EAAE,EAAEA,EAHS;AAIbC,gBAAAA,EAAE,EAAEwQ,EAJS;AAKbvL,gBAAAA,EAAE,EAAEA,EALS;AAMb3D,gBAAAA,UAAU,EAAEA,UANC;AAObC,gBAAAA,EAAE,EAAE,IAPS;AAQbG,gBAAAA,EAAE,EAAE,IARS;AASbC,gBAAAA,EAAE,EAAE;AATS,eAAf;AAWD;;AAED;;AAEF;AACE,kBAAM,qCAAqC6M,QAArC,GAAgD,GAAhD,GAAsDJ,EAAE,CAACtK,mBAAH,EAAtD,GAAiF,GAAvF;AAvTJ;AAyTD;;AAED,UAAI4J,oBAAJ,EAA0B;AACxB,aAAKxH,cAAL,CAAoByH,uBAAuB,CAACY,WAAxB,EAApB,IAA6DX,mBAA7D;AACD;;AAEDT,MAAAA,iBAAiB,CAAC9D,QAAlB,GAA6BA,QAA7B;AACA8D,MAAAA,iBAAiB,CAAC7D,QAAlB,GAA6BA,QAA7B;AACA6D,MAAAA,iBAAiB,CAAClE,UAAlB,GAA+BA,UAA/B;AACAkE,MAAAA,iBAAiB,CAACjE,aAAlB,GAAkCD,UAAU,CAACzI,MAA7C;AACA2M,MAAAA,iBAAiB,CAAChE,cAAlB,GAAmC,CAAnC;AACD,KAvwBoE;AAwwBrEsH,IAAAA,wBAAwB,EAAE,kCAAUC,KAAV,EAAiB;AACzC;AACA,UAAIC,UAAU,GAAG,CAAjB;AACAD,MAAAA,KAAK,CAACE,QAAN,CAAe,UAAAC,CAAC,EAAI;AAClB,YAAIA,CAAC,CAACC,OAAN,EAAe;AACb,cAAID,CAAC,CAACjI,QAAF,CAAWiB,wBAAf,EAAyC;AACvC8G,YAAAA,UAAU;AACX;;AAEDE,UAAAA,CAAC,CAACjI,QAAF,CAAWmI,gBAAX,GAA8BJ,UAA9B;AACD;AACF,OARD;AASAD,MAAAA,KAAK,CAAC9H,QAAN,CAAeoI,oBAAf,GAAsCL,UAAU,GAAG,CAAnD;AACD,KArxBoE;AAsxBrEvI,IAAAA,aAAa,EAAE,uBAAUD,IAAV,EAAgB8I,WAAhB,EAA6BC,SAA7B,EAAwC3J,GAAxC,EAA6C;AAC1D,UAAII,KAAK,GAAG,IAAZ;AACA,UAAIwJ,UAAU,GAAGxJ,KAAK,CAACW,kBAAN,EAAjB;AACA6I,MAAAA,UAAU,CAAC5J,GAAX,GAAiBA,GAAjB;AACA,UAAI2F,gBAAgB,GAAGvF,KAAK,CAACyC,mBAAN,EAAvB,CAJ0D,CAIN;;AAEpD,UAAI8G,SAAJ,EAAe;AACbC,QAAAA,UAAU,CAACzH,aAAX,CAAyB0H,gBAAzB,CAA0ClE,gBAAgB,CAACxD,aAA3D,EAA0EwH,SAAS,CAACvH,MAApF;AACAwH,QAAAA,UAAU,CAACxH,MAAX,CAAkB0H,IAAlB,CAAuBH,SAAS,CAACvH,MAAjC;AACAwH,QAAAA,UAAU,CAAC/H,QAAX,GAAsB8H,SAAS,CAAC9H,QAAhC;AACA+H,QAAAA,UAAU,CAACtH,wBAAX,GAAsCqH,SAAS,CAACrH,wBAAhD;AACD,OAXyD,CAWxD;;;AAGF,UAAIN,eAAe,GAAG2D,gBAAgB,CAAC3D,eAAvC;;AAEA,UAAIA,eAAe,KAAK,IAAxB,EAA8B;AAC5BA,QAAAA,eAAe,GAAG2D,gBAAgB,CAAC3D,eAAjB,CAAiCgF,WAAjC,EAAlB;AACD;;AAED,UAAI5G,KAAK,CAACzB,cAAN,CAAqBqD,eAArB,MAA0C+H,SAA9C,EAAyD;AACvD3J,QAAAA,KAAK,CAACzB,cAAN,CAAqBqD,eAArB,IAAwCpB,IAAxC;AACD,OAtByD,CAsBxD;;;AAGFR,MAAAA,KAAK,CAACsF,WAAN,CAAkB9E,IAAlB;AACA,UAAIoJ,aAAa,GAAG,CAApB;AACAC,MAAAA,iBAAiB;;AAEjB,eAASA,iBAAT,GAA6B;AAC3BD,QAAAA,aAAa;;AAEb,YAAIA,aAAa,KAAKJ,UAAU,CAAClI,UAAX,CAAsBzI,MAAtB,GAA+B,CAArD,EAAwD;AACtDiR,UAAAA,cAAc;AACf,SAFD,MAEO;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAIP,SAAS,GAAGC,UAAU,CAAClI,UAAX,CAAsBkI,UAAU,CAAChI,cAAjC,CAAhB;AACAuI,UAAAA,OAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB,YAAY;AACjCC,YAAAA,aAAa,CAACX,SAAD,CAAb;AACD,WAFD;AAGAC,UAAAA,UAAU,CAAChI,cAAX;AACD;AACF;;AAED,eAASsI,cAAT,GAA0B;AACxB,YAAI9J,KAAK,CAACrI,aAAN,IAAuB6R,UAAU,CAACxO,IAAX,KAAoB,MAA/C,EAAuD;AACrDrD,UAAAA,aAAa,CAAC6R,UAAU,CAAC5R,SAAZ,EAAuB4R,UAAU,CAAC3R,YAAlC,CAAb;AACD;;AAED,YAAIkP,MAAM,GAAG,CAACxB,gBAAgB,CAAC1E,WAA/B;;AAEA,YAAIb,KAAK,CAACrB,eAAN,IAAyB,CAAC5D,eAAe,CAACyO,UAAU,CAACxO,IAAZ,CAAzC,IAA8D+L,MAAlE,EAA0E;AACxE,cAAMoD,QAAQ,GAAGX,UAAU,CAACxC,WAA5B;;AAEA,cAAIwC,UAAU,CAAC5R,SAAX,CAAqBiB,MAArB,GAA8B,CAAlC,EAAqC;AACnCsR,YAAAA,QAAQ,CAACpR,GAAT,CAAayD,YAAY,CAACgN,UAAU,CAAC5R,SAAZ,EAAuB,CAAvB,CAAzB;AACD;;AAED,cAAI4R,UAAU,CAAC3R,YAAX,CAAwBgB,MAAxB,GAAiC,CAArC,EAAwC;AACtCsR,YAAAA,QAAQ,CAACpR,GAAT,CAAayD,YAAY,CAACgN,UAAU,CAAC3R,YAAZ,EAA0B,CAA1B,CAAzB;AACD;;AAED,cAAI2R,UAAU,CAACvH,mBAAX,CAA+BpJ,MAA/B,GAAwC,CAA5C,EAA+C;AAC7CsR,YAAAA,QAAQ,CAACpR,GAAT,CAAayD,YAAY,CAACgN,UAAU,CAACvH,mBAAZ,EAAiC,CAAjC,EAAoC,IAApC,CAAzB;AACD;;AAED,cAAIsD,gBAAgB,CAACyB,WAArB,EAAkC;AAChCmD,YAAAA,QAAQ,CAACjH,IAAT,GAAgBsG,UAAU,CAACpB,QAA3B;AACA+B,YAAAA,QAAQ,CAAClJ,QAAT,CAAkBS,QAAlB,GAA6B8H,UAAU,CAAC9H,QAAxC;AACAyI,YAAAA,QAAQ,CAAClJ,QAAT,CAAkBU,QAAlB,GAA6B6H,UAAU,CAAC7H,QAAxC;AACA6H,YAAAA,UAAU,CAACxH,MAAX,CAAkBoI,SAAlB,CAA4BD,QAAQ,CAACE,QAArC,EAA+CF,QAAQ,CAACG,UAAxD,EAAoEH,QAAQ,CAACI,KAA7E;AACAhF,YAAAA,gBAAgB,CAACyB,WAAjB,CAA6BjO,GAA7B,CAAiCoR,QAAjC;AACD;AACF,SAtBD,MAsBO;AACL,cAAIxL,eAAe,GAAGqB,KAAK,CAACrB,eAA5B;AACA,cAAI6L,kBAAkB,GAAGjF,gBAAgB,CAAC1N,YAA1C;AACA,cAAI4S,yBAAyB,GAAGlF,gBAAgB,CAACtD,mBAAjD;AACA,cAAIyI,eAAe,GAAGnF,gBAAgB,CAAC3N,SAAvC;AACA,cAAIC,YAAY,GAAG2R,UAAU,CAAC3R,YAA9B;AACA,cAAIoK,mBAAmB,GAAGuH,UAAU,CAACvH,mBAArC;AACA,cAAIrK,SAAS,GAAG4R,UAAU,CAAC5R,SAA3B;;AAEA,eAAK,IAAIe,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,YAAY,CAACgB,MAAjC,EAAyCF,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACnD,gBAAIG,EAAE,GAAGjB,YAAY,CAACc,CAAD,CAArB;;AAEA,gBAAIgG,eAAJ,EAAqB;AACnB7F,cAAAA,EAAE,CAACV,EAAH,CAAMuO,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACAlJ,cAAAA,EAAE,CAACT,EAAH,CAAMsO,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACD;;AAEDwI,YAAAA,kBAAkB,CAAC1Q,IAAnB,CAAwBhB,EAAxB;AACD;;AAED,eAAK,IAAIH,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGqJ,mBAAmB,CAACpJ,MAAxC,EAAgDF,GAAC,GAAGC,GAApD,EAAuDD,GAAC,EAAxD,EAA4D;AAC1D,gBAAIsF,EAAE,GAAGgE,mBAAmB,CAACtJ,GAAD,CAA5B;;AAEA,gBAAIgG,eAAJ,EAAqB;AACnBV,cAAAA,EAAE,CAAC7F,EAAH,CAAMuO,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACA/D,cAAAA,EAAE,CAAC5F,EAAH,CAAMsO,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACA/D,cAAAA,EAAE,CAACC,EAAH,CAAMyI,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACA/D,cAAAA,EAAE,CAACE,EAAH,CAAMwI,YAAN,CAAmB6C,UAAU,CAACxH,MAA9B;AACD;;AAEDyI,YAAAA,yBAAyB,CAAC3Q,IAA1B,CAA+BmE,EAA/B;AACD;;AAED,eAAK,IAAItF,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGhB,SAAS,CAACiB,MAA9B,EAAsCF,GAAC,GAAGC,GAA1C,EAA6CD,GAAC,EAA9C,EAAkD;AAChD,gBAAIK,GAAG,GAAGpB,SAAS,CAACe,GAAD,CAAnB;;AAEA,gBAAIgG,eAAJ,EAAqB;AACnB3F,cAAAA,GAAG,CAACZ,EAAJ,GAASY,GAAG,CAACZ,EAAJ,CAAOyB,KAAP,GAAe8M,YAAf,CAA4B6C,UAAU,CAACxH,MAAvC,CAAT;AACAhJ,cAAAA,GAAG,CAACX,EAAJ,GAASW,GAAG,CAACX,EAAJ,CAAOwB,KAAP,GAAe8M,YAAf,CAA4B6C,UAAU,CAACxH,MAAvC,CAAT;AACAhJ,cAAAA,GAAG,CAACsE,EAAJ,GAAStE,GAAG,CAACsE,EAAJ,CAAOzD,KAAP,GAAe8M,YAAf,CAA4B6C,UAAU,CAACxH,MAAvC,CAAT;AACAvK,cAAAA,QAAQ,CAACkR,UAAT,CAAoB3P,GAAG,CAACX,EAAxB,EAA4BW,GAAG,CAACZ,EAAhC;AACAV,cAAAA,QAAQ,CAACiR,UAAT,CAAoB3P,GAAG,CAACsE,EAAxB,EAA4BtE,GAAG,CAACX,EAAhC;AACAW,cAAAA,GAAG,CAACW,UAAJ,CAAeiP,YAAf,CAA4BnR,QAA5B,EAAsCC,QAAtC,EAAgDoD,SAAhD;AACD;;AAED4P,YAAAA,eAAe,CAAC5Q,IAAhB,CAAqBd,GAArB;AACD;AACF;;AAEDgH,QAAAA,KAAK,CAACmC,gBAAN,GA9EwB,CA8EE;;AAE1B,YAAI,CAACoD,gBAAgB,CAAC1E,WAAtB,EAAmC;AACjCb,UAAAA,KAAK,CAAC8I,wBAAN,CAA+BU,UAAU,CAACxC,WAA1C;AACD;;AAED,YAAIsC,WAAJ,EAAiB;AACfA,UAAAA,WAAW,CAACE,UAAU,CAACxC,WAAZ,CAAX;AACD;AACF;;AAED,eAASkD,aAAT,CAAuBX,SAAvB,EAAkC;AAChCC,QAAAA,UAAU,CAAC3H,cAAX,GAA4B0H,SAAS,CAAChM,QAAV,CAAmB0D,QAAnB,CAA4BC,IAAxD;AACAsI,QAAAA,UAAU,CAAC1H,kBAAX,GAAgCyH,SAAS,CAAChM,QAAV,CAAmB0D,QAAnB,CAA4BgC,YAA5B,CAAyChC,QAAzC,CAAkDC,IAAlF;AACAsI,QAAAA,UAAU,CAAC5H,eAAX,GAA6B2H,SAAS,CAAClB,gBAAvC,CAHgC,CAGyB;;AAEzD,YAAIsC,MAAM,GAAG3K,KAAK,CAACzB,cAAN,CAAqBgL,SAAS,CAAClB,gBAAV,CAA2BzB,WAA3B,EAArB,CAAb;;AAEA,YAAI+D,MAAJ,EAAY;AACV3K,UAAAA,KAAK,CAACS,aAAN,CAAoBkK,MAApB,EAA4B,UAAUC,cAAV,EAA0B;AACpDC,YAAAA,iBAAiB,CAACD,cAAD,EAAiBrB,SAAjB,CAAjB;AACAM,YAAAA,iBAAiB;AAClB,WAHD,EAGGN,SAHH,EAGc3J,GAHd;AAIA;AACD,SAb+B,CAa9B;AACF;;;AAGA,YAAIkL,YAAY,GAAGvB,SAAS,CAACnB,QAA7B;AACA,YAAI2C,gBAAgB,GAAGzT,WAAW,CAACkI,uBAAnC;;AAEA,gBAAQ+J,SAAS,CAACjB,aAAlB;AACE,eAAKhR,WAAW,CAAC4H,mBAAjB;AACE6L,YAAAA,gBAAgB,GAAGxB,SAAS,CAACjB,aAAV,GAA0B,CAA7C;AACA;;AAEF,eAAKhR,WAAW,CAAC6H,uBAAjB;AACE2L,YAAAA,YAAY,GAAG,WAAWA,YAA1B;AACAC,YAAAA,gBAAgB,GAAGxB,SAAS,CAACjB,aAAV,GAA0B,CAA7C;AACA;;AAEF,eAAKhR,WAAW,CAAC8H,mBAAjB;AACE0L,YAAAA,YAAY,GAAG,OAAOA,YAAtB;AACAC,YAAAA,gBAAgB,GAAGxB,SAAS,CAACjB,aAAV,GAA0B,CAA7C;AACA;;AAEF,eAAKhR,WAAW,CAAC+H,wBAAjB;AACEyL,YAAAA,YAAY,GAAG,YAAYA,YAA3B;AACAC,YAAAA,gBAAgB,GAAGxB,SAAS,CAACjB,aAAV,GAA0B,CAA7C;AACA;;AAEF,eAAKhR,WAAW,CAACgI,0BAAjB;AACEwL,YAAAA,YAAY,GAAGlL,GAAG,CAAC7D,SAAJ,CAAc,CAAd,EAAiB6D,GAAG,CAACoL,WAAJ,CAAgB,GAAhB,IAAuB,CAAxC,IAA6CF,YAA5D;AACAC,YAAAA,gBAAgB,GAAGxB,SAAS,CAACjB,aAAV,GAA0B,CAA7C;AACA;;AAEF,eAAKhR,WAAW,CAACiI,0BAAjB;AACE,gBAAIgK,SAAS,CAAChB,cAAd,EAA8B;AAC5B;AACAwC,cAAAA,gBAAgB,GAAGzT,WAAW,CAACkI,uBAA/B;AACD,aAHD,MAGO;AACL;AACA+J,cAAAA,SAAS,CAACnB,QAAV,GAAqBmB,SAAS,CAACnB,QAAV,CAAmBxB,WAAnB,EAArB;AACAkE,cAAAA,YAAY,GAAGvB,SAAS,CAACnB,QAAzB;AACAmB,cAAAA,SAAS,CAAChB,cAAV,GAA2B,IAA3B;AACAwC,cAAAA,gBAAgB,GAAGzT,WAAW,CAAC4H,mBAA/B;AACD;;AAED;;AAEF,eAAK5H,WAAW,CAACkI,uBAAjB;AACE;AACA0H,YAAAA,OAAO,CAACC,IAAR,CAAa,6BAA6BoC,SAAS,CAAClB,gBAAvC,GAA0D,uBAAvE;AACA;AA1CJ;;AA6CAkB,QAAAA,SAAS,CAACjB,aAAV,GAA0ByC,gBAA1B;AACAxB,QAAAA,SAAS,CAAC3J,GAAV,GAAgBkL,YAAhB,CAlEgC,CAkEF;AAC9B;AACA;;AAEA,YAAI7K,UAAU,GAAG,IAAI1J,UAAJ,CAAeyJ,KAAK,CAAC5B,OAArB,CAAjB;AACA6B,QAAAA,UAAU,CAACC,OAAX,CAAmBF,KAAK,CAACG,IAAzB;AACAF,QAAAA,UAAU,CAACG,gBAAX,CAA4BJ,KAAK,CAACK,aAAlC;AACAJ,QAAAA,UAAU,CAACK,kBAAX,CAA8BN,KAAK,CAACO,eAApC;AACAN,QAAAA,UAAU,CAACN,IAAX,CAAgBmL,YAAhB,EAA8B,UAAUtK,IAAV,EAAgB;AAC5CR,UAAAA,KAAK,CAACS,aAAN,CAAoBD,IAApB,EAA0B,UAAUoK,cAAV,EAA0B;AAClDC,YAAAA,iBAAiB,CAACD,cAAD,EAAiBrB,SAAjB,CAAjB;AACAM,YAAAA,iBAAiB;AAClB,WAHD,EAGGN,SAHH,EAGc3J,GAHd;AAID,SALD,EAKG+J,SALH,EAKc,UAAUsB,GAAV,EAAe;AAC3BC,UAAAA,gBAAgB,CAACD,GAAD,EAAM1B,SAAN,CAAhB;AACD,SAPD,EAOGA,SAPH;AAQD;;AAED,eAASsB,iBAAT,CAA2BD,cAA3B,EAA2CrB,SAA3C,EAAsD;AACpD,YAAIqB,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACAV,UAAAA,aAAa,CAACX,SAAD,CAAb;AACA;AACD;;AAEDvJ,QAAAA,KAAK,CAACxB,OAAN,CAAc+K,SAAS,CAAClB,gBAAxB,IAA4CkB,SAAS,CAAC3J,GAAtD;AACD;;AAED,eAASsL,gBAAT,CAA0BD,GAA1B,EAA+B1B,SAA/B,EAA0C;AACxC;AACAW,QAAAA,aAAa,CAACX,SAAD,CAAb;AACD;AACF;AAlgCoE,GAA/C,CAAxB;AAogCA,SAAOjS,WAAP;AACD,CA37CiB,EAAlB;;AA67CA,SAASA,WAAT","sourcesContent":["import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\nvar LDrawLoader = function () {\n  var conditionalLineVertShader =\n  /* glsl */\n  `\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\n  var conditionalLineFragShader =\n  /* glsl */\n  `\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n  var tempVec0 = new Vector3();\n  var tempVec1 = new Vector3();\n\n  function smoothNormals(triangles, lineSegments) {\n    function hashVertex(v) {\n      // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n      // to be smoothed as expected (see minifig arms). The errors between edges\n      // could be due to matrix multiplication.\n      var x = ~~(v.x * 1e2);\n      var y = ~~(v.y * 1e2);\n      var z = ~~(v.z * 1e2);\n      return `${x},${y},${z}`;\n    }\n\n    function hashEdge(v0, v1) {\n      return `${hashVertex(v0)}_${hashVertex(v1)}`;\n    }\n\n    var hardEdges = new Set();\n    var halfEdgeList = {};\n    var fullHalfEdgeList = {};\n    var normals = []; // Save the list of hard edges by hash\n\n    for (let i = 0, l = lineSegments.length; i < l; i++) {\n      var ls = lineSegments[i];\n      var v0 = ls.v0;\n      var v1 = ls.v1;\n      hardEdges.add(hashEdge(v0, v1));\n      hardEdges.add(hashEdge(v1, v0));\n    } // track the half edges associated with each triangle\n\n\n    for (let i = 0, l = triangles.length; i < l; i++) {\n      var tri = triangles[i];\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        var index = i2;\n        var next = (i2 + 1) % 3;\n        var v0 = tri[`v${index}`];\n        var v1 = tri[`v${next}`];\n        var hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n        if (hardEdges.has(hash)) continue;\n        halfEdgeList[hash] = tri;\n        fullHalfEdgeList[hash] = tri;\n      }\n    } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n    // quads provide more \"influence\" to some vertex normals than a triangle due to\n    // the fact that a quad is made up of two triangles and all triangles are weighted\n    // equally. To fix this quads could be tracked separately so their vertex normals\n    // are weighted appropriately or we could try only adding a normal direction\n    // once per normal.\n    // Iterate until we've tried to connect all triangles to share normals\n\n\n    while (true) {\n      // Stop if there are no more triangles left\n      var halfEdges = Object.keys(halfEdgeList);\n      if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n      var i = 0;\n      var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n      while (i < queue.length) {\n        // initialize all vertex normals in this triangle\n        var tri = queue[i];\n        i++;\n        var faceNormal = tri.faceNormal;\n\n        if (tri.n0 === null) {\n          tri.n0 = faceNormal.clone();\n          normals.push(tri.n0);\n        }\n\n        if (tri.n1 === null) {\n          tri.n1 = faceNormal.clone();\n          normals.push(tri.n1);\n        }\n\n        if (tri.n2 === null) {\n          tri.n2 = faceNormal.clone();\n          normals.push(tri.n2);\n        } // Check if any edge is connected to another triangle edge\n\n\n        for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n          var index = i2;\n          var next = (i2 + 1) % 3;\n          var v0 = tri[`v${index}`];\n          var v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n          var hash = hashEdge(v0, v1);\n          delete halfEdgeList[hash];\n          var reverseHash = hashEdge(v1, v0);\n          var otherTri = fullHalfEdgeList[reverseHash];\n\n          if (otherTri) {\n            // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n            // hard edge. There are some cases where the line segments do not line up exactly\n            // with or span multiple triangle edges (see Lunar Vehicle wheels).\n            if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n              continue;\n            } // if this triangle has already been traversed then it won't be in\n            // the halfEdgeList. If it has not then add it to the queue and delete\n            // it so it won't be found again.\n\n\n            if (reverseHash in halfEdgeList) {\n              queue.push(otherTri);\n              delete halfEdgeList[reverseHash];\n            } // Find the matching edge in this triangle and copy the normal vector over\n\n\n            for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n              var otherIndex = i3;\n              var otherNext = (i3 + 1) % 3;\n              var otherV0 = otherTri[`v${otherIndex}`];\n              var otherV1 = otherTri[`v${otherNext}`];\n              var otherHash = hashEdge(otherV0, otherV1);\n\n              if (otherHash === reverseHash) {\n                if (otherTri[`n${otherIndex}`] === null) {\n                  var norm = tri[`n${next}`];\n                  otherTri[`n${otherIndex}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                if (otherTri[`n${otherNext}`] === null) {\n                  var norm = tri[`n${index}`];\n                  otherTri[`n${otherNext}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n    for (let i = 0, l = normals.length; i < l; i++) {\n      normals[i].normalize();\n    }\n  }\n\n  function isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === 'Subpart';\n  }\n\n  function LineParser(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  LineParser.prototype = {\n    constructor: LineParser,\n    seekNonSpace: function () {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    },\n    getToken: function () {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    },\n    getRemainingString: function () {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    },\n    isAtTheEnd: function () {\n      return this.currentCharIndex >= this.lineLength;\n    },\n    setToEnd: function () {\n      this.currentCharIndex = this.lineLength;\n    },\n    getLineNumberString: function () {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  };\n\n  function sortByMaterial(a, b) {\n    if (a.colourCode === b.colourCode) {\n      return 0;\n    }\n\n    if (a.colourCode < b.colourCode) {\n      return -1;\n    }\n\n    return 1;\n  }\n\n  function createObject(elements, elementSize, isConditionalSegments) {\n    // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the triangles or line segments by colour code to make later the mesh groups\n    elements.sort(sortByMaterial);\n    var positions = [];\n    var normals = [];\n    var materials = [];\n    var bufferGeometry = new BufferGeometry();\n    var prevMaterial = null;\n    var index0 = 0;\n    var numGroupVerts = 0;\n\n    for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n      var elem = elements[iElem];\n      var v0 = elem.v0;\n      var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n      positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n      if (elementSize === 3) {\n        positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n        var n0 = elem.n0 || elem.faceNormal;\n        var n1 = elem.n1 || elem.faceNormal;\n        var n2 = elem.n2 || elem.faceNormal;\n        normals.push(n0.x, n0.y, n0.z);\n        normals.push(n1.x, n1.y, n1.z);\n        normals.push(n2.x, n2.y, n2.z);\n      }\n\n      if (prevMaterial !== elem.material) {\n        if (prevMaterial !== null) {\n          bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n        }\n\n        materials.push(elem.material);\n        prevMaterial = elem.material;\n        index0 = iElem * elementSize;\n        numGroupVerts = elementSize;\n      } else {\n        numGroupVerts += elementSize;\n      }\n    }\n\n    if (numGroupVerts > 0) {\n      bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    }\n\n    bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n    if (elementSize === 3) {\n      bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    }\n\n    var object3d = null;\n\n    if (elementSize === 2) {\n      object3d = new LineSegments(bufferGeometry, materials);\n    } else if (elementSize === 3) {\n      object3d = new Mesh(bufferGeometry, materials);\n    }\n\n    if (isConditionalSegments) {\n      object3d.isConditionalLine = true;\n      var controlArray0 = new Float32Array(elements.length * 3 * 2);\n      var controlArray1 = new Float32Array(elements.length * 3 * 2);\n      var directionArray = new Float32Array(elements.length * 3 * 2);\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        var os = elements[i];\n        var c0 = os.c0;\n        var c1 = os.c1;\n        var v0 = os.v0;\n        var v1 = os.v1;\n        var index = i * 3 * 2;\n        controlArray0[index + 0] = c0.x;\n        controlArray0[index + 1] = c0.y;\n        controlArray0[index + 2] = c0.z;\n        controlArray0[index + 3] = c0.x;\n        controlArray0[index + 4] = c0.y;\n        controlArray0[index + 5] = c0.z;\n        controlArray1[index + 0] = c1.x;\n        controlArray1[index + 1] = c1.y;\n        controlArray1[index + 2] = c1.z;\n        controlArray1[index + 3] = c1.x;\n        controlArray1[index + 4] = c1.y;\n        controlArray1[index + 5] = c1.z;\n        directionArray[index + 0] = v1.x - v0.x;\n        directionArray[index + 1] = v1.y - v0.y;\n        directionArray[index + 2] = v1.z - v0.z;\n        directionArray[index + 3] = v1.x - v0.x;\n        directionArray[index + 4] = v1.y - v0.y;\n        directionArray[index + 5] = v1.z - v0.z;\n      }\n\n      bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n      bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n      bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n    }\n\n    return object3d;\n  } //\n\n\n  function LDrawLoader(manager) {\n    Loader.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  } // Special surface finish tag types.\n  // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\n\n  LDrawLoader.FINISH_TYPE_DEFAULT = 0;\n  LDrawLoader.FINISH_TYPE_CHROME = 1;\n  LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;\n  LDrawLoader.FINISH_TYPE_RUBBER = 3;\n  LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;\n  LDrawLoader.FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n  // The LDraw standard establishes these various possible subfolders.\n\n  LDrawLoader.FILE_LOCATION_AS_IS = 0;\n  LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;\n  LDrawLoader.FILE_LOCATION_TRY_P = 2;\n  LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;\n  LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;\n  LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;\n  LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;\n  LDrawLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: LDrawLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    },\n    parse: function (text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    },\n    setMaterials: function (materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    },\n    setFileMap: function (fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    },\n    newParseScopeLevel: function (materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (let i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new Matrix4(),\n        matrix: new Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    },\n    removeScopeLevel: function () {\n      this.parseScopesStack.pop();\n      return this;\n    },\n    addMaterial: function (material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    },\n    getMaterial: function (colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n\n      for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    },\n    getParentParseScope: function () {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    },\n    getCurrentParseScope: function () {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    },\n    parseColourMetaDirective: function (lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = LDrawLoader.FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = LDrawLoader.FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = LDrawLoader.FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case LDrawLoader.FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: UniformsUtils.merge([UniformsLib.fog, {\n            diffuse: {\n              value: new Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    },\n    //\n    objectParse: function (text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var lineIndex = 0;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  var matrix = currentParseScope.matrix;\n\n                  if (matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  var material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            var material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: LDrawLoader.FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, v3, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    },\n    computeConstructionSteps: function (model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(c => {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    },\n    processObject: function (text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          const objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (let i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n            var os = conditionalSegments[i];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (let i = 0, l = triangles.length; i < l; i++) {\n            var tri = triangles[i];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n              tempVec0.subVectors(tri.v1, tri.v0);\n              tempVec1.subVectors(tri.v2, tri.v1);\n              tri.faceNormal.crossVectors(tempVec0, tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case LDrawLoader.FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case LDrawLoader.FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  });\n  return LDrawLoader;\n}();\n\nexport { LDrawLoader };\n"]},"metadata":{},"sourceType":"module"}