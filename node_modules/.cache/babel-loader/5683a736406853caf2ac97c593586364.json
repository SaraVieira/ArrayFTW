{"ast":null,"code":"import { Vector3, Quaternion, Matrix4 } from 'three';\nimport { CharsetEncoder } from 'mmd-parser';\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nvar MMDExporter = function MMDExporter() {\n  // Unicode to Shift_JIS table\n  var u2sTable;\n\n  function unicodeToShiftjis(str) {\n    if (u2sTable === undefined) {\n      var encoder = new CharsetEncoder(); // eslint-disable-line no-undef\n\n      var table = encoder.s2uTable;\n      u2sTable = {};\n      var keys = Object.keys(table);\n\n      for (var i = 0, il = keys.length; i < il; i++) {\n        var key = keys[i];\n        var value = table[key];\n        key = parseInt(key);\n        u2sTable[value] = key;\n      }\n    }\n\n    var array = [];\n\n    for (var _i = 0, _il = str.length; _i < _il; _i++) {\n      var code = str.charCodeAt(_i);\n      var value = u2sTable[code];\n\n      if (value === undefined) {\n        throw \"cannot convert charcode 0x\".concat(code.toString(16));\n      } else if (value > 0xff) {\n        array.push(value >> 8 & 0xff);\n        array.push(value & 0xff);\n      } else {\n        array.push(value & 0xff);\n      }\n    }\n\n    return new Uint8Array(array);\n  }\n\n  function getBindBones(skin) {\n    // any more efficient ways?\n    var poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n\n\n  this.parseVpd = function (skin, outputShiftJis, useOriginalBones) {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n      return null;\n    }\n\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6) num = 0;\n      var a = num.toString();\n\n      if (a.indexOf('.') === -1) {\n        a += '.';\n      }\n\n      a += '000000';\n      var index = a.indexOf('.');\n      var d = a.slice(0, index);\n      var p = a.slice(index + 1, index + 7);\n      return \"\".concat(d, \".\").concat(p);\n    }\n\n    function toStringsFromArray(array) {\n      var a = [];\n\n      for (var i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]));\n      }\n\n      return a.join(',');\n    }\n\n    skin.updateMatrixWorld(true);\n    var bones = skin.skeleton.bones;\n    var bones2 = getBindBones(skin);\n    var position = new Vector3();\n    var quaternion = new Quaternion();\n    var quaternion2 = new Quaternion();\n    var matrix = new Matrix4();\n    var array = [];\n    array.push('Vocaloid Pose Data file');\n    array.push('');\n    array.push(\"\".concat(skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin', \".osm;\"));\n    array.push(\"\".concat(bones.length, \";\"));\n    array.push('');\n\n    for (var i = 0, il = bones.length; i < il; i++) {\n      var bone = bones[i];\n      var bone2 = bones2[i];\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n\n      if (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      var pArray = position.sub(bone2.position).toArray();\n      var qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray(); // right to left\n\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(\"Bone\".concat(i, \"{\").concat(bone.name));\n      array.push(\"  \".concat(toStringsFromArray(pArray), \";\"));\n      array.push(\"  \".concat(toStringsFromArray(qArray), \";\"));\n      array.push('}');\n      array.push('');\n    }\n\n    array.push('');\n    var lines = array.join('\\n');\n    return outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n  };\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n\n};\n\nexport { MMDExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/MMDExporter.js"],"names":["Vector3","Quaternion","Matrix4","CharsetEncoder","MMDExporter","u2sTable","unicodeToShiftjis","str","undefined","encoder","table","s2uTable","keys","Object","i","il","length","key","value","parseInt","array","code","charCodeAt","toString","push","Uint8Array","getBindBones","skin","poseSkin","clone","pose","skeleton","bones","parseVpd","outputShiftJis","useOriginalBones","isSkinnedMesh","console","warn","toStringsFromNumber","num","Math","abs","a","indexOf","index","d","slice","p","toStringsFromArray","join","updateMatrixWorld","bones2","position","quaternion","quaternion2","matrix","name","replace","bone","bone2","userData","ik","originalMatrix","fromArray","copy","setFromMatrixPosition","setFromRotationMatrix","pArray","sub","toArray","qArray","conjugate","multiply","lines"],"mappings":"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","sourcesContent":["import { Vector3, Quaternion, Matrix4 } from 'three';\nimport { CharsetEncoder } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nconst MMDExporter = function () {\n  // Unicode to Shift_JIS table\n  let u2sTable;\n\n  function unicodeToShiftjis(str) {\n    if (u2sTable === undefined) {\n      const encoder = new CharsetEncoder(); // eslint-disable-line no-undef\n\n      const table = encoder.s2uTable;\n      u2sTable = {};\n      const keys = Object.keys(table);\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i];\n        var value = table[key];\n        key = parseInt(key);\n        u2sTable[value] = key;\n      }\n    }\n\n    const array = [];\n\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i);\n      var value = u2sTable[code];\n\n      if (value === undefined) {\n        throw `cannot convert charcode 0x${code.toString(16)}`;\n      } else if (value > 0xff) {\n        array.push(value >> 8 & 0xff);\n        array.push(value & 0xff);\n      } else {\n        array.push(value & 0xff);\n      }\n    }\n\n    return new Uint8Array(array);\n  }\n\n  function getBindBones(skin) {\n    // any more efficient ways?\n    const poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n\n\n  this.parseVpd = (skin, outputShiftJis, useOriginalBones) => {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n      return null;\n    }\n\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6) num = 0;\n      let a = num.toString();\n\n      if (a.indexOf('.') === -1) {\n        a += '.';\n      }\n\n      a += '000000';\n      const index = a.indexOf('.');\n      const d = a.slice(0, index);\n      const p = a.slice(index + 1, index + 7);\n      return `${d}.${p}`;\n    }\n\n    function toStringsFromArray(array) {\n      const a = [];\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]));\n      }\n\n      return a.join(',');\n    }\n\n    skin.updateMatrixWorld(true);\n    const bones = skin.skeleton.bones;\n    const bones2 = getBindBones(skin);\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const quaternion2 = new Quaternion();\n    const matrix = new Matrix4();\n    const array = [];\n    array.push('Vocaloid Pose Data file');\n    array.push('');\n    array.push(`${skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin'}.osm;`);\n    array.push(`${bones.length};`);\n    array.push('');\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      const bone2 = bones2[i];\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n\n      if (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      const pArray = position.sub(bone2.position).toArray();\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray(); // right to left\n\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(`Bone${i}{${bone.name}`);\n      array.push(`  ${toStringsFromArray(pArray)};`);\n      array.push(`  ${toStringsFromArray(qArray)};`);\n      array.push('}');\n      array.push('');\n    }\n\n    array.push('');\n    const lines = array.join('\\n');\n    return outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n  };\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n\n};\n\nexport { MMDExporter };\n"]},"metadata":{},"sourceType":"module"}