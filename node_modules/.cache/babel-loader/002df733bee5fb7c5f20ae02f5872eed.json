{"ast":null,"code":"import { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\n\nvar ParallaxBarrierEffect = function ParallaxBarrierEffect(renderer) {\n  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  var _scene = new Scene();\n\n  var _stereo = new StereoCamera();\n\n  var _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n\n  var _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n\n  var _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n\n  var _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\tvec2 uv = vUv;', '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\t\tgl_FragColor = texture2D( mapLeft, uv );', '\t} else {', '\t\tgl_FragColor = texture2D( mapRight, uv );', '\t}', '}'].join('\\n')\n  });\n\n  var mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n\n  _scene.add(mesh);\n\n  this.setSize = function (width, height) {\n    renderer.setSize(width, height);\n    var pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = function (scene, camera) {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\n\nexport { ParallaxBarrierEffect };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/effects/ParallaxBarrierEffect.js"],"names":["OrthographicCamera","Scene","StereoCamera","WebGLRenderTarget","ShaderMaterial","Mesh","PlaneGeometry","LinearFilter","NearestFilter","RGBAFormat","ParallaxBarrierEffect","renderer","_camera","_scene","_stereo","_params","minFilter","magFilter","format","_renderTargetL","_renderTargetR","_material","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","mesh","add","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR"],"mappings":"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","sourcesContent":["import { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\n\nconst ParallaxBarrierEffect = function (renderer) {\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  const _scene = new Scene();\n\n  const _stereo = new StereoCamera();\n\n  const _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n\n  const _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n\n  const _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n\n  const _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\tvec2 uv = vUv;', '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\t\tgl_FragColor = texture2D( mapLeft, uv );', '\t} else {', '\t\tgl_FragColor = texture2D( mapRight, uv );', '\t}', '}'].join('\\n')\n  });\n\n  const mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n\n  _scene.add(mesh);\n\n  this.setSize = (width, height) => {\n    renderer.setSize(width, height);\n    const pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = (scene, camera) => {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\n\nexport { ParallaxBarrierEffect };\n"]},"metadata":{},"sourceType":"module"}