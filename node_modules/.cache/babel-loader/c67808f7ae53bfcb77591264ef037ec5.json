{"ast":null,"code":"import _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { BufferAttribute, Matrix4, Vector3, Matrix3, MeshPhongMaterial, UniformsUtils, ShaderLib, ShaderChunk } from 'three';\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\n\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function compressNormals(mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    var normal = mesh.geometry.attributes.normal;\n\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n\n    if (normal.isPacked) return;\n\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n\n    var array = normal.array;\n    var count = normal.count;\n    var result;\n\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n\n      for (var idx = 0; idx < array.length; idx += 3) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n\n      for (var _idx = 0; _idx < array.length; _idx += 3) {\n        var _encoded = this.EncodingFuncs.octEncodeBest(array[_idx], array[_idx + 1], array[_idx + 2], 1);\n\n        result[_idx / 3 * 2 + 0] = _encoded[0];\n        result[_idx / 3 * 2 + 1] = _encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n\n      for (var _idx2 = 0; _idx2 < array.length; _idx2 += 3) {\n        var _encoded2 = this.EncodingFuncs.octEncodeBest(array[_idx2], array[_idx2 + 1], array[_idx2 + 2], 2);\n\n        result[_idx2 / 3 * 2 + 0] = _encoded2[0];\n        result[_idx2 / 3 * 2 + 1] = _encoded2[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n\n      for (var _idx3 = 0; _idx3 < array.length; _idx3 += 3) {\n        var _encoded3 = this.EncodingFuncs.anglesEncode(array[_idx3], array[_idx3 + 1], array[_idx3 + 2]);\n\n        result[_idx3 / 3 * 2 + 0] = _encoded3[0];\n        result[_idx3 / 3 * 2 + 1] = _encoded3[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function compressPositions(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    var position = mesh.geometry.attributes.position;\n\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n\n    if (position.isPacked) return;\n\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n\n    var array = position.array;\n    var encodingBytes = 2;\n    var result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    var quantized = result.quantized;\n    var decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function compressUvs(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n\n    var uvs = mesh.geometry.attributes.uv;\n\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n\n    if (uvs.isPacked) return;\n    var range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    var array = uvs.array;\n\n    for (var i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n\n    var result;\n\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n\n      for (var _i = 0; _i < array.length; _i += 2) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[_i], array[_i + 1], 0, 2);\n        result[_i] = encoded[0];\n        result[_i + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function defaultEncode(x, y, z, bytes) {\n      if (bytes == 1) {\n        var tmpx = Math.round((x + 1) * 0.5 * 255);\n        var tmpy = Math.round((y + 1) * 0.5 * 255);\n        var tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        var _tmpx = Math.round((x + 1) * 0.5 * 65535);\n\n        var _tmpy = Math.round((y + 1) * 0.5 * 65535);\n\n        var _tmpz = Math.round((z + 1) * 0.5 * 65535);\n\n        return new Uint16Array([_tmpx, _tmpy, _tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function defaultDecode(array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function anglesEncode(x, y, z) {\n      var normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      var normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function octEncodeBest(x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n\n      return best;\n\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n\n        var z = 1 - Math.abs(x) - Math.abs(y);\n\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function quantizedEncode(array, bytes) {\n      var quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      var decodeMat = new Matrix4();\n      var min = new Float32Array(3);\n      var max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n\n      for (var i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n\n      decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n\n      for (var _i2 = 0; _i2 < array.length; _i2 += 3) {\n        quantized[_i2 + 0] = Math.floor((array[_i2 + 0] - min[0]) * multiplier[0]);\n        quantized[_i2 + 1] = Math.floor((array[_i2 + 1] - min[1]) * multiplier[1]);\n        quantized[_i2 + 2] = Math.floor((array[_i2 + 2] - min[2]) * multiplier[2]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function quantizedEncodeUV(array, bytes) {\n      var quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      var decodeMat = new Matrix3();\n      var min = new Float32Array(2);\n      var max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n\n      for (var i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n\n      for (var _i3 = 0; _i3 < array.length; _i3 += 2) {\n        quantized[_i3 + 0] = Math.floor((array[_i3 + 0] - min[0]) * multiplier[0]);\n        quantized[_i3 + 1] = Math.floor((array[_i3 + 1] - min[1]) * multiplier[1]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\n\nvar PackedPhongMaterial = /*#__PURE__*/function (_MeshPhongMaterial) {\n  _inherits(PackedPhongMaterial, _MeshPhongMaterial);\n\n  var _super = _createSuper(PackedPhongMaterial);\n\n  function PackedPhongMaterial(parameters) {\n    var _this;\n\n    _classCallCheck(this, PackedPhongMaterial);\n\n    _this = _super.call(this);\n    _this.defines = {};\n    _this.type = 'PackedPhongMaterial';\n    _this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    _this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 0\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tfloat x = packedNormal.x * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tfloat y = packedNormal.y * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\\n\\t\\t\\t\\t\\t\\t\\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\\n\\t\\t\\t\\t\\t\\t\\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 1\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\\n\\t\\t\\t\\t\\t\\t\\tif (v.z < 0.0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 2\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = (packedNormal * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\tuniform mat4 quantizeMatPos;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tuniform mat3 quantizeMatUV;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 0\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = (packedUV * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", 'void main() {', ShaderChunk.uv_vertex, \"#ifdef USE_UV\\n\\t\\t\\t\\t\\t#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t\\tvUv = decodeUV(vUv);\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\tobjectNormal = decodeNormal(objectNormal);\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\t\\t\\tvec3 objectTangent = vec3( tangent.xyz );\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\", ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', ShaderChunk.begin_vertex, \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    _this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', ShaderChunk.common, ShaderChunk.packing, ShaderChunk.dithering_pars_fragment, ShaderChunk.color_pars_fragment, ShaderChunk.uv_pars_fragment, ShaderChunk.uv2_pars_fragment, ShaderChunk.map_pars_fragment, ShaderChunk.alphamap_pars_fragment, ShaderChunk.aomap_pars_fragment, ShaderChunk.lightmap_pars_fragment, ShaderChunk.emissivemap_pars_fragment, ShaderChunk.envmap_common_pars_fragment, ShaderChunk.envmap_pars_fragment, ShaderChunk.cube_uv_reflection_fragment, ShaderChunk.fog_pars_fragment, ShaderChunk.bsdfs, ShaderChunk.lights_pars_begin, ShaderChunk.lights_phong_pars_fragment, ShaderChunk.shadowmap_pars_fragment, ShaderChunk.bumpmap_pars_fragment, ShaderChunk.normalmap_pars_fragment, ShaderChunk.specularmap_pars_fragment, ShaderChunk.logdepthbuf_pars_fragment, ShaderChunk.clipping_planes_pars_fragment, 'void main() {', ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', ShaderChunk.logdepthbuf_fragment, ShaderChunk.map_fragment, ShaderChunk.color_fragment, ShaderChunk.alphamap_fragment, ShaderChunk.alphatest_fragment, ShaderChunk.specularmap_fragment, ShaderChunk.normal_fragment_begin, ShaderChunk.normal_fragment_maps, ShaderChunk.emissivemap_fragment, // accumulation\n    ShaderChunk.lights_phong_fragment, ShaderChunk.lights_fragment_begin, ShaderChunk.lights_fragment_maps, ShaderChunk.lights_fragment_end, // modulation\n    ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', ShaderChunk.tonemapping_fragment, ShaderChunk.encodings_fragment, ShaderChunk.fog_fragment, ShaderChunk.premultiplied_alpha_fragment, ShaderChunk.dithering_fragment, '}'].join('\\n');\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  return PackedPhongMaterial;\n}(MeshPhongMaterial);\n\nexport { GeometryCompressionUtils, PackedPhongMaterial };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/utils/GeometryCompressionUtils.js"],"names":["BufferAttribute","Matrix4","Vector3","Matrix3","MeshPhongMaterial","UniformsUtils","ShaderLib","ShaderChunk","GeometryCompressionUtils","compressNormals","mesh","encodeMethod","geometry","console","error","normal","attributes","isPacked","itemSize","array","count","result","Uint8Array","idx","length","encoded","EncodingFuncs","defaultEncode","setAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","material","PackedPhongMaterial","copy","defines","USE_PACKED_NORMAL","compressPositions","position","encodingBytes","quantizedEncode","quantized","decodeMat","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","USE_PACKED_POSITION","uniforms","quantizeMatPos","value","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","USE_PACKED_UV","quantizedEncodeUV","quantizeMatUV","x","y","z","tmpx","round","tmpy","tmpz","defaultDecode","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","Float32Array","Number","MAX_VALUE","scale","elements","transpose","multiplier","floor","parameters","type","merge","phong","vertexShader","common","uv_pars_vertex","uv2_pars_vertex","displacementmap_pars_vertex","envmap_pars_vertex","color_pars_vertex","fog_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","uv2_vertex","color_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","envmap_vertex","shadowmap_vertex","fog_vertex","join","fragmentShader","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","uv2_pars_fragment","map_pars_fragment","alphamap_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","envmap_common_pars_fragment","envmap_pars_fragment","cube_uv_reflection_fragment","fog_pars_fragment","bsdfs","lights_pars_begin","lights_phong_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","specularmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","specularmap_fragment","normal_fragment_begin","normal_fragment_maps","emissivemap_fragment","lights_phong_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","envmap_fragment","tonemapping_fragment","encodings_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment","setValues"],"mappings":"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","sourcesContent":["import { BufferAttribute, Matrix4, Vector3, Matrix3, MeshPhongMaterial, UniformsUtils, ShaderLib, ShaderChunk } from 'three';\n\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function (mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    const normal = mesh.geometry.attributes.normal;\n\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n\n    if (normal.isPacked) return;\n\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n\n    const array = normal.array;\n    const count = normal.count;\n    let result;\n\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n\n      for (let idx = 0; idx < array.length; idx += 3) {\n        const encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\n        result[idx / 3 * 2 + 0] = encoded[0];\n        result[idx / 3 * 2 + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    const position = mesh.geometry.attributes.position;\n\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n\n    if (position.isPacked) return;\n\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n\n    const array = position.array;\n    const encodingBytes = 2;\n    const result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    const quantized = result.quantized;\n    const decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function (mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n\n    const uvs = mesh.geometry.attributes.uv;\n\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n\n    if (uvs.isPacked) return;\n    const range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    const array = uvs.array;\n\n    for (let i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n\n    let result;\n\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n\n      for (let i = 0; i < array.length; i += 2) {\n        const encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);\n        result[i] = encoded[0];\n        result[i + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function (x, y, z, bytes) {\n      if (bytes == 1) {\n        const tmpx = Math.round((x + 1) * 0.5 * 255);\n        const tmpy = Math.round((y + 1) * 0.5 * 255);\n        const tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        const tmpx = Math.round((x + 1) * 0.5 * 65535);\n        const tmpy = Math.round((y + 1) * 0.5 * 65535);\n        const tmpz = Math.round((z + 1) * 0.5 * 65535);\n        return new Uint16Array([tmpx, tmpy, tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function (array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function (x, y, z) {\n      const normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      const normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function (x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n\n      return best;\n\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n\n        var z = 1 - Math.abs(x) - Math.abs(y);\n\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function (array, bytes) {\n      let quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      const decodeMat = new Matrix4();\n      const min = new Float32Array(3);\n      const max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n\n      for (let i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n\n      decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n\n      for (let i = 0; i < array.length; i += 3) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function (array, bytes) {\n      let quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      const decodeMat = new Matrix3();\n      const min = new Float32Array(2);\n      const max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n\n      for (let i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n\n      for (let i = 0; i < array.length; i += 2) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\n\nclass PackedPhongMaterial extends MeshPhongMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {};\n    this.type = 'PackedPhongMaterial';\n    this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, 'void main() {', ShaderChunk.uv_vertex, `#ifdef USE_UV\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`, ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', ShaderChunk.begin_vertex, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', ShaderChunk.common, ShaderChunk.packing, ShaderChunk.dithering_pars_fragment, ShaderChunk.color_pars_fragment, ShaderChunk.uv_pars_fragment, ShaderChunk.uv2_pars_fragment, ShaderChunk.map_pars_fragment, ShaderChunk.alphamap_pars_fragment, ShaderChunk.aomap_pars_fragment, ShaderChunk.lightmap_pars_fragment, ShaderChunk.emissivemap_pars_fragment, ShaderChunk.envmap_common_pars_fragment, ShaderChunk.envmap_pars_fragment, ShaderChunk.cube_uv_reflection_fragment, ShaderChunk.fog_pars_fragment, ShaderChunk.bsdfs, ShaderChunk.lights_pars_begin, ShaderChunk.lights_phong_pars_fragment, ShaderChunk.shadowmap_pars_fragment, ShaderChunk.bumpmap_pars_fragment, ShaderChunk.normalmap_pars_fragment, ShaderChunk.specularmap_pars_fragment, ShaderChunk.logdepthbuf_pars_fragment, ShaderChunk.clipping_planes_pars_fragment, 'void main() {', ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', ShaderChunk.logdepthbuf_fragment, ShaderChunk.map_fragment, ShaderChunk.color_fragment, ShaderChunk.alphamap_fragment, ShaderChunk.alphatest_fragment, ShaderChunk.specularmap_fragment, ShaderChunk.normal_fragment_begin, ShaderChunk.normal_fragment_maps, ShaderChunk.emissivemap_fragment, // accumulation\n    ShaderChunk.lights_phong_fragment, ShaderChunk.lights_fragment_begin, ShaderChunk.lights_fragment_maps, ShaderChunk.lights_fragment_end, // modulation\n    ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', ShaderChunk.tonemapping_fragment, ShaderChunk.encodings_fragment, ShaderChunk.fog_fragment, ShaderChunk.premultiplied_alpha_fragment, ShaderChunk.dithering_fragment, '}'].join('\\n');\n    this.setValues(parameters);\n  }\n\n}\n\nexport { GeometryCompressionUtils, PackedPhongMaterial };\n"]},"metadata":{},"sourceType":"module"}