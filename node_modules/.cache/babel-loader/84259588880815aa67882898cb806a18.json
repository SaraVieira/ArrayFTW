{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n        result;\n\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian,\n          i = 0;\n      result = new viewType(length);\n\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n\n    return result;\n  }\n\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n        version = array[0],\n        flags = array[1],\n        indexedGeometry = !!(flags >> 7 & 0x01),\n        indicesType = flags >> 6 & 0x01,\n        bigEndian = (flags >> 5 & 0x01) === 1,\n        attributesNumber = flags & 0x1f,\n        valuesNumber = 0,\n        indicesNumber = 0;\n\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n\n    var pos = 8;\n    var attributes = {},\n        attributeName,\n        char,\n        attributeType,\n        cardinality,\n        encodingType,\n        arrayType,\n        values,\n        indices,\n        i;\n\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function parse(arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry(),\n          attribute,\n          i;\n\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  });\n\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n\n  return PRWMLoader;\n}();\n\nexport { PRWMLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/PRWMLoader.js"],"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","PRWMLoader","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","bytesPerElement","BYTES_PER_ELEMENT","result","readView","DataView","getMethod","name","littleEndian","i","decodePrwm","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","pos","attributes","attributeName","char","attributeType","cardinality","encodingType","arrayType","values","indices","String","fromCharCode","Math","ceil","type","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","replace","arrayBuffer","parse","e","console","error","itemError","data","attributesKey","keys","bufferGeometry","attribute","setAttribute","normalized","setIndex"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n        result;\n\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian,\n          i = 0;\n      result = new viewType(length);\n\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n\n    return result;\n  }\n\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n        version = array[0],\n        flags = array[1],\n        indexedGeometry = !!(flags >> 7 & 0x01),\n        indicesType = flags >> 6 & 0x01,\n        bigEndian = (flags >> 5 & 0x01) === 1,\n        attributesNumber = flags & 0x1f,\n        valuesNumber = 0,\n        indicesNumber = 0;\n\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n\n    var pos = 8;\n    var attributes = {},\n        attributeName,\n        char,\n        attributeType,\n        cardinality,\n        encodingType,\n        arrayType,\n        values,\n        indices,\n        i;\n\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry(),\n          attribute,\n          i;\n\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  });\n\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n\n  return PRWMLoader;\n}();\n\nexport { PRWMLoader };\n"]},"metadata":{},"sourceType":"module"}