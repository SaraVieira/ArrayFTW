{"ast":null,"code":"import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearEncoding, NoToneMapping, LinearFilter, RGBFormat } from 'three';\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nvar Water = function Water(geometry, options) {\n  Mesh.call(this, geometry);\n  var scope = this;\n  options = options || {};\n  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n  var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n  var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : FrontSide;\n  var fog = options.fog !== undefined ? options.fog : false; //\n\n  var mirrorPlane = new Plane();\n  var normal = new Vector3();\n  var mirrorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var mirrorCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var mirrorShader = {\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n      normalSampler: {\n        value: null\n      },\n      mirrorSampler: {\n        value: null\n      },\n      alpha: {\n        value: 1.0\n      },\n      time: {\n        value: 0.0\n      },\n      size: {\n        value: 1.0\n      },\n      distortionScale: {\n        value: 20.0\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      sunColor: {\n        value: new Color(0x7f7f7f)\n      },\n      sunDirection: {\n        value: new Vector3(0.70707, 0.70707, 0)\n      },\n      eye: {\n        value: new Vector3()\n      },\n      waterColor: {\n        value: new Color(0x555555)\n      }\n    }]),\n    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '\tmirrorCoord = modelMatrix * vec4( position, 1.0 );', '\tworldPosition = mirrorCoord.xyzw;', '\tmirrorCoord = textureMatrix * mirrorCoord;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * mvPosition;', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '\tvec4 noise = texture2D( normalSampler, uv0 ) +', '\t\ttexture2D( normalSampler, uv1 ) +', '\t\ttexture2D( normalSampler, uv2 ) +', '\t\ttexture2D( normalSampler, uv3 );', '\treturn noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );', '\tspecularColor += pow( direction, shiny ) * sunColor * spec;', '\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '\tvec4 noise = getNoise( worldPosition.xz * size );', '\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '\tvec3 diffuseLight = vec3(0.0);', '\tvec3 specularLight = vec3(0.0);', '\tvec3 worldToEye = eye-worldPosition.xyz;', '\tvec3 eyeDirection = normalize( worldToEye );', '\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '\tfloat distance = length(worldToEye);', '\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '\tfloat rf0 = 0.3;', '\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '\tvec3 outgoingLight = albedo;', '\tgl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    fragmentShader: mirrorShader.fragmentShader,\n    vertexShader: mirrorShader.vertexShader,\n    uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n    lights: true,\n    side: side,\n    fog: fog\n  });\n  material.uniforms['mirrorSampler'].value = renderTarget.texture;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  material.uniforms['alpha'].value = alpha;\n  material.uniforms['time'].value = time;\n  material.uniforms['normalSampler'].value = normalSampler;\n  material.uniforms['sunColor'].value = sunColor;\n  material.uniforms['waterColor'].value = waterColor;\n  material.uniforms['sunDirection'].value = sunDirection;\n  material.uniforms['distortionScale'].value = distortionScale;\n  material.uniforms['eye'].value = eye;\n  scope.material = material;\n\n  scope.onBeforeRender = function (renderer, scene, camera) {\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n    eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n    if (renderer.outputEncoding !== LinearEncoding) {\n      console.warn('THREE.Water: WebGLRenderer must use LinearEncoding as outputEncoding.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    if (renderer.toneMapping !== NoToneMapping) {\n      console.warn('THREE.Water: WebGLRenderer must use NoToneMapping as toneMapping.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    scope.visible = false;\n    renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, mirrorCamera);\n    scope.visible = true;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n  };\n};\n\nWater.prototype = Object.create(Mesh.prototype);\nWater.prototype.constructor = Water;\nexport { Water };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/Water.js"],"names":["Mesh","Vector3","Color","FrontSide","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","MathUtils","UniformsUtils","UniformsLib","ShaderMaterial","LinearEncoding","NoToneMapping","LinearFilter","RGBFormat","Water","geometry","options","call","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","join","fragmentShader","material","clone","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","outputEncoding","console","warn","toneMapping","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor"],"mappings":"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","sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearEncoding, NoToneMapping, LinearFilter, RGBFormat } from 'three';\n\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nvar Water = function (geometry, options) {\n  Mesh.call(this, geometry);\n  var scope = this;\n  options = options || {};\n  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n  var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n  var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : FrontSide;\n  var fog = options.fog !== undefined ? options.fog : false; //\n\n  var mirrorPlane = new Plane();\n  var normal = new Vector3();\n  var mirrorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var mirrorCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var mirrorShader = {\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n      normalSampler: {\n        value: null\n      },\n      mirrorSampler: {\n        value: null\n      },\n      alpha: {\n        value: 1.0\n      },\n      time: {\n        value: 0.0\n      },\n      size: {\n        value: 1.0\n      },\n      distortionScale: {\n        value: 20.0\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      sunColor: {\n        value: new Color(0x7f7f7f)\n      },\n      sunDirection: {\n        value: new Vector3(0.70707, 0.70707, 0)\n      },\n      eye: {\n        value: new Vector3()\n      },\n      waterColor: {\n        value: new Color(0x555555)\n      }\n    }]),\n    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '\tmirrorCoord = modelMatrix * vec4( position, 1.0 );', '\tworldPosition = mirrorCoord.xyzw;', '\tmirrorCoord = textureMatrix * mirrorCoord;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * mvPosition;', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '\tvec4 noise = texture2D( normalSampler, uv0 ) +', '\t\ttexture2D( normalSampler, uv1 ) +', '\t\ttexture2D( normalSampler, uv2 ) +', '\t\ttexture2D( normalSampler, uv3 );', '\treturn noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );', '\tspecularColor += pow( direction, shiny ) * sunColor * spec;', '\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '\tvec4 noise = getNoise( worldPosition.xz * size );', '\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '\tvec3 diffuseLight = vec3(0.0);', '\tvec3 specularLight = vec3(0.0);', '\tvec3 worldToEye = eye-worldPosition.xyz;', '\tvec3 eyeDirection = normalize( worldToEye );', '\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '\tfloat distance = length(worldToEye);', '\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '\tfloat rf0 = 0.3;', '\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '\tvec3 outgoingLight = albedo;', '\tgl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    fragmentShader: mirrorShader.fragmentShader,\n    vertexShader: mirrorShader.vertexShader,\n    uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n    lights: true,\n    side: side,\n    fog: fog\n  });\n  material.uniforms['mirrorSampler'].value = renderTarget.texture;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  material.uniforms['alpha'].value = alpha;\n  material.uniforms['time'].value = time;\n  material.uniforms['normalSampler'].value = normalSampler;\n  material.uniforms['sunColor'].value = sunColor;\n  material.uniforms['waterColor'].value = waterColor;\n  material.uniforms['sunDirection'].value = sunDirection;\n  material.uniforms['distortionScale'].value = distortionScale;\n  material.uniforms['eye'].value = eye;\n  scope.material = material;\n\n  scope.onBeforeRender = function (renderer, scene, camera) {\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n    eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n    if (renderer.outputEncoding !== LinearEncoding) {\n      console.warn('THREE.Water: WebGLRenderer must use LinearEncoding as outputEncoding.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    if (renderer.toneMapping !== NoToneMapping) {\n      console.warn('THREE.Water: WebGLRenderer must use NoToneMapping as toneMapping.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    scope.visible = false;\n    renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, mirrorCamera);\n    scope.visible = true;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n  };\n};\n\nWater.prototype = Object.create(Mesh.prototype);\nWater.prototype.constructor = Water;\n\nexport { Water };\n"]},"metadata":{},"sourceType":"module"}