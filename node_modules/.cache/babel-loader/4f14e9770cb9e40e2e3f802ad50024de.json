{"ast":null,"code":"import _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nvar LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_vertex>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\t\\t#include <clipping_planes_pars_vertex>\\n\\n\\t\\tuniform float linewidth;\\n\\t\\tuniform vec2 resolution;\\n\\n\\t\\tattribute vec3 instanceStart;\\n\\t\\tattribute vec3 instanceEnd;\\n\\n\\t\\tattribute vec3 instanceColorStart;\\n\\t\\tattribute vec3 instanceColorEnd;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashScale;\\n\\t\\t\\tattribute float instanceDistanceStart;\\n\\t\\t\\tattribute float instanceDistanceEnd;\\n\\t\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#endif\\n\\n\\t\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\n\\n\\t\\t\\t// trim end segment so it terminates between the camera plane and the near plane\\n\\n\\t\\t\\t// conservative estimate of the near plane\\n\\t\\t\\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\n\\t\\t\\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\n\\t\\t\\tfloat nearEstimate = - 0.5 * b / a;\\n\\n\\t\\t\\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\\n\\n\\t\\t\\tend.xyz = mix( start.xyz, end.xyz, alpha );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#ifdef USE_COLOR\\n\\n\\t\\t\\t\\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat aspect = resolution.x / resolution.y;\\n\\n\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\t// camera space\\n\\t\\t\\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\\n\\t\\t\\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\\n\\n\\t\\t\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\n\\t\\t\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\n\\t\\t\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\n\\t\\t\\t// perhaps there is a more elegant solution -- WestLangley\\n\\n\\t\\t\\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\\n\\n\\t\\t\\tif ( perspective ) {\\n\\n\\t\\t\\t\\tif ( start.z < 0.0 && end.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( start, end );\\n\\n\\t\\t\\t\\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( end, start );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip space\\n\\t\\t\\tvec4 clipStart = projectionMatrix * start;\\n\\t\\t\\tvec4 clipEnd = projectionMatrix * end;\\n\\n\\t\\t\\t// ndc space\\n\\t\\t\\tvec2 ndcStart = clipStart.xy / clipStart.w;\\n\\t\\t\\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\\n\\n\\t\\t\\t// direction\\n\\t\\t\\tvec2 dir = ndcEnd - ndcStart;\\n\\n\\t\\t\\t// account for clip-space aspect ratio\\n\\t\\t\\tdir.x *= aspect;\\n\\t\\t\\tdir = normalize( dir );\\n\\n\\t\\t\\t// perpendicular to dir\\n\\t\\t\\tvec2 offset = vec2( dir.y, - dir.x );\\n\\n\\t\\t\\t// undo aspect ratio adjustment\\n\\t\\t\\tdir.x /= aspect;\\n\\t\\t\\toffset.x /= aspect;\\n\\n\\t\\t\\t// sign flip\\n\\t\\t\\tif ( position.x < 0.0 ) offset *= - 1.0;\\n\\n\\t\\t\\t// endcaps\\n\\t\\t\\tif ( position.y < 0.0 ) {\\n\\n\\t\\t\\t\\toffset += - dir;\\n\\n\\t\\t\\t} else if ( position.y > 1.0 ) {\\n\\n\\t\\t\\t\\toffset += dir;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// adjust for linewidth\\n\\t\\t\\toffset *= linewidth;\\n\\n\\t\\t\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\n\\t\\t\\toffset /= resolution.y;\\n\\n\\t\\t\\t// select end\\n\\t\\t\\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\\n\\n\\t\\t\\t// back to clip space\\n\\t\\t\\toffset *= clip.w;\\n\\n\\t\\t\\tclip.xy += offset;\\n\\n\\t\\t\\tgl_Position = clip;\\n\\n\\t\\t\\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <clipping_planes_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\\n\\t\\t\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 diffuse;\\n\\t\\tuniform float opacity;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashSize;\\n\\t\\t\\tuniform float dashOffset;\\n\\t\\t\\tuniform float gapSize;\\n\\n\\t\\t#endif\\n\\n\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_fragment>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t#include <clipping_planes_pars_fragment>\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <clipping_planes_fragment>\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\\n\\n\\t\\t\\t\\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat alpha = opacity;\\n\\n\\t\\t\\t#ifdef ALPHA_TO_COVERAGE\\n\\n\\t\\t\\t// artifacts appear on some hardware if a derivative is taken within a conditional\\n\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\tfloat len2 = a * a + b * b;\\n\\t\\t\\tfloat dlen = fwidth( len2 );\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\t\\tfloat len2 = a * a + b * b;\\n\\n\\t\\t\\t\\tif ( len2 > 1.0 ) discard;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tvec4 diffuseColor = vec4( diffuse, alpha );\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t#include <color_fragment>\\n\\n\\t\\t\\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\t\\t\\t#include <premultiplied_alpha_fragment>\\n\\n\\t\\t}\\n\\t\\t\"\n};\n\nvar LineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LineMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(LineMaterial);\n\n  function LineMaterial() {\n    var _this;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LineMaterial);\n\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(_assertThisInitialized(_this), \"isLineMaterial\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashed\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"color\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lineWidth\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashScale\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashOffset\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"opacity\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"resolution\", new Vector2());\n\n    _defineProperty(_assertThisInitialized(_this), \"alphaToCoverage\", false);\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function set(value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function get() {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function set(value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  return LineMaterial;\n}(ShaderMaterial);\n\nexport { LineMaterial };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/lines/LineMaterial.js"],"names":["_defineProperty","Vector2","ShaderLib","UniformsUtils","UniformsLib","ShaderMaterial","LineUniforms","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","copy","alphaToCoverage","Boolean","defines","needsUpdate","ALPHA_TO_COVERAGE","extensions","derivatives","setValues"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters = {}) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", 0);\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n"]},"metadata":{},"sourceType":"module"}