{"ast":null,"code":"import { DataTextureLoader, FloatType, HalfFloatType, UnsignedByteType, RGBEFormat, RGBAFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function EXRLoader(manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = FloatType;\n};\n\nEXRLoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: EXRLoader,\n  parse: function parse(buffer) {\n    var USHORT_RANGE = 1 << 16;\n    var BITMAP_SIZE = USHORT_RANGE >> 3;\n    var HUF_ENCBITS = 16; // literal (value) bit length\n\n    var HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    var HUF_DECMASK = HUF_DECSIZE - 1;\n    var NBITS = 16;\n    var A_OFFSET = 1 << NBITS - 1;\n    var MOD_MASK = (1 << NBITS) - 1;\n    var SHORT_ZEROCODE_RUN = 59;\n    var LONG_ZEROCODE_RUN = 63;\n    var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    var ULONG_SIZE = 8;\n    var FLOAT32_SIZE = 4;\n    var INT32_SIZE = 4;\n    var INT16_SIZE = 2;\n    var INT8_SIZE = 1;\n    var STATIC_HUFFMAN = 0;\n    var DEFLATE = 1;\n    var UNKNOWN = 0;\n    var LOSSY_DCT = 1;\n    var RLE = 2;\n    var logBase = Math.pow(2.7182818, 2.2);\n    var tmpDataView = new DataView(new ArrayBuffer(8));\n\n    function frexp(value) {\n      if (value === 0) return [value, 0];\n      tmpDataView.setFloat64(0, value);\n      var bits = tmpDataView.getUint32(0) >>> 20 & 0x7ff;\n\n      if (bits === 0) {\n        // denormal\n        tmpDataView.setFloat64(0, value * Math.pow(2, 64)); // exp + 64\n\n        bits = (tmpDataView.getUint32(0) >>> 20 & 0x7ff) - 64;\n      }\n\n      var exponent = bits - 1022;\n      var mantissa = ldexp(value, -exponent);\n      return [mantissa, exponent];\n    }\n\n    function ldexp(mantissa, exponent) {\n      var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n      var result = mantissa;\n\n      for (var i = 0; i < steps; i++) {\n        result *= Math.pow(2, Math.floor((exponent + i) / steps));\n      }\n\n      return result;\n    }\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) {\n        lut[k++] = 0;\n      }\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    var getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    var hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) {\n        hufTableBuffer[i] = 0;\n      }\n\n      for (var _i = 0; _i < HUF_ENCSIZE; ++_i) {\n        hufTableBuffer[hcode[_i]] += 1;\n      }\n\n      var c = 0;\n\n      for (var _i2 = 58; _i2 > 0; --_i2) {\n        var nc = c + hufTableBuffer[_i2] >> 1;\n        hufTableBuffer[_i2] = c;\n        c = nc;\n      }\n\n      for (var _i3 = 0; _i3 < HUF_ENCSIZE; ++_i3) {\n        var l = hcode[_i3];\n        if (l > 0) hcode[_i3] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) {\n            hcode[im++] = 0;\n          }\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) {\n            hcode[im++] = 0;\n          }\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (var _i4 = 1 << HUF_DECBITS - l; _i4 > 0; _i4--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    var getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    var getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    var wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) {\n        p <<= 1;\n      }\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (var _i5 = 0; _i5 < count + 1; _i5++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (var comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (var _comp = 0; _comp < numComp; ++_comp) {\n            halfZigBlock[_comp].fill(0); // set block DC component\n\n\n            halfZigBlock[_comp][0] = dcBuffer[currDcComp[_comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[_comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[_comp], dctData[_comp]); // decode float dct\n\n            dctInverse(dctData[_comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n            convertToHalf(dctData[_comp2], rowBlock[_comp2], blockx * 64);\n          }\n        } // blockx\n\n\n        var _offset = 0;\n\n        for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n          var _type = channelData[cscSet.idx[_comp3]].type;\n\n          for (var y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            _offset = rowOffsets[_comp3][y];\n\n            for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n              var src = _blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(_offset + 0 * INT16_SIZE * _type, rowBlock[_comp3][src + 0], true);\n              dataView.setUint16(_offset + 1 * INT16_SIZE * _type, rowBlock[_comp3][src + 1], true);\n              dataView.setUint16(_offset + 2 * INT16_SIZE * _type, rowBlock[_comp3][src + 2], true);\n              dataView.setUint16(_offset + 3 * INT16_SIZE * _type, rowBlock[_comp3][src + 3], true);\n              dataView.setUint16(_offset + 4 * INT16_SIZE * _type, rowBlock[_comp3][src + 4], true);\n              dataView.setUint16(_offset + 5 * INT16_SIZE * _type, rowBlock[_comp3][src + 5], true);\n              dataView.setUint16(_offset + 6 * INT16_SIZE * _type, rowBlock[_comp3][src + 6], true);\n              dataView.setUint16(_offset + 7 * INT16_SIZE * _type, rowBlock[_comp3][src + 7], true);\n              _offset += 8 * INT16_SIZE * _type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n              var _offset2 = rowOffsets[_comp3][_y] + 8 * numFullBlocksX * INT16_SIZE * _type;\n\n              var _src = numFullBlocksX * 64 + (_y & 0x7) * 8;\n\n              for (var x = 0; x < maxX; ++x) {\n                dataView.setUint16(_offset2 + x * INT16_SIZE * _type, rowBlock[_comp3][_src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (var _comp4 = 0; _comp4 < numComp; ++_comp4) {\n        channelData[cscSet.idx[_comp4]].decoded = true;\n        var type = channelData[cscSet.idx[_comp4]].type;\n        if (channelData[_comp4].type != 2) continue;\n\n        for (var _y2 = 0; _y2 < height; ++_y2) {\n          var _offset3 = rowOffsets[_comp4][_y2];\n\n          for (var _x = 0; _x < width; ++_x) {\n            halfRow[_x] = dataView.getUint16(_offset3 + _x * INT16_SIZE * type, true);\n          }\n\n          for (var _x2 = 0; _x2 < width; ++_x2) {\n            dataView.setFloat32(_offset3 + _x2 * INT16_SIZE * type, decodeFloat16(halfRow[_x2]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      var a = 0.5 * Math.cos(3.14159 / 4.0);\n      var b = 0.5 * Math.cos(3.14159 / 16.0);\n      var c = 0.5 * Math.cos(3.14159 / 8.0);\n      var d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      var e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      var f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      var g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var tmpBufSize = info.width * scanlineBlockSize * (EXRHeader.channels.length * info.type);\n      var outBuffer = new Uint16Array(tmpBufSize);\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var _i6 = 0; _i6 < maxNonZero - minNonZero + 1; _i6++) {\n          bitmap[_i6 + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (var _i7 = 0; _i7 < info.channels; ++_i7) {\n        var cd = pizChannelData[_i7];\n\n        for (var j = 0; j < pizChannelData[_i7].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n\n      if (typeof fflate === 'undefined') {\n        console.error('THREE.EXRLoader: External library fflate.min.js required.');\n      }\n\n      var rawBuffer = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var sz = info.lines * info.channels * info.width;\n      var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      var tmpBufferEnd = 0;\n      var writePtr = 0;\n      var ptr = new Array(4);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (var j = 0; j < info.width; ++j) {\n                var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (var _j = 0; _j < info.width; ++_j) {\n                var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n\n                pixel += _diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (EXRHeader.channels.length * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'; // Read channel ruleset information\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (var _offset4 = 0; _offset4 < info.channels; ++_offset4) {\n        var cd = channelData[_offset4];\n\n        for (var _i8 = 0; _i8 < channelRules.length; ++_i8) {\n          var rule = channelRules[_i8];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = _offset4;\n            }\n\n            cd.offset = _offset4;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (var _i9 = 0; _i9 < rowOffsets.length; ++_i9) {\n        rowOffsets[_i9] = new Array();\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (var _i10 = 0; _i10 < channelData.length; ++_i10) {\n        var cd = channelData[_i10];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (var _y3 = 0; _y3 < info.lines; ++_y3) {\n              var rowOffsetBytes = rowOffsets[_i10][row];\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseUlong(dataView, offset) {\n      var uLong = dataView.getUint32(0, true);\n      offset.value = offset.value + ULONG_SIZE;\n      return uLong;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseInt64(dataView, offset) {\n      var int = Number(dataView.getBigInt64(offset.value, true));\n      offset.value += ULONG_SIZE;\n      return int;\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    var bufferDataView = new DataView(buffer);\n    var uInt8Array = new Uint8Array(buffer);\n    var EXRHeader = {};\n    bufferDataView.getUint32(0, true); // magic\n\n    bufferDataView.getUint8(4, true); // versionByteZero\n\n    bufferDataView.getUint8(5, true); // fullMask\n    // start of header\n\n    var offset = {\n      value: 8\n    }; // start at 8, after magic stuff\n\n    var keepReading = true;\n\n    while (keepReading) {\n      var attributeName = parseNullTerminatedString(buffer, offset);\n\n      if (attributeName == 0) {\n        keepReading = false;\n      } else {\n        var attributeType = parseNullTerminatedString(buffer, offset);\n        var attributeSize = parseUint32(bufferDataView, offset);\n        var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n\n        if (attributeValue === undefined) {\n          console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n        } else {\n          EXRHeader[attributeName] = attributeValue;\n        }\n      }\n    } // offsets\n\n\n    var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n    var uncompress;\n    var scanlineBlockSize;\n\n    switch (EXRHeader.compression) {\n      case 'NO_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRAW;\n        break;\n\n      case 'RLE_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRLE;\n        break;\n\n      case 'ZIPS_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'ZIP_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'PIZ_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressPIZ;\n        break;\n\n      case 'PXR24_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressPXR;\n        break;\n\n      case 'DWAA_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressDWA;\n        break;\n\n      case 'DWAB_COMPRESSION':\n        scanlineBlockSize = 256;\n        uncompress = uncompressDWA;\n        break;\n\n      default:\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n    }\n\n    var size_t;\n    var getValue; // mixed pixelType not supported\n\n    var pixelType = EXRHeader.channels[0].pixelType;\n\n    if (pixelType === 1) {\n      // half\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat16;\n          size_t = INT16_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = parseUint16;\n          size_t = INT16_SIZE;\n          break;\n      }\n    } else if (pixelType === 2) {\n      // float\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat32;\n          size_t = FLOAT32_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = decodeFloat32;\n          size_t = FLOAT32_SIZE;\n      }\n    } else {\n      throw 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n    }\n\n    var numBlocks = dataWindowHeight / scanlineBlockSize;\n\n    for (var i = 0; i < numBlocks; i++) {\n      parseUlong(bufferDataView, offset); // scanlineOffset\n    } // we should be passed the scanline offset table, start reading pixel data\n\n\n    var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n    var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1; // Firefox only supports RGBA (half) float textures\n    // var numChannels = EXRHeader.channels.length;\n\n    var numChannels = 4;\n    var size = width * height * numChannels; // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n    switch (this.type) {\n      case UnsignedByteType:\n      case FloatType:\n        var byteArray = new Float32Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(1, 0, size);\n        }\n\n        break;\n\n      case HalfFloatType:\n        var byteArray = new Uint16Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n        }\n\n        break;\n\n      default:\n        console.error('THREE.EXRLoader: unsupported type: ', this.type);\n        break;\n    }\n\n    var channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3\n    };\n    var compressionInfo = {\n      size: 0,\n      width: width,\n      lines: scanlineBlockSize,\n      offset: offset,\n      array: uInt8Array,\n      viewer: bufferDataView,\n      type: pixelType,\n      channels: EXRHeader.channels.length\n    };\n    var line;\n    var size;\n    var viewer;\n    var tmpOffset = {\n      value: 0\n    };\n\n    for (var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n      line = parseUint32(bufferDataView, offset); // line_no\n\n      size = parseUint32(bufferDataView, offset); // data_len\n\n      compressionInfo.lines = line + scanlineBlockSize > height ? height - line : scanlineBlockSize;\n      compressionInfo.offset = offset;\n      compressionInfo.size = size;\n      viewer = uncompress(compressionInfo);\n      offset.value += size;\n\n      for (var line_y = 0; line_y < scanlineBlockSize; line_y++) {\n        var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n        if (true_y >= height) break;\n\n        for (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n          var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (var x = 0; x < width; x++) {\n            var idx = line_y * (EXRHeader.channels.length * width) + channelID * width + x;\n            tmpOffset.value = idx * size_t;\n            var val = getValue(viewer, tmpOffset);\n            byteArray[(height - 1 - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n          }\n        }\n      }\n    }\n\n    if (this.type === UnsignedByteType) {\n      var v, _i11;\n\n      var _size = byteArray.length;\n      var RGBEArray = new Uint8Array(_size);\n\n      for (var h = 0; h < height; ++h) {\n        for (var w = 0; w < width; ++w) {\n          _i11 = h * width * 4 + w * 4;\n          var red = byteArray[_i11];\n          var green = byteArray[_i11 + 1];\n          var blue = byteArray[_i11 + 2];\n          v = red > green ? red : green;\n          v = blue > v ? blue : v;\n\n          if (v < 1e-32) {\n            RGBEArray[_i11] = RGBEArray[_i11 + 1] = RGBEArray[_i11 + 2] = RGBEArray[_i11 + 3] = 0;\n          } else {\n            var res = frexp(v);\n            v = res[0] * 256 / v;\n            RGBEArray[_i11] = red * v;\n            RGBEArray[_i11 + 1] = green * v;\n            RGBEArray[_i11 + 2] = blue * v;\n            RGBEArray[_i11 + 3] = res[1] + 128;\n          }\n        }\n      }\n\n      byteArray = RGBEArray;\n    }\n\n    var format = this.type === UnsignedByteType ? RGBEFormat : RGBAFormat;\n    return {\n      header: EXRHeader,\n      width: width,\n      height: height,\n      data: byteArray,\n      format: format,\n      type: this.type\n    };\n  },\n  setDataType: function setDataType(value) {\n    this.type = value;\n    return this;\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n\n        case FloatType:\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { EXRLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/EXRLoader.js"],"names":["DataTextureLoader","FloatType","HalfFloatType","UnsignedByteType","RGBEFormat","RGBAFormat","LinearEncoding","LinearFilter","RGBEEncoding","NearestFilter","DataUtils","unzlibSync","EXRLoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","tmpDataView","DataView","ArrayBuffer","frexp","value","setFloat64","bits","getUint32","exponent","mantissa","ldexp","steps","min","ceil","abs","result","i","floor","reverseLutFromBitmap","bitmap","lut","k","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","stop","decodeRunLength","size","byteLength","reader","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","tmpBufSize","scanlineBlockSize","EXRHeader","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","fflate","console","error","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseUlong","uLong","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","Uint8","int","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","undefined","bufferDataView","keepReading","attributeName","attributeType","attributeSize","attributeValue","warn","dataWindowHeight","dataWindow","uncompress","size_t","getValue","numBlocks","numChannels","byteArray","channelOffsets","R","G","B","A","compressionInfo","line","scanlineBlockIdx","line_y","true_y","channelID","cOff","val","v","RGBEArray","w","red","green","blue","res","format","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,SAA5B,EAAuCC,aAAvC,EAAsDC,gBAAtD,EAAwEC,UAAxE,EAAoFC,UAApF,EAAgGC,cAAhG,EAAgHC,YAAhH,EAA8HC,YAA9H,EAA4IC,aAA5I,EAA2JC,SAA3J,QAA4K,OAA5K;AACA,SAASC,UAAT,QAA2B,QAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAUC,OAAV,EAAmB;AACjCb,EAAAA,iBAAiB,CAACc,IAAlB,CAAuB,IAAvB,EAA6BD,OAA7B;AACA,OAAKE,IAAL,GAAYd,SAAZ;AACD,CAHD;;AAKAW,SAAS,CAACI,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAcnB,iBAAiB,CAACgB,SAAhC,CAAd,EAA0D;AAC9EI,EAAAA,WAAW,EAAER,SADiE;AAE9ES,EAAAA,KAAK,EAAE,eAAUC,MAAV,EAAkB;AACvB,QAAMC,YAAY,GAAG,KAAK,EAA1B;AACA,QAAMC,WAAW,GAAGD,YAAY,IAAI,CAApC;AACA,QAAME,WAAW,GAAG,EAApB,CAHuB,CAGC;;AAExB,QAAMC,WAAW,GAAG,EAApB,CALuB,CAKC;;AAExB,QAAMC,WAAW,GAAG,CAAC,KAAKF,WAAN,IAAqB,CAAzC,CAPuB,CAOqB;;AAE5C,QAAMG,WAAW,GAAG,KAAKF,WAAzB,CATuB,CASe;;AAEtC,QAAMG,WAAW,GAAGD,WAAW,GAAG,CAAlC;AACA,QAAME,KAAK,GAAG,EAAd;AACA,QAAMC,QAAQ,GAAG,KAAKD,KAAK,GAAG,CAA9B;AACA,QAAME,QAAQ,GAAG,CAAC,KAAKF,KAAN,IAAe,CAAhC;AACA,QAAMG,kBAAkB,GAAG,EAA3B;AACA,QAAMC,iBAAiB,GAAG,EAA1B;AACA,QAAMC,iBAAiB,GAAG,IAAID,iBAAJ,GAAwBD,kBAAlD;AACA,QAAMG,UAAU,GAAG,CAAnB;AACA,QAAMC,YAAY,GAAG,CAArB;AACA,QAAMC,UAAU,GAAG,CAAnB;AACA,QAAMC,UAAU,GAAG,CAAnB;AACA,QAAMC,SAAS,GAAG,CAAlB;AACA,QAAMC,cAAc,GAAG,CAAvB;AACA,QAAMC,OAAO,GAAG,CAAhB;AACA,QAAMC,OAAO,GAAG,CAAhB;AACA,QAAMC,SAAS,GAAG,CAAlB;AACA,QAAMC,GAAG,GAAG,CAAZ;AACA,QAAMC,OAAO,GAAGC,IAAI,CAACC,GAAL,CAAS,SAAT,EAAoB,GAApB,CAAhB;AACA,QAAIC,WAAW,GAAG,IAAIC,QAAJ,CAAa,IAAIC,WAAJ,CAAgB,CAAhB,CAAb,CAAlB;;AAEA,aAASC,KAAT,CAAeC,KAAf,EAAsB;AACpB,UAAIA,KAAK,KAAK,CAAd,EAAiB,OAAO,CAACA,KAAD,EAAQ,CAAR,CAAP;AACjBJ,MAAAA,WAAW,CAACK,UAAZ,CAAuB,CAAvB,EAA0BD,KAA1B;AACA,UAAIE,IAAI,GAAGN,WAAW,CAACO,SAAZ,CAAsB,CAAtB,MAA6B,EAA7B,GAAkC,KAA7C;;AAEA,UAAID,IAAI,KAAK,CAAb,EAAgB;AACd;AACAN,QAAAA,WAAW,CAACK,UAAZ,CAAuB,CAAvB,EAA0BD,KAAK,GAAGN,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAlC,EAFc,CAEsC;;AAEpDO,QAAAA,IAAI,GAAG,CAACN,WAAW,CAACO,SAAZ,CAAsB,CAAtB,MAA6B,EAA7B,GAAkC,KAAnC,IAA4C,EAAnD;AACD;;AAED,UAAIC,QAAQ,GAAGF,IAAI,GAAG,IAAtB;AACA,UAAIG,QAAQ,GAAGC,KAAK,CAACN,KAAD,EAAQ,CAACI,QAAT,CAApB;AACA,aAAO,CAACC,QAAD,EAAWD,QAAX,CAAP;AACD;;AAED,aAASE,KAAT,CAAeD,QAAf,EAAyBD,QAAzB,EAAmC;AACjC,UAAIG,KAAK,GAAGb,IAAI,CAACc,GAAL,CAAS,CAAT,EAAYd,IAAI,CAACe,IAAL,CAAUf,IAAI,CAACgB,GAAL,CAASN,QAAT,IAAqB,IAA/B,CAAZ,CAAZ;AACA,UAAIO,MAAM,GAAGN,QAAb;;AAEA,WAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAApB,EAA2BK,CAAC,EAA5B;AAAgCD,QAAAA,MAAM,IAAIjB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACmB,KAAL,CAAW,CAACT,QAAQ,GAAGQ,CAAZ,IAAiBL,KAA5B,CAAZ,CAAV;AAAhC;;AAEA,aAAOI,MAAP;AACD;;AAED,aAASG,oBAAT,CAA8BC,MAA9B,EAAsCC,GAAtC,EAA2C;AACzC,UAAIC,CAAC,GAAG,CAAR;;AAEA,WAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,YAApB,EAAkC,EAAE0C,CAApC,EAAuC;AACrC,YAAIA,CAAC,IAAI,CAAL,IAAUG,MAAM,CAACH,CAAC,IAAI,CAAN,CAAN,GAAiB,MAAMA,CAAC,GAAG,CAAV,CAA/B,EAA6C;AAC3CI,UAAAA,GAAG,CAACC,CAAC,EAAF,CAAH,GAAWL,CAAX;AACD;AACF;;AAED,UAAIM,CAAC,GAAGD,CAAC,GAAG,CAAZ;;AAEA,aAAOA,CAAC,GAAG/C,YAAX;AAAyB8C,QAAAA,GAAG,CAACC,CAAC,EAAF,CAAH,GAAW,CAAX;AAAzB;;AAEA,aAAOC,CAAP;AACD;;AAED,aAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,WAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrC,WAApB,EAAiCqC,CAAC,EAAlC,EAAsC;AACpCQ,QAAAA,IAAI,CAACR,CAAD,CAAJ,GAAU,EAAV;AACAQ,QAAAA,IAAI,CAACR,CAAD,CAAJ,CAAQS,GAAR,GAAc,CAAd;AACAD,QAAAA,IAAI,CAACR,CAAD,CAAJ,CAAQU,GAAR,GAAc,CAAd;AACAF,QAAAA,IAAI,CAACR,CAAD,CAAJ,CAAQW,CAAR,GAAY,IAAZ;AACD;AACF;;AAED,QAAMC,aAAa,GAAG;AACpBC,MAAAA,CAAC,EAAE,CADiB;AAEpBC,MAAAA,CAAC,EAAE,CAFiB;AAGpBC,MAAAA,EAAE,EAAE;AAHgB,KAAtB;;AAMA,aAASC,OAAT,CAAiBC,KAAjB,EAAwBH,CAAxB,EAA2BC,EAA3B,EAA+BG,UAA/B,EAA2CC,QAA3C,EAAqD;AACnD,aAAOJ,EAAE,GAAGE,KAAZ,EAAmB;AACjBH,QAAAA,CAAC,GAAGA,CAAC,IAAI,CAAL,GAASM,eAAe,CAACF,UAAD,EAAaC,QAAb,CAA5B;AACAJ,QAAAA,EAAE,IAAI,CAAN;AACD;;AAEDA,MAAAA,EAAE,IAAIE,KAAN;AACAL,MAAAA,aAAa,CAACC,CAAd,GAAkBC,CAAC,IAAIC,EAAL,GAAU,CAAC,KAAKE,KAAN,IAAe,CAA3C;AACAL,MAAAA,aAAa,CAACE,CAAd,GAAkBA,CAAlB;AACAF,MAAAA,aAAa,CAACG,EAAd,GAAmBA,EAAnB;AACD;;AAED,QAAMM,cAAc,GAAG,IAAIC,KAAJ,CAAU,EAAV,CAAvB;;AAEA,aAASC,qBAAT,CAA+BC,KAA/B,EAAsC;AACpC,WAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,EAArB,EAAyB,EAAEA,CAA3B;AAA8BqB,QAAAA,cAAc,CAACrB,CAAD,CAAd,GAAoB,CAApB;AAA9B;;AAEA,WAAK,IAAIA,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGtC,WAApB,EAAiC,EAAEsC,EAAnC;AAAsCqB,QAAAA,cAAc,CAACG,KAAK,CAACxB,EAAD,CAAN,CAAd,IAA4B,CAA5B;AAAtC;;AAEA,UAAIc,CAAC,GAAG,CAAR;;AAEA,WAAK,IAAId,GAAC,GAAG,EAAb,EAAiBA,GAAC,GAAG,CAArB,EAAwB,EAAEA,GAA1B,EAA6B;AAC3B,YAAIyB,EAAE,GAAGX,CAAC,GAAGO,cAAc,CAACrB,GAAD,CAAlB,IAAyB,CAAlC;AACAqB,QAAAA,cAAc,CAACrB,GAAD,CAAd,GAAoBc,CAApB;AACAA,QAAAA,CAAC,GAAGW,EAAJ;AACD;;AAED,WAAK,IAAIzB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGtC,WAApB,EAAiC,EAAEsC,GAAnC,EAAsC;AACpC,YAAIa,CAAC,GAAGW,KAAK,CAACxB,GAAD,CAAb;AACA,YAAIa,CAAC,GAAG,CAAR,EAAWW,KAAK,CAACxB,GAAD,CAAL,GAAWa,CAAC,GAAGQ,cAAc,CAACR,CAAD,CAAd,MAAuB,CAAtC;AACZ;AACF;;AAED,aAASa,iBAAT,CAA2BR,UAA3B,EAAuCS,UAAvC,EAAmDR,QAAnD,EAA6DS,EAA7D,EAAiEC,EAAjE,EAAqEC,EAArE,EAAyEN,KAAzE,EAAgF;AAC9E,UAAIb,CAAC,GAAGQ,QAAR;AACA,UAAIL,CAAC,GAAG,CAAR;AACA,UAAIC,EAAE,GAAG,CAAT;;AAEA,aAAOc,EAAE,IAAIC,EAAb,EAAiBD,EAAE,EAAnB,EAAuB;AACrB,YAAIlB,CAAC,CAACvB,KAAF,GAAU+B,QAAQ,CAAC/B,KAAnB,GAA2BwC,EAA/B,EAAmC,OAAO,KAAP;AACnCZ,QAAAA,OAAO,CAAC,CAAD,EAAIF,CAAJ,EAAOC,EAAP,EAAWG,UAAX,EAAuBP,CAAvB,CAAP;AACA,YAAIE,CAAC,GAAGD,aAAa,CAACC,CAAtB;AACAC,QAAAA,CAAC,GAAGF,aAAa,CAACE,CAAlB;AACAC,QAAAA,EAAE,GAAGH,aAAa,CAACG,EAAnB;AACAS,QAAAA,KAAK,CAACK,EAAD,CAAL,GAAYhB,CAAZ;;AAEA,YAAIA,CAAC,IAAI5C,iBAAT,EAA4B;AAC1B,cAAI0C,CAAC,CAACvB,KAAF,GAAU+B,QAAQ,CAAC/B,KAAnB,GAA2BwC,EAA/B,EAAmC;AACjC,kBAAM,wCAAN;AACD;;AAEDZ,UAAAA,OAAO,CAAC,CAAD,EAAIF,CAAJ,EAAOC,EAAP,EAAWG,UAAX,EAAuBP,CAAvB,CAAP;AACA,cAAIoB,KAAK,GAAGnB,aAAa,CAACC,CAAd,GAAkB3C,iBAA9B;AACA4C,UAAAA,CAAC,GAAGF,aAAa,CAACE,CAAlB;AACAC,UAAAA,EAAE,GAAGH,aAAa,CAACG,EAAnB;;AAEA,cAAIc,EAAE,GAAGE,KAAL,GAAaD,EAAE,GAAG,CAAtB,EAAyB;AACvB,kBAAM,wCAAN;AACD;;AAED,iBAAOC,KAAK,EAAZ;AAAgBP,YAAAA,KAAK,CAACK,EAAE,EAAH,CAAL,GAAc,CAAd;AAAhB;;AAEAA,UAAAA,EAAE;AACH,SAjBD,MAiBO,IAAIhB,CAAC,IAAI7C,kBAAT,EAA6B;AAClC,cAAI+D,KAAK,GAAGlB,CAAC,GAAG7C,kBAAJ,GAAyB,CAArC;;AAEA,cAAI6D,EAAE,GAAGE,KAAL,GAAaD,EAAE,GAAG,CAAtB,EAAyB;AACvB,kBAAM,wCAAN;AACD;;AAED,iBAAOC,KAAK,EAAZ;AAAgBP,YAAAA,KAAK,CAACK,EAAE,EAAH,CAAL,GAAc,CAAd;AAAhB;;AAEAA,UAAAA,EAAE;AACH;AACF;;AAEDN,MAAAA,qBAAqB,CAACC,KAAD,CAArB;AACD;;AAED,aAASQ,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,aAAOA,IAAI,GAAG,EAAd;AACD;;AAED,aAASC,OAAT,CAAiBD,IAAjB,EAAuB;AACrB,aAAOA,IAAI,IAAI,CAAf;AACD;;AAED,aAASE,gBAAT,CAA0BX,KAA1B,EAAiCK,EAAjC,EAAqCC,EAArC,EAAyCM,MAAzC,EAAiD;AAC/C,aAAOP,EAAE,IAAIC,EAAb,EAAiBD,EAAE,EAAnB,EAAuB;AACrB,YAAIf,CAAC,GAAGoB,OAAO,CAACV,KAAK,CAACK,EAAD,CAAN,CAAf;AACA,YAAIhB,CAAC,GAAGmB,SAAS,CAACR,KAAK,CAACK,EAAD,CAAN,CAAjB;;AAEA,YAAIf,CAAC,IAAID,CAAT,EAAY;AACV,gBAAM,qBAAN;AACD;;AAED,YAAIA,CAAC,GAAGpD,WAAR,EAAqB;AACnB,cAAI4E,EAAE,GAAGD,MAAM,CAACtB,CAAC,IAAID,CAAC,GAAGpD,WAAV,CAAf;;AAEA,cAAI4E,EAAE,CAAC5B,GAAP,EAAY;AACV,kBAAM,qBAAN;AACD;;AAED4B,UAAAA,EAAE,CAAC3B,GAAH;;AAEA,cAAI2B,EAAE,CAAC1B,CAAP,EAAU;AACR,gBAAIA,CAAC,GAAG0B,EAAE,CAAC1B,CAAX;AACA0B,YAAAA,EAAE,CAAC1B,CAAH,GAAO,IAAIW,KAAJ,CAAUe,EAAE,CAAC3B,GAAb,CAAP;;AAEA,iBAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,EAAE,CAAC3B,GAAH,GAAS,CAA7B,EAAgC,EAAEV,CAAlC,EAAqC;AACnCqC,cAAAA,EAAE,CAAC1B,CAAH,CAAKX,CAAL,IAAUW,CAAC,CAACX,CAAD,CAAX;AACD;AACF,WAPD,MAOO;AACLqC,YAAAA,EAAE,CAAC1B,CAAH,GAAO,IAAIW,KAAJ,CAAU,CAAV,CAAP;AACD;;AAEDe,UAAAA,EAAE,CAAC1B,CAAH,CAAK0B,EAAE,CAAC3B,GAAH,GAAS,CAAd,IAAmBmB,EAAnB;AACD,SArBD,MAqBO,IAAIhB,CAAJ,EAAO;AACZ,cAAIyB,QAAQ,GAAG,CAAf;;AAEA,eAAK,IAAItC,GAAC,GAAG,KAAKvC,WAAW,GAAGoD,CAAhC,EAAmCb,GAAC,GAAG,CAAvC,EAA0CA,GAAC,EAA3C,EAA+C;AAC7C,gBAAIqC,EAAE,GAAGD,MAAM,CAAC,CAACtB,CAAC,IAAIrD,WAAW,GAAGoD,CAApB,IAAyByB,QAA1B,CAAf;;AAEA,gBAAID,EAAE,CAAC5B,GAAH,IAAU4B,EAAE,CAAC1B,CAAjB,EAAoB;AAClB,oBAAM,qBAAN;AACD;;AAED0B,YAAAA,EAAE,CAAC5B,GAAH,GAASI,CAAT;AACAwB,YAAAA,EAAE,CAAC3B,GAAH,GAASmB,EAAT;AACAS,YAAAA,QAAQ;AACT;AACF;AACF;;AAED,aAAO,IAAP;AACD;;AAED,QAAMC,aAAa,GAAG;AACpBzB,MAAAA,CAAC,EAAE,CADiB;AAEpBC,MAAAA,EAAE,EAAE;AAFgB,KAAtB;;AAKA,aAASyB,OAAT,CAAiB1B,CAAjB,EAAoBC,EAApB,EAAwBG,UAAxB,EAAoCC,QAApC,EAA8C;AAC5CL,MAAAA,CAAC,GAAGA,CAAC,IAAI,CAAL,GAASM,eAAe,CAACF,UAAD,EAAaC,QAAb,CAA5B;AACAJ,MAAAA,EAAE,IAAI,CAAN;AACAwB,MAAAA,aAAa,CAACzB,CAAd,GAAkBA,CAAlB;AACAyB,MAAAA,aAAa,CAACxB,EAAd,GAAmBA,EAAnB;AACD;;AAED,QAAM0B,aAAa,GAAG;AACpB3B,MAAAA,CAAC,EAAE,CADiB;AAEpBC,MAAAA,EAAE,EAAE;AAFgB,KAAtB;;AAKA,aAAS2B,OAAT,CAAiBC,EAAjB,EAAqBC,GAArB,EAA0B9B,CAA1B,EAA6BC,EAA7B,EAAiCG,UAAjC,EAA6CS,UAA7C,EAAyDR,QAAzD,EAAmE0B,SAAnE,EAA8EC,eAA9E,EAA+FC,kBAA/F,EAAmH;AACjH,UAAIJ,EAAE,IAAIC,GAAV,EAAe;AACb,YAAI7B,EAAE,GAAG,CAAT,EAAY;AACVyB,UAAAA,OAAO,CAAC1B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,UAAAA,CAAC,GAAGyB,aAAa,CAACzB,CAAlB;AACAC,UAAAA,EAAE,GAAGwB,aAAa,CAACxB,EAAnB;AACD;;AAEDA,QAAAA,EAAE,IAAI,CAAN;AACA,YAAIiC,EAAE,GAAGlC,CAAC,IAAIC,EAAd;AACA,YAAIiC,EAAE,GAAG,IAAIC,UAAJ,CAAe,CAACD,EAAD,CAAf,EAAqB,CAArB,CAAT;;AAEA,YAAIF,eAAe,CAAC1D,KAAhB,GAAwB4D,EAAxB,GAA6BD,kBAAjC,EAAqD;AACnD,iBAAO,KAAP;AACD;;AAED,YAAIG,CAAC,GAAGL,SAAS,CAACC,eAAe,CAAC1D,KAAhB,GAAwB,CAAzB,CAAjB;;AAEA,eAAO4D,EAAE,KAAK,CAAd,EAAiB;AACfH,UAAAA,SAAS,CAACC,eAAe,CAAC1D,KAAhB,EAAD,CAAT,GAAqC8D,CAArC;AACD;AACF,OApBD,MAoBO,IAAIJ,eAAe,CAAC1D,KAAhB,GAAwB2D,kBAA5B,EAAgD;AACrDF,QAAAA,SAAS,CAACC,eAAe,CAAC1D,KAAhB,EAAD,CAAT,GAAqCuD,EAArC;AACD,OAFM,MAEA;AACL,eAAO,KAAP;AACD;;AAEDF,MAAAA,aAAa,CAAC3B,CAAd,GAAkBA,CAAlB;AACA2B,MAAAA,aAAa,CAAC1B,EAAd,GAAmBA,EAAnB;AACD;;AAED,aAASoC,MAAT,CAAgB/D,KAAhB,EAAuB;AACrB,aAAOA,KAAK,GAAG,MAAf;AACD;;AAED,aAASgE,KAAT,CAAehE,KAAf,EAAsB;AACpB,UAAIiE,GAAG,GAAGF,MAAM,CAAC/D,KAAD,CAAhB;AACA,aAAOiE,GAAG,GAAG,MAAN,GAAeA,GAAG,GAAG,OAArB,GAA+BA,GAAtC;AACD;;AAED,QAAMC,YAAY,GAAG;AACnBC,MAAAA,CAAC,EAAE,CADgB;AAEnBC,MAAAA,CAAC,EAAE;AAFgB,KAArB;;AAKA,aAASC,MAAT,CAAgB5C,CAAhB,EAAmB6C,CAAnB,EAAsB;AACpB,UAAIC,EAAE,GAAGP,KAAK,CAACvC,CAAD,CAAd;AACA,UAAI+C,EAAE,GAAGR,KAAK,CAACM,CAAD,CAAd;AACA,UAAIG,EAAE,GAAGD,EAAT;AACA,UAAIE,EAAE,GAAGH,EAAE,IAAIE,EAAE,GAAG,CAAT,CAAF,IAAiBA,EAAE,IAAI,CAAvB,CAAT;AACA,UAAIE,EAAE,GAAGD,EAAT;AACA,UAAIE,EAAE,GAAGF,EAAE,GAAGD,EAAd;AACAP,MAAAA,YAAY,CAACC,CAAb,GAAiBQ,EAAjB;AACAT,MAAAA,YAAY,CAACE,CAAb,GAAiBQ,EAAjB;AACD;;AAED,aAASC,MAAT,CAAgBpD,CAAhB,EAAmB6C,CAAnB,EAAsB;AACpB,UAAIQ,CAAC,GAAGf,MAAM,CAACtC,CAAD,CAAd;AACA,UAAIsD,CAAC,GAAGhB,MAAM,CAACO,CAAD,CAAd;AACA,UAAIU,EAAE,GAAGF,CAAC,IAAIC,CAAC,IAAI,CAAT,CAAD,GAAepG,QAAxB;AACA,UAAIsG,EAAE,GAAGF,CAAC,GAAGC,EAAJ,GAAStG,QAAT,GAAoBC,QAA7B;AACAuF,MAAAA,YAAY,CAACC,CAAb,GAAiBc,EAAjB;AACAf,MAAAA,YAAY,CAACE,CAAb,GAAiBY,EAAjB;AACD;;AAED,aAASE,UAAT,CAAoBjH,MAApB,EAA4BkH,CAA5B,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuCC,EAAvC,EAA2CC,EAA3C,EAA+CC,EAA/C,EAAmD;AACjD,UAAIC,GAAG,GAAGD,EAAE,GAAG,KAAK,EAApB;AACA,UAAItE,CAAC,GAAGkE,EAAE,GAAGE,EAAL,GAAUA,EAAV,GAAeF,EAAvB;AACA,UAAI7D,CAAC,GAAG,CAAR;AACA,UAAImE,EAAJ;;AAEA,aAAOnE,CAAC,IAAIL,CAAZ;AAAeK,QAAAA,CAAC,KAAK,CAAN;AAAf;;AAEAA,MAAAA,CAAC,KAAK,CAAN;AACAmE,MAAAA,EAAE,GAAGnE,CAAL;AACAA,MAAAA,CAAC,KAAK,CAAN;;AAEA,aAAOA,CAAC,IAAI,CAAZ,EAAe;AACb,YAAIoE,EAAE,GAAG,CAAT;AACA,YAAIC,EAAE,GAAGD,EAAE,GAAGJ,EAAE,IAAID,EAAE,GAAGI,EAAT,CAAhB;AACA,YAAIG,GAAG,GAAGN,EAAE,GAAGhE,CAAf;AACA,YAAIuE,GAAG,GAAGP,EAAE,GAAGG,EAAf;AACA,YAAIK,GAAG,GAAGV,EAAE,GAAG9D,CAAf;AACA,YAAIyE,GAAG,GAAGX,EAAE,GAAGK,EAAf;AACA,YAAIO,GAAJ,EAASC,GAAT,EAAcC,GAAd,EAAmBC,GAAnB;;AAEA,eAAOT,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIG,GAAvB,EAA4B;AAC1B,cAAIO,EAAE,GAAGV,EAAT;AACA,cAAIW,EAAE,GAAGX,EAAE,GAAGN,EAAE,IAAID,EAAE,GAAGM,EAAT,CAAhB;;AAEA,iBAAOW,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIL,GAAvB,EAA4B;AAC1B,gBAAIO,GAAG,GAAGF,EAAE,GAAGN,GAAf;AACA,gBAAIS,GAAG,GAAGH,EAAE,GAAGR,GAAf;AACA,gBAAIY,GAAG,GAAGD,GAAG,GAAGT,GAAhB;;AAEA,gBAAIN,GAAJ,EAAS;AACPpB,cAAAA,MAAM,CAACpG,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACAc,cAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAgC,cAAAA,GAAG,GAAGjC,YAAY,CAACE,CAAnB;AACAC,cAAAA,MAAM,CAACpG,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAP,EAAkBlH,MAAM,CAACwI,GAAG,GAAGtB,CAAP,CAAxB,CAAN;AACAe,cAAAA,GAAG,GAAGhC,YAAY,CAACC,CAAnB;AACAiC,cAAAA,GAAG,GAAGlC,YAAY,CAACE,CAAnB;AACAC,cAAAA,MAAM,CAAC4B,GAAD,EAAMC,GAAN,CAAN;AACAjI,cAAAA,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAN,GAAiBjB,YAAY,CAACC,CAA9B;AACAlG,cAAAA,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAC,cAAAA,MAAM,CAAC8B,GAAD,EAAMC,GAAN,CAAN;AACAnI,cAAAA,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACC,CAA/B;AACAlG,cAAAA,MAAM,CAACwI,GAAG,GAAGtB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACD,aAbD,MAaO;AACLS,cAAAA,MAAM,CAAC5G,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACAc,cAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAgC,cAAAA,GAAG,GAAGjC,YAAY,CAACE,CAAnB;AACAS,cAAAA,MAAM,CAAC5G,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAP,EAAkBlH,MAAM,CAACwI,GAAG,GAAGtB,CAAP,CAAxB,CAAN;AACAe,cAAAA,GAAG,GAAGhC,YAAY,CAACC,CAAnB;AACAiC,cAAAA,GAAG,GAAGlC,YAAY,CAACE,CAAnB;AACAS,cAAAA,MAAM,CAACoB,GAAD,EAAMC,GAAN,CAAN;AACAjI,cAAAA,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAN,GAAiBjB,YAAY,CAACC,CAA9B;AACAlG,cAAAA,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAS,cAAAA,MAAM,CAACsB,GAAD,EAAMC,GAAN,CAAN;AACAnI,cAAAA,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACC,CAA/B;AACAlG,cAAAA,MAAM,CAACwI,GAAG,GAAGtB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACD;AACF;;AAED,cAAIgB,EAAE,GAAG7D,CAAT,EAAY;AACV,gBAAIiF,GAAG,GAAGH,EAAE,GAAGR,GAAf;AACA,gBAAIJ,GAAJ,EAASpB,MAAM,CAACpG,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAvB,CAAN,CAAT,KAAsDN,MAAM,CAAC5G,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAvB,CAAN;AACtDc,YAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAlG,YAAAA,MAAM,CAACuI,GAAG,GAAGrB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAnG,YAAAA,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAN,GAAiBc,GAAjB;AACD;AACF;;AAED,YAAIX,EAAE,GAAG/D,CAAT,EAAY;AACV,cAAI8E,EAAE,GAAGV,EAAT;AACA,cAAIW,EAAE,GAAGX,EAAE,GAAGN,EAAE,IAAID,EAAE,GAAGM,EAAT,CAAhB;;AAEA,iBAAOW,EAAE,IAAIC,EAAb,EAAiBD,EAAE,IAAIL,GAAvB,EAA4B;AAC1B,gBAAIO,GAAG,GAAGF,EAAE,GAAGN,GAAf;AACA,gBAAIN,GAAJ,EAASpB,MAAM,CAACpG,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAvB,CAAN,CAAT,KAAsDN,MAAM,CAAC5G,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAP,EAAiBlH,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAvB,CAAN;AACtDc,YAAAA,GAAG,GAAG/B,YAAY,CAACC,CAAnB;AACAlG,YAAAA,MAAM,CAACsI,GAAG,GAAGpB,CAAP,CAAN,GAAkBjB,YAAY,CAACE,CAA/B;AACAnG,YAAAA,MAAM,CAACoI,EAAE,GAAGlB,CAAN,CAAN,GAAiBc,GAAjB;AACD;AACF;;AAEDP,QAAAA,EAAE,GAAGnE,CAAL;AACAA,QAAAA,CAAC,KAAK,CAAN;AACD;;AAED,aAAOoE,EAAP;AACD;;AAED,aAASe,SAAT,CAAmBC,aAAnB,EAAkCC,aAAlC,EAAiD9E,UAAjD,EAA6DS,UAA7D,EAAyER,QAAzE,EAAmFS,EAAnF,EAAuFgB,GAAvF,EAA4FqD,EAA5F,EAAgGpD,SAAhG,EAA2GqD,SAA3G,EAAsH;AACpH,UAAIpF,CAAC,GAAG,CAAR;AACA,UAAIC,EAAE,GAAG,CAAT;AACA,UAAIgC,kBAAkB,GAAGkD,EAAzB;AACA,UAAIE,WAAW,GAAGrH,IAAI,CAACsH,KAAL,CAAWjF,QAAQ,CAAC/B,KAAT,GAAiB,CAACwC,EAAE,GAAG,CAAN,IAAW,CAAvC,CAAlB;;AAEA,aAAOT,QAAQ,CAAC/B,KAAT,GAAiB+G,WAAxB,EAAqC;AACnC3D,QAAAA,OAAO,CAAC1B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,QAAAA,CAAC,GAAGyB,aAAa,CAACzB,CAAlB;AACAC,QAAAA,EAAE,GAAGwB,aAAa,CAACxB,EAAnB;;AAEA,eAAOA,EAAE,IAAItD,WAAb,EAA0B;AACxB,cAAI4I,KAAK,GAAGvF,CAAC,IAAIC,EAAE,GAAGtD,WAAV,GAAwBG,WAApC;AACA,cAAIyE,EAAE,GAAG2D,aAAa,CAACK,KAAD,CAAtB;;AAEA,cAAIhE,EAAE,CAAC5B,GAAP,EAAY;AACVM,YAAAA,EAAE,IAAIsB,EAAE,CAAC5B,GAAT;AACAiC,YAAAA,OAAO,CAACL,EAAE,CAAC3B,GAAJ,EAASkC,GAAT,EAAc9B,CAAd,EAAiBC,EAAjB,EAAqBG,UAArB,EAAiCS,UAAjC,EAA6CR,QAA7C,EAAuD0B,SAAvD,EAAkEqD,SAAlE,EAA6EnD,kBAA7E,CAAP;AACAjC,YAAAA,CAAC,GAAG2B,aAAa,CAAC3B,CAAlB;AACAC,YAAAA,EAAE,GAAG0B,aAAa,CAAC1B,EAAnB;AACD,WALD,MAKO;AACL,gBAAI,CAACsB,EAAE,CAAC1B,CAAR,EAAW;AACT,oBAAM,kBAAN;AACD;;AAED,gBAAI4D,CAAJ;;AAEA,iBAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGlC,EAAE,CAAC3B,GAAnB,EAAwB6D,CAAC,EAAzB,EAA6B;AAC3B,kBAAI1D,CAAC,GAAGmB,SAAS,CAAC+D,aAAa,CAAC1D,EAAE,CAAC1B,CAAH,CAAK4D,CAAL,CAAD,CAAd,CAAjB;;AAEA,qBAAOxD,EAAE,GAAGF,CAAL,IAAUM,QAAQ,CAAC/B,KAAT,GAAiB+G,WAAlC,EAA+C;AAC7C3D,gBAAAA,OAAO,CAAC1B,CAAD,EAAIC,EAAJ,EAAQG,UAAR,EAAoBC,QAApB,CAAP;AACAL,gBAAAA,CAAC,GAAGyB,aAAa,CAACzB,CAAlB;AACAC,gBAAAA,EAAE,GAAGwB,aAAa,CAACxB,EAAnB;AACD;;AAED,kBAAIA,EAAE,IAAIF,CAAV,EAAa;AACX,oBAAIqB,OAAO,CAAC6D,aAAa,CAAC1D,EAAE,CAAC1B,CAAH,CAAK4D,CAAL,CAAD,CAAd,CAAP,KAAoCzD,CAAC,IAAIC,EAAE,GAAGF,CAAV,GAAc,CAAC,KAAKA,CAAN,IAAW,CAA7D,CAAJ,EAAqE;AACnEE,kBAAAA,EAAE,IAAIF,CAAN;AACA6B,kBAAAA,OAAO,CAACL,EAAE,CAAC1B,CAAH,CAAK4D,CAAL,CAAD,EAAU3B,GAAV,EAAe9B,CAAf,EAAkBC,EAAlB,EAAsBG,UAAtB,EAAkCS,UAAlC,EAA8CR,QAA9C,EAAwD0B,SAAxD,EAAmEqD,SAAnE,EAA8EnD,kBAA9E,CAAP;AACAjC,kBAAAA,CAAC,GAAG2B,aAAa,CAAC3B,CAAlB;AACAC,kBAAAA,EAAE,GAAG0B,aAAa,CAAC1B,EAAnB;AACA;AACD;AACF;AACF;;AAED,gBAAIwD,CAAC,IAAIlC,EAAE,CAAC3B,GAAZ,EAAiB;AACf,oBAAM,kBAAN;AACD;AACF;AACF;AACF;;AAED,UAAIV,CAAC,GAAG,IAAI4B,EAAJ,GAAS,CAAjB;AACAd,MAAAA,CAAC,KAAKd,CAAN;AACAe,MAAAA,EAAE,IAAIf,CAAN;;AAEA,aAAOe,EAAE,GAAG,CAAZ,EAAe;AACb,YAAIsB,EAAE,GAAG2D,aAAa,CAAClF,CAAC,IAAIrD,WAAW,GAAGsD,EAAnB,GAAwBnD,WAAzB,CAAtB;;AAEA,YAAIyE,EAAE,CAAC5B,GAAP,EAAY;AACVM,UAAAA,EAAE,IAAIsB,EAAE,CAAC5B,GAAT;AACAiC,UAAAA,OAAO,CAACL,EAAE,CAAC3B,GAAJ,EAASkC,GAAT,EAAc9B,CAAd,EAAiBC,EAAjB,EAAqBG,UAArB,EAAiCS,UAAjC,EAA6CR,QAA7C,EAAuD0B,SAAvD,EAAkEqD,SAAlE,EAA6EnD,kBAA7E,CAAP;AACAjC,UAAAA,CAAC,GAAG2B,aAAa,CAAC3B,CAAlB;AACAC,UAAAA,EAAE,GAAG0B,aAAa,CAAC1B,EAAnB;AACD,SALD,MAKO;AACL,gBAAM,kBAAN;AACD;AACF;;AAED,aAAO,IAAP;AACD;;AAED,aAASuF,aAAT,CAAuBpF,UAAvB,EAAmCS,UAAnC,EAA+CR,QAA/C,EAAyDoF,WAAzD,EAAsE1D,SAAtE,EAAiF2D,IAAjF,EAAuF;AACrF,UAAIN,SAAS,GAAG;AACd9G,QAAAA,KAAK,EAAE;AADO,OAAhB;AAGA,UAAIqH,eAAe,GAAGtF,QAAQ,CAAC/B,KAA/B;AACA,UAAIyC,EAAE,GAAG6E,WAAW,CAAC/E,UAAD,EAAaR,QAAb,CAApB;AACA,UAAIW,EAAE,GAAG4E,WAAW,CAAC/E,UAAD,EAAaR,QAAb,CAApB;AACAA,MAAAA,QAAQ,CAAC/B,KAAT,IAAkB,CAAlB;AACA,UAAI6B,KAAK,GAAGyF,WAAW,CAAC/E,UAAD,EAAaR,QAAb,CAAvB;AACAA,MAAAA,QAAQ,CAAC/B,KAAT,IAAkB,CAAlB;;AAEA,UAAIyC,EAAE,GAAG,CAAL,IAAUA,EAAE,IAAInE,WAAhB,IAA+BoE,EAAE,GAAG,CAApC,IAAyCA,EAAE,IAAIpE,WAAnD,EAAgE;AAC9D,cAAM,kCAAN;AACD;;AAED,UAAIiJ,IAAI,GAAG,IAAIrF,KAAJ,CAAU5D,WAAV,CAAX;AACA,UAAI8C,IAAI,GAAG,IAAIc,KAAJ,CAAU3D,WAAV,CAAX;AACA4C,MAAAA,gBAAgB,CAACC,IAAD,CAAhB;AACA,UAAIoB,EAAE,GAAG2E,WAAW,IAAIpF,QAAQ,CAAC/B,KAAT,GAAiBqH,eAArB,CAApB;AACA/E,MAAAA,iBAAiB,CAACR,UAAD,EAAaS,UAAb,EAAyBR,QAAzB,EAAmCS,EAAnC,EAAuCC,EAAvC,EAA2CC,EAA3C,EAA+C6E,IAA/C,CAAjB;;AAEA,UAAI1F,KAAK,GAAG,KAAKsF,WAAW,IAAIpF,QAAQ,CAAC/B,KAAT,GAAiBqH,eAArB,CAAhB,CAAZ,EAAoE;AAClE,cAAM,oCAAN;AACD;;AAEDtE,MAAAA,gBAAgB,CAACwE,IAAD,EAAO9E,EAAP,EAAWC,EAAX,EAAetB,IAAf,CAAhB;AACAsF,MAAAA,SAAS,CAACa,IAAD,EAAOnG,IAAP,EAAaU,UAAb,EAAyBS,UAAzB,EAAqCR,QAArC,EAA+CF,KAA/C,EAAsDa,EAAtD,EAA0D0E,IAA1D,EAAgE3D,SAAhE,EAA2EqD,SAA3E,CAAT;AACD;;AAED,aAASU,QAAT,CAAkBxG,GAAlB,EAAuByG,IAAvB,EAA6BC,KAA7B,EAAoC;AAClC,WAAK,IAAI9G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8G,KAApB,EAA2B,EAAE9G,CAA7B,EAAgC;AAC9B6G,QAAAA,IAAI,CAAC7G,CAAD,CAAJ,GAAUI,GAAG,CAACyG,IAAI,CAAC7G,CAAD,CAAL,CAAb;AACD;AACF;;AAED,aAAS+G,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAACE,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,YAAI9C,CAAC,GAAG6C,MAAM,CAACC,CAAC,GAAG,CAAL,CAAN,GAAgBD,MAAM,CAACC,CAAD,CAAtB,GAA4B,GAApC;AACAD,QAAAA,MAAM,CAACC,CAAD,CAAN,GAAY9C,CAAZ;AACD;AACF;;AAED,aAASgD,gBAAT,CAA0BH,MAA1B,EAAkCI,GAAlC,EAAuC;AACrC,UAAIC,EAAE,GAAG,CAAT;AACA,UAAIC,EAAE,GAAGxI,IAAI,CAACmB,KAAL,CAAW,CAAC+G,MAAM,CAACE,MAAP,GAAgB,CAAjB,IAAsB,CAAjC,CAAT;AACA,UAAIhE,CAAC,GAAG,CAAR;AACA,UAAIqE,IAAI,GAAGP,MAAM,CAACE,MAAP,GAAgB,CAA3B;;AAEA,aAAO,IAAP,EAAa;AACX,YAAIhE,CAAC,GAAGqE,IAAR,EAAc;AACdH,QAAAA,GAAG,CAAClE,CAAC,EAAF,CAAH,GAAW8D,MAAM,CAACK,EAAE,EAAH,CAAjB;AACA,YAAInE,CAAC,GAAGqE,IAAR,EAAc;AACdH,QAAAA,GAAG,CAAClE,CAAC,EAAF,CAAH,GAAW8D,MAAM,CAACM,EAAE,EAAH,CAAjB;AACD;AACF;;AAED,aAASE,eAAT,CAAyBR,MAAzB,EAAiC;AAC/B,UAAIS,IAAI,GAAGT,MAAM,CAACU,UAAlB;AACA,UAAIN,GAAG,GAAG,IAAI9F,KAAJ,EAAV;AACA,UAAIX,CAAC,GAAG,CAAR;AACA,UAAIgH,MAAM,GAAG,IAAI1I,QAAJ,CAAa+H,MAAb,CAAb;;AAEA,aAAOS,IAAI,GAAG,CAAd,EAAiB;AACf,YAAI5G,CAAC,GAAG8G,MAAM,CAACC,OAAP,CAAejH,CAAC,EAAhB,CAAR;;AAEA,YAAIE,CAAC,GAAG,CAAR,EAAW;AACT,cAAIgH,KAAK,GAAG,CAAChH,CAAb;AACA4G,UAAAA,IAAI,IAAII,KAAK,GAAG,CAAhB;;AAEA,eAAK,IAAI7H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6H,KAApB,EAA2B7H,CAAC,EAA5B,EAAgC;AAC9BoH,YAAAA,GAAG,CAACU,IAAJ,CAASH,MAAM,CAACI,QAAP,CAAgBpH,CAAC,EAAjB,CAAT;AACD;AACF,SAPD,MAOO;AACL,cAAIkH,KAAK,GAAGhH,CAAZ;AACA4G,UAAAA,IAAI,IAAI,CAAR;AACA,cAAIrI,KAAK,GAAGuI,MAAM,CAACI,QAAP,CAAgBpH,CAAC,EAAjB,CAAZ;;AAEA,eAAK,IAAIX,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG6H,KAAK,GAAG,CAA5B,EAA+B7H,GAAC,EAAhC,EAAoC;AAClCoH,YAAAA,GAAG,CAACU,IAAJ,CAAS1I,KAAT;AACD;AACF;AACF;;AAED,aAAOgI,GAAP;AACD;;AAED,aAASY,cAAT,CAAwBC,MAAxB,EAAgCC,OAAhC,EAAyCC,WAAzC,EAAsDC,QAAtD,EAAgEC,QAAhE,EAA0ExF,SAA1E,EAAqF;AACnF,UAAIyF,QAAQ,GAAG,IAAIrJ,QAAJ,CAAa4D,SAAS,CAACxF,MAAvB,CAAf;AACA,UAAIkL,KAAK,GAAGJ,WAAW,CAACF,MAAM,CAACO,GAAP,CAAW,CAAX,CAAD,CAAX,CAA2BD,KAAvC;AACA,UAAIE,MAAM,GAAGN,WAAW,CAACF,MAAM,CAACO,GAAP,CAAW,CAAX,CAAD,CAAX,CAA2BC,MAAxC;AACA,UAAIC,OAAO,GAAG,CAAd;AACA,UAAIC,cAAc,GAAG7J,IAAI,CAACmB,KAAL,CAAWsI,KAAK,GAAG,GAAnB,CAArB;AACA,UAAIK,UAAU,GAAG9J,IAAI,CAACe,IAAL,CAAU0I,KAAK,GAAG,GAAlB,CAAjB;AACA,UAAIM,UAAU,GAAG/J,IAAI,CAACe,IAAL,CAAU4I,MAAM,GAAG,GAAnB,CAAjB;AACA,UAAIK,SAAS,GAAGP,KAAK,GAAG,CAACK,UAAU,GAAG,CAAd,IAAmB,CAA3C;AACA,UAAIG,SAAS,GAAGN,MAAM,GAAG,CAACI,UAAU,GAAG,CAAd,IAAmB,CAA5C;AACA,UAAIG,UAAU,GAAG;AACf5J,QAAAA,KAAK,EAAE;AADQ,OAAjB;AAGA,UAAI6J,UAAU,GAAG,IAAI3H,KAAJ,CAAUoH,OAAV,CAAjB;AACA,UAAIQ,OAAO,GAAG,IAAI5H,KAAJ,CAAUoH,OAAV,CAAd;AACA,UAAIS,YAAY,GAAG,IAAI7H,KAAJ,CAAUoH,OAAV,CAAnB;AACA,UAAIU,QAAQ,GAAG,IAAI9H,KAAJ,CAAUoH,OAAV,CAAf;AACA,UAAIW,UAAU,GAAG,IAAI/H,KAAJ,CAAUoH,OAAV,CAAjB;;AAEA,WAAK,IAAIY,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGZ,OAA1B,EAAmC,EAAEY,IAArC,EAA2C;AACzCD,QAAAA,UAAU,CAACC,IAAD,CAAV,GAAmBpB,OAAO,CAACD,MAAM,CAACO,GAAP,CAAWc,IAAX,CAAD,CAA1B;AACAL,QAAAA,UAAU,CAACK,IAAD,CAAV,GAAmBA,IAAI,GAAG,CAAP,GAAW,CAAX,GAAeL,UAAU,CAACK,IAAI,GAAG,CAAR,CAAV,GAAuBV,UAAU,GAAGC,UAAtE;AACAK,QAAAA,OAAO,CAACI,IAAD,CAAP,GAAgB,IAAIC,YAAJ,CAAiB,EAAjB,CAAhB;AACAJ,QAAAA,YAAY,CAACG,IAAD,CAAZ,GAAqB,IAAIE,WAAJ,CAAgB,EAAhB,CAArB;AACAJ,QAAAA,QAAQ,CAACE,IAAD,CAAR,GAAiB,IAAIE,WAAJ,CAAgBZ,UAAU,GAAG,EAA7B,CAAjB;AACD;;AAED,WAAK,IAAIa,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGZ,UAA9B,EAA0C,EAAEY,MAA5C,EAAoD;AAClD,YAAIC,IAAI,GAAG,CAAX;AACA,YAAID,MAAM,IAAIZ,UAAU,GAAG,CAA3B,EAA8Ba,IAAI,GAAGX,SAAP;AAC9B,YAAIY,IAAI,GAAG,CAAX;;AAEA,aAAK,IAAIC,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGhB,UAA9B,EAA0C,EAAEgB,MAA5C,EAAoD;AAClD,cAAIA,MAAM,IAAIhB,UAAU,GAAG,CAA3B,EAA8Be,IAAI,GAAGb,SAAP;;AAE9B,eAAK,IAAIQ,KAAI,GAAG,CAAhB,EAAmBA,KAAI,GAAGZ,OAA1B,EAAmC,EAAEY,KAArC,EAA2C;AACzCH,YAAAA,YAAY,CAACG,KAAD,CAAZ,CAAmBO,IAAnB,CAAwB,CAAxB,EADyC,CACb;;;AAE5BV,YAAAA,YAAY,CAACG,KAAD,CAAZ,CAAmB,CAAnB,IAAwBjB,QAAQ,CAACY,UAAU,CAACK,KAAD,CAAV,EAAD,CAAhC,CAHyC,CAGa;;AAEtDQ,YAAAA,OAAO,CAACd,UAAD,EAAaZ,QAAb,EAAuBe,YAAY,CAACG,KAAD,CAAnC,CAAP,CALyC,CAKU;;AAEnDS,YAAAA,QAAQ,CAACZ,YAAY,CAACG,KAAD,CAAb,EAAqBJ,OAAO,CAACI,KAAD,CAA5B,CAAR,CAPyC,CAOI;;AAE7CU,YAAAA,UAAU,CAACd,OAAO,CAACI,KAAD,CAAR,CAAV;AACD;;AAED;AACEW,YAAAA,aAAa,CAACf,OAAD,CAAb;AACD;;AAED,eAAK,IAAII,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGZ,OAA1B,EAAmC,EAAEY,MAArC,EAA2C;AACzCY,YAAAA,aAAa,CAAChB,OAAO,CAACI,MAAD,CAAR,EAAgBF,QAAQ,CAACE,MAAD,CAAxB,EAAgCM,MAAM,GAAG,EAAzC,CAAb;AACD;AACF,SA3BiD,CA2BhD;;;AAGF,YAAIO,OAAM,GAAG,CAAb;;AAEA,aAAK,IAAIb,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGZ,OAA1B,EAAmC,EAAEY,MAArC,EAA2C;AACzC,cAAMxM,KAAI,GAAGqL,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWc,MAAX,CAAD,CAAX,CAA8BxM,IAA3C;;AAEA,eAAK,IAAIsN,CAAC,GAAG,IAAIX,MAAjB,EAAyBW,CAAC,GAAG,IAAIX,MAAJ,GAAaC,IAA1C,EAAgD,EAAEU,CAAlD,EAAqD;AACnDD,YAAAA,OAAM,GAAGd,UAAU,CAACC,MAAD,CAAV,CAAiBc,CAAjB,CAAT;;AAEA,iBAAK,IAAIR,OAAM,GAAG,CAAlB,EAAqBA,OAAM,GAAGjB,cAA9B,EAA8C,EAAEiB,OAAhD,EAAwD;AACtD,kBAAMS,GAAG,GAAGT,OAAM,GAAG,EAAT,GAAc,CAACQ,CAAC,GAAG,GAAL,IAAY,CAAtC;AACA9B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACA/B,cAAAA,QAAQ,CAACgC,SAAT,CAAmBH,OAAM,GAAG,IAAI7L,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,GAAG,GAAG,CAArB,CAAnD,EAA4E,IAA5E;AACAF,cAAAA,OAAM,IAAI,IAAI7L,UAAJ,GAAiBxB,KAA3B;AACD;AACF,WAlBwC,CAkBvC;;;AAGF,cAAI6L,cAAc,IAAIC,UAAtB,EAAkC;AAChC,iBAAK,IAAIwB,EAAC,GAAG,IAAIX,MAAjB,EAAyBW,EAAC,GAAG,IAAIX,MAAJ,GAAaC,IAA1C,EAAgD,EAAEU,EAAlD,EAAqD;AACnD,kBAAMD,QAAM,GAAGd,UAAU,CAACC,MAAD,CAAV,CAAiBc,EAAjB,IAAsB,IAAIzB,cAAJ,GAAqBrK,UAArB,GAAkCxB,KAAvE;;AACA,kBAAMuN,IAAG,GAAG1B,cAAc,GAAG,EAAjB,GAAsB,CAACyB,EAAC,GAAG,GAAL,IAAY,CAA9C;;AAEA,mBAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,IAApB,EAA0B,EAAEY,CAA5B,EAA+B;AAC7BjC,gBAAAA,QAAQ,CAACgC,SAAT,CAAmBH,QAAM,GAAGI,CAAC,GAAGjM,UAAJ,GAAiBxB,KAA7C,EAAmDsM,QAAQ,CAACE,MAAD,CAAR,CAAee,IAAG,GAAGE,CAArB,CAAnD,EAA4E,IAA5E;AACD;AACF;AACF;AACF,SA/DiD,CA+DhD;;AAEH,OA5FkF,CA4FjF;;;AAGF,UAAIC,OAAO,GAAG,IAAIhB,WAAJ,CAAgBjB,KAAhB,CAAd;AACA,UAAID,QAAQ,GAAG,IAAIrJ,QAAJ,CAAa4D,SAAS,CAACxF,MAAvB,CAAf,CAhGmF,CAgGpC;;AAE/C,WAAK,IAAIiM,MAAI,GAAG,CAAhB,EAAmBA,MAAI,GAAGZ,OAA1B,EAAmC,EAAEY,MAArC,EAA2C;AACzCnB,QAAAA,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWc,MAAX,CAAD,CAAX,CAA8BmB,OAA9B,GAAwC,IAAxC;AACA,YAAI3N,IAAI,GAAGqL,WAAW,CAACF,MAAM,CAACO,GAAP,CAAWc,MAAX,CAAD,CAAX,CAA8BxM,IAAzC;AACA,YAAIqL,WAAW,CAACmB,MAAD,CAAX,CAAkBxM,IAAlB,IAA0B,CAA9B,EAAiC;;AAEjC,aAAK,IAAIsN,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG3B,MAApB,EAA4B,EAAE2B,GAA9B,EAAiC;AAC/B,cAAMD,QAAM,GAAGd,UAAU,CAACC,MAAD,CAAV,CAAiBc,GAAjB,CAAf;;AAEA,eAAK,IAAIG,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGhC,KAApB,EAA2B,EAAEgC,EAA7B,EAAgC;AAC9BC,YAAAA,OAAO,CAACD,EAAD,CAAP,GAAajC,QAAQ,CAACoC,SAAT,CAAmBP,QAAM,GAAGI,EAAC,GAAGjM,UAAJ,GAAiBxB,IAA7C,EAAmD,IAAnD,CAAb;AACD;;AAED,eAAK,IAAIyN,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGhC,KAApB,EAA2B,EAAEgC,GAA7B,EAAgC;AAC9BjC,YAAAA,QAAQ,CAACqC,UAAT,CAAoBR,QAAM,GAAGI,GAAC,GAAGjM,UAAJ,GAAiBxB,IAA9C,EAAoD8N,aAAa,CAACJ,OAAO,CAACD,GAAD,CAAR,CAAjE,EAA+E,IAA/E;AACD;AACF;AACF;AACF;;AAED,aAAST,OAAT,CAAiBd,UAAjB,EAA6BZ,QAA7B,EAAuCe,YAAvC,EAAqD;AACnD,UAAI0B,OAAJ;AACA,UAAIC,OAAO,GAAG,CAAd;;AAEA,aAAOA,OAAO,GAAG,EAAjB,EAAqB;AACnBD,QAAAA,OAAO,GAAGzC,QAAQ,CAACY,UAAU,CAAC5J,KAAZ,CAAlB;;AAEA,YAAIyL,OAAO,IAAI,MAAf,EAAuB;AACrBC,UAAAA,OAAO,GAAG,EAAV;AACD,SAFD,MAEO,IAAID,OAAO,IAAI,CAAX,IAAgB,IAApB,EAA0B;AAC/BC,UAAAA,OAAO,IAAID,OAAO,GAAG,IAArB;AACD,SAFM,MAEA;AACL1B,UAAAA,YAAY,CAAC2B,OAAD,CAAZ,GAAwBD,OAAxB;AACAC,UAAAA,OAAO;AACR;;AAED9B,QAAAA,UAAU,CAAC5J,KAAX;AACD;AACF;;AAED,aAAS2K,QAAT,CAAkBM,GAAlB,EAAuBU,GAAvB,EAA4B;AAC1BA,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAtB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACAU,MAAAA,GAAG,CAAC,EAAD,CAAH,GAAUH,aAAa,CAACP,GAAG,CAAC,EAAD,CAAJ,CAAvB;AACD;;AAED,aAASL,UAAT,CAAoBnD,IAApB,EAA0B;AACxB,UAAMtD,CAAC,GAAG,MAAMzE,IAAI,CAACkM,GAAL,CAAS,UAAU,GAAnB,CAAhB;AACA,UAAMxH,CAAC,GAAG,MAAM1E,IAAI,CAACkM,GAAL,CAAS,UAAU,IAAnB,CAAhB;AACA,UAAMlK,CAAC,GAAG,MAAMhC,IAAI,CAACkM,GAAL,CAAS,UAAU,GAAnB,CAAhB;AACA,UAAM7G,CAAC,GAAG,MAAMrF,IAAI,CAACkM,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,UAAMC,CAAC,GAAG,MAAMnM,IAAI,CAACkM,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,UAAME,CAAC,GAAG,MAAMpM,IAAI,CAACkM,GAAL,CAAS,MAAM,OAAN,GAAgB,GAAzB,CAAhB;AACA,UAAMG,CAAC,GAAG,MAAMrM,IAAI,CAACkM,GAAL,CAAS,MAAM,OAAN,GAAgB,IAAzB,CAAhB;AACA,UAAII,KAAK,GAAG,IAAI9J,KAAJ,CAAU,CAAV,CAAZ;AACA,UAAI+J,IAAI,GAAG,IAAI/J,KAAJ,CAAU,CAAV,CAAX;AACA,UAAIgK,KAAK,GAAG,IAAIhK,KAAJ,CAAU,CAAV,CAAZ;AACA,UAAIiK,KAAK,GAAG,IAAIjK,KAAJ,CAAU,CAAV,CAAZ;;AAEA,WAAK,IAAIkK,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,CAAxB,EAA2B,EAAEA,GAA7B,EAAkC;AAChC,YAAIC,MAAM,GAAGD,GAAG,GAAG,CAAnB;AACAJ,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWtK,CAAC,GAAG+F,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAnB;AACAL,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGrE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAnB;AACAL,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWtK,CAAC,GAAG+F,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAnB;AACAL,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGrE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAnB;AACAJ,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU7H,CAAC,GAAGqD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAR,GAAuBtH,CAAC,GAAG0C,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA/B,GAA8CR,CAAC,GAAGpE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAtD,GAAqEN,CAAC,GAAGtE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAvF;AACAJ,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUlH,CAAC,GAAG0C,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAR,GAAuBN,CAAC,GAAGtE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA/B,GAA8CjI,CAAC,GAAGqD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAtD,GAAqER,CAAC,GAAGpE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAvF;AACAJ,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUJ,CAAC,GAAGpE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAR,GAAuBjI,CAAC,GAAGqD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA/B,GAA8CN,CAAC,GAAGtE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAtD,GAAqEtH,CAAC,GAAG0C,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAvF;AACAJ,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUF,CAAC,GAAGtE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAR,GAAuBR,CAAC,GAAGpE,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA/B,GAA8CtH,CAAC,GAAG0C,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAtD,GAAqEjI,CAAC,GAAGqD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAvF;AACAH,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAW/H,CAAC,IAAIsD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmB5E,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA3B,CAAZ;AACAH,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAW/H,CAAC,IAAIsD,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmB5E,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAA3B,CAAZ;AACAH,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAE,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAG,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAzE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC4E,MAAM,GAAG,CAAV,CAAJ,GAAmBF,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACD;;AAED,WAAK,IAAIK,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAG,CAA9B,EAAiC,EAAEA,MAAnC,EAA2C;AACzCN,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWtK,CAAC,GAAG+F,IAAI,CAAC,KAAK6E,MAAN,CAAnB;AACAN,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGrE,IAAI,CAAC,KAAK6E,MAAN,CAAnB;AACAN,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWtK,CAAC,GAAG+F,IAAI,CAAC,KAAK6E,MAAN,CAAnB;AACAN,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,CAAC,GAAGrE,IAAI,CAAC,KAAK6E,MAAN,CAAnB;AACAL,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU7H,CAAC,GAAGqD,IAAI,CAAC,IAAI6E,MAAL,CAAR,GAAuBvH,CAAC,GAAG0C,IAAI,CAAC,KAAK6E,MAAN,CAA/B,GAA+CT,CAAC,GAAGpE,IAAI,CAAC,KAAK6E,MAAN,CAAvD,GAAuEP,CAAC,GAAGtE,IAAI,CAAC,KAAK6E,MAAN,CAAzF;AACAL,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUlH,CAAC,GAAG0C,IAAI,CAAC,IAAI6E,MAAL,CAAR,GAAuBP,CAAC,GAAGtE,IAAI,CAAC,KAAK6E,MAAN,CAA/B,GAA+ClI,CAAC,GAAGqD,IAAI,CAAC,KAAK6E,MAAN,CAAvD,GAAuET,CAAC,GAAGpE,IAAI,CAAC,KAAK6E,MAAN,CAAzF;AACAL,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUJ,CAAC,GAAGpE,IAAI,CAAC,IAAI6E,MAAL,CAAR,GAAuBlI,CAAC,GAAGqD,IAAI,CAAC,KAAK6E,MAAN,CAA/B,GAA+CP,CAAC,GAAGtE,IAAI,CAAC,KAAK6E,MAAN,CAAvD,GAAuEvH,CAAC,GAAG0C,IAAI,CAAC,KAAK6E,MAAN,CAAzF;AACAL,QAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUF,CAAC,GAAGtE,IAAI,CAAC,IAAI6E,MAAL,CAAR,GAAuBT,CAAC,GAAGpE,IAAI,CAAC,KAAK6E,MAAN,CAA/B,GAA+CvH,CAAC,GAAG0C,IAAI,CAAC,KAAK6E,MAAN,CAAvD,GAAuElI,CAAC,GAAGqD,IAAI,CAAC,KAAK6E,MAAN,CAAzF;AACAJ,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAW/H,CAAC,IAAIsD,IAAI,CAAC6E,MAAD,CAAJ,GAAe7E,IAAI,CAAC,KAAK6E,MAAN,CAAvB,CAAZ;AACAJ,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAW/H,CAAC,IAAIsD,IAAI,CAAC6E,MAAD,CAAJ,GAAe7E,IAAI,CAAC,KAAK6E,MAAN,CAAvB,CAAZ;AACAJ,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAE,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAG,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAC,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWD,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAA3B;AACAzE,QAAAA,IAAI,CAAC,IAAI6E,MAAL,CAAJ,GAAmBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC,IAAI6E,MAAL,CAAJ,GAAmBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAlC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACAxE,QAAAA,IAAI,CAAC,KAAK6E,MAAN,CAAJ,GAAoBH,KAAK,CAAC,CAAD,CAAL,GAAWF,IAAI,CAAC,CAAD,CAAnC;AACD;AACF;;AAED,aAASpB,aAAT,CAAuBpD,IAAvB,EAA6B;AAC3B,WAAK,IAAI7G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B,YAAIoK,CAAC,GAAGvD,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,CAAR;AACA,YAAI2L,EAAE,GAAG9E,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,CAAT;AACA,YAAI4L,EAAE,GAAG/E,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,CAAT;AACA6G,QAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,IAAaoK,CAAC,GAAG,SAASwB,EAA1B;AACA/E,QAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,IAAaoK,CAAC,GAAG,SAASuB,EAAb,GAAkB,SAASC,EAAxC;AACA/E,QAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ7G,CAAR,IAAaoK,CAAC,GAAG,SAASuB,EAA1B;AACD;AACF;;AAED,aAASzB,aAAT,CAAuBG,GAAvB,EAA4BU,GAA5B,EAAiCvC,GAAjC,EAAsC;AACpC,WAAK,IAAIxI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AAC3B+K,QAAAA,GAAG,CAACvC,GAAG,GAAGxI,CAAP,CAAH,GAAevD,SAAS,CAACoP,WAAV,CAAsBC,QAAQ,CAACzB,GAAG,CAACrK,CAAD,CAAJ,CAA9B,CAAf;AACD;AACF;;AAED,aAAS8L,QAAT,CAAkBC,KAAlB,EAAyB;AACvB,UAAIA,KAAK,IAAI,CAAb,EAAgB;AACd,eAAOjN,IAAI,CAACkN,IAAL,CAAUD,KAAV,IAAmBjN,IAAI,CAACC,GAAL,CAASD,IAAI,CAACgB,GAAL,CAASiM,KAAT,CAAT,EAA0B,GAA1B,CAA1B;AACD,OAFD,MAEO;AACL,eAAOjN,IAAI,CAACkN,IAAL,CAAUD,KAAV,IAAmBjN,IAAI,CAACC,GAAL,CAASF,OAAT,EAAkBC,IAAI,CAACgB,GAAL,CAASiM,KAAT,IAAkB,GAApC,CAA1B;AACD;AACF;;AAED,aAASE,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,aAAO,IAAIjN,QAAJ,CAAaiN,IAAI,CAACC,KAAL,CAAW9O,MAAxB,EAAgC6O,IAAI,CAAC/B,MAAL,CAAY/K,KAA5C,EAAmD8M,IAAI,CAACzE,IAAxD,CAAP;AACD;;AAED,aAAS2E,aAAT,CAAuBF,IAAvB,EAA6B;AAC3B,UAAIG,UAAU,GAAGH,IAAI,CAACI,MAAL,CAAYjP,MAAZ,CAAmBkP,KAAnB,CAAyBL,IAAI,CAAC/B,MAAL,CAAY/K,KAArC,EAA4C8M,IAAI,CAAC/B,MAAL,CAAY/K,KAAZ,GAAoB8M,IAAI,CAACzE,IAArE,CAAjB;AACA,UAAI+E,SAAS,GAAG,IAAIvJ,UAAJ,CAAeuE,eAAe,CAAC6E,UAAD,CAA9B,CAAhB;AACA,UAAII,SAAS,GAAG,IAAIxJ,UAAJ,CAAeuJ,SAAS,CAACtF,MAAzB,CAAhB;AACAH,MAAAA,SAAS,CAACyF,SAAD,CAAT,CAJ2B,CAIL;;AAEtBrF,MAAAA,gBAAgB,CAACqF,SAAD,EAAYC,SAAZ,CAAhB,CAN2B,CAMa;;AAExC,aAAO,IAAIxN,QAAJ,CAAawN,SAAS,CAACpP,MAAvB,CAAP;AACD;;AAED,aAASqP,aAAT,CAAuBR,IAAvB,EAA6B;AAC3B,UAAIG,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBL,IAAI,CAAC/B,MAAL,CAAY/K,KAA7B,EAAoC8M,IAAI,CAAC/B,MAAL,CAAY/K,KAAZ,GAAoB8M,IAAI,CAACzE,IAA7D,CAAjB;AACA,UAAI+E,SAAS,GAAG9P,UAAU,CAAC2P,UAAD,CAA1B,CAF2B,CAEa;;AAExC,UAAII,SAAS,GAAG,IAAIxJ,UAAJ,CAAeuJ,SAAS,CAACtF,MAAzB,CAAhB;AACAH,MAAAA,SAAS,CAACyF,SAAD,CAAT,CAL2B,CAKL;;AAEtBrF,MAAAA,gBAAgB,CAACqF,SAAD,EAAYC,SAAZ,CAAhB,CAP2B,CAOa;;AAExC,aAAO,IAAIxN,QAAJ,CAAawN,SAAS,CAACpP,MAAvB,CAAP;AACD;;AAED,aAASsP,aAAT,CAAuBT,IAAvB,EAA6B;AAC3B,UAAIvK,UAAU,GAAGuK,IAAI,CAACI,MAAtB;AACA,UAAInL,QAAQ,GAAG;AACb/B,QAAAA,KAAK,EAAE8M,IAAI,CAAC/B,MAAL,CAAY/K;AADN,OAAf;AAGA,UAAIwN,UAAU,GAAGV,IAAI,CAAC3D,KAAL,GAAasE,iBAAb,IAAkCC,SAAS,CAACC,QAAV,CAAmB7F,MAAnB,GAA4BgF,IAAI,CAACpP,IAAnE,CAAjB;AACA,UAAI+F,SAAS,GAAG,IAAI2G,WAAJ,CAAgBoD,UAAhB,CAAhB;AACA,UAAIzM,MAAM,GAAG,IAAI8C,UAAJ,CAAe1F,WAAf,CAAb,CAP2B,CAOe;;AAE1C,UAAIyP,YAAY,GAAG,CAAnB;AACA,UAAIC,cAAc,GAAG,IAAI3L,KAAJ,CAAU4K,IAAI,CAACa,QAAf,CAArB;;AAEA,WAAK,IAAI/M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,IAAI,CAACa,QAAzB,EAAmC/M,CAAC,EAApC,EAAwC;AACtCiN,QAAAA,cAAc,CAACjN,CAAD,CAAd,GAAoB,EAApB;AACAiN,QAAAA,cAAc,CAACjN,CAAD,CAAd,CAAkB,OAAlB,IAA6BgN,YAA7B;AACAC,QAAAA,cAAc,CAACjN,CAAD,CAAd,CAAkB,KAAlB,IAA2BiN,cAAc,CAACjN,CAAD,CAAd,CAAkB,OAAlB,CAA3B;AACAiN,QAAAA,cAAc,CAACjN,CAAD,CAAd,CAAkB,IAAlB,IAA0BkM,IAAI,CAAC3D,KAA/B;AACA0E,QAAAA,cAAc,CAACjN,CAAD,CAAd,CAAkB,IAAlB,IAA0BkM,IAAI,CAACgB,KAA/B;AACAD,QAAAA,cAAc,CAACjN,CAAD,CAAd,CAAkB,MAAlB,IAA4BkM,IAAI,CAACpP,IAAjC;AACAkQ,QAAAA,YAAY,IAAIC,cAAc,CAACjN,CAAD,CAAd,CAAkBwE,EAAlB,GAAuByI,cAAc,CAACjN,CAAD,CAAd,CAAkB0E,EAAzC,GAA8CuI,cAAc,CAACjN,CAAD,CAAd,CAAkByH,IAAhF;AACD,OApB0B,CAoBzB;;;AAGF,UAAI0F,UAAU,GAAGC,WAAW,CAACzL,UAAD,EAAaR,QAAb,CAA5B;AACA,UAAIkM,UAAU,GAAGD,WAAW,CAACzL,UAAD,EAAaR,QAAb,CAA5B;;AAEA,UAAIkM,UAAU,IAAI9P,WAAlB,EAA+B;AAC7B,cAAM,qDAAN;AACD;;AAED,UAAI4P,UAAU,IAAIE,UAAlB,EAA8B;AAC5B,aAAK,IAAIrN,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGqN,UAAU,GAAGF,UAAb,GAA0B,CAA9C,EAAiDnN,GAAC,EAAlD,EAAsD;AACpDG,UAAAA,MAAM,CAACH,GAAC,GAAGmN,UAAL,CAAN,GAAyBG,UAAU,CAAC3L,UAAD,EAAaR,QAAb,CAAnC;AACD;AACF,OAlC0B,CAkCzB;;;AAGF,UAAIf,GAAG,GAAG,IAAIoJ,WAAJ,CAAgBlM,YAAhB,CAAV;AACA,UAAIiQ,QAAQ,GAAGrN,oBAAoB,CAACC,MAAD,EAASC,GAAT,CAAnC;AACA,UAAI8G,MAAM,GAAGR,WAAW,CAAC/E,UAAD,EAAaR,QAAb,CAAxB,CAvC2B,CAuCqB;;AAEhDmF,MAAAA,aAAa,CAAC4F,IAAI,CAACC,KAAN,EAAaxK,UAAb,EAAyBR,QAAzB,EAAmC+F,MAAnC,EAA2CrE,SAA3C,EAAsDmK,YAAtD,CAAb,CAzC2B,CAyCuD;;AAElF,WAAK,IAAIhN,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGkM,IAAI,CAACa,QAAzB,EAAmC,EAAE/M,GAArC,EAAwC;AACtC,YAAIwN,EAAE,GAAGP,cAAc,CAACjN,GAAD,CAAvB;;AAEA,aAAK,IAAIuE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0I,cAAc,CAACjN,GAAD,CAAd,CAAkByH,IAAtC,EAA4C,EAAElD,CAA9C,EAAiD;AAC/CD,UAAAA,UAAU,CAACzB,SAAD,EAAY2K,EAAE,CAACC,KAAH,GAAWlJ,CAAvB,EAA0BiJ,EAAE,CAAChJ,EAA7B,EAAiCgJ,EAAE,CAAC/F,IAApC,EAA0C+F,EAAE,CAAC9I,EAA7C,EAAiD8I,EAAE,CAAChJ,EAAH,GAAQgJ,EAAE,CAAC/F,IAA5D,EAAkE8F,QAAlE,CAAV;AACD;AACF,OAjD0B,CAiDzB;;;AAGF3G,MAAAA,QAAQ,CAACxG,GAAD,EAAMyC,SAAN,EAAiBmK,YAAjB,CAAR,CApD2B,CAoDa;;AAExC,UAAIU,SAAS,GAAG,CAAhB;AACA,UAAIjB,SAAS,GAAG,IAAIxJ,UAAJ,CAAeJ,SAAS,CAACxF,MAAV,CAAiBqK,UAAhC,CAAhB;;AAEA,WAAK,IAAI0C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8B,IAAI,CAACgB,KAAzB,EAAgC9C,CAAC,EAAjC,EAAqC;AACnC,aAAK,IAAItJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoL,IAAI,CAACa,QAAzB,EAAmCjM,CAAC,EAApC,EAAwC;AACtC,cAAI0M,EAAE,GAAGP,cAAc,CAACnM,CAAD,CAAvB;AACA,cAAIR,CAAC,GAAGkN,EAAE,CAAChJ,EAAH,GAAQgJ,EAAE,CAAC/F,IAAnB;AACA,cAAIkG,EAAE,GAAG,IAAI1K,UAAJ,CAAeJ,SAAS,CAACxF,MAAzB,EAAiCmQ,EAAE,CAACI,GAAH,GAAStP,UAA1C,EAAsDgC,CAAC,GAAGhC,UAA1D,CAAT;AACAmO,UAAAA,SAAS,CAACoB,GAAV,CAAcF,EAAd,EAAkBD,SAAlB;AACAA,UAAAA,SAAS,IAAIpN,CAAC,GAAGhC,UAAjB;AACAkP,UAAAA,EAAE,CAACI,GAAH,IAAUtN,CAAV;AACD;AACF;;AAED,aAAO,IAAIrB,QAAJ,CAAawN,SAAS,CAACpP,MAAvB,CAAP;AACD;;AAED,aAASyQ,aAAT,CAAuB5B,IAAvB,EAA6B;AAC3B,UAAIG,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBL,IAAI,CAAC/B,MAAL,CAAY/K,KAA7B,EAAoC8M,IAAI,CAAC/B,MAAL,CAAY/K,KAAZ,GAAoB8M,IAAI,CAACzE,IAA7D,CAAjB;;AAEA,UAAI,OAAOsG,MAAP,KAAkB,WAAtB,EAAmC;AACjCC,QAAAA,OAAO,CAACC,KAAR,CAAc,2DAAd;AACD;;AAED,UAAIzB,SAAS,GAAGuB,MAAM,CAACrR,UAAP,CAAkB2P,UAAlB,CAAhB,CAP2B,CAOoB;;AAE/C,UAAM6B,EAAE,GAAGhC,IAAI,CAACgB,KAAL,GAAahB,IAAI,CAACa,QAAlB,GAA6Bb,IAAI,CAAC3D,KAA7C;AACA,UAAMkE,SAAS,GAAGP,IAAI,CAACpP,IAAL,IAAa,CAAb,GAAiB,IAAI0M,WAAJ,CAAgB0E,EAAhB,CAAjB,GAAuC,IAAIC,WAAJ,CAAgBD,EAAhB,CAAzD;AACA,UAAIE,YAAY,GAAG,CAAnB;AACA,UAAIC,QAAQ,GAAG,CAAf;AACA,UAAMC,GAAG,GAAG,IAAIhN,KAAJ,CAAU,CAAV,CAAZ;;AAEA,WAAK,IAAI8I,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8B,IAAI,CAACgB,KAAzB,EAAgC9C,CAAC,EAAjC,EAAqC;AACnC,aAAK,IAAItJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoL,IAAI,CAACa,QAAzB,EAAmCjM,CAAC,EAApC,EAAwC;AACtC,cAAIyN,KAAK,GAAG,CAAZ;;AAEA,kBAAQrC,IAAI,CAACpP,IAAb;AACE,iBAAK,CAAL;AACEwR,cAAAA,GAAG,CAAC,CAAD,CAAH,GAASF,YAAT;AACAE,cAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAASpC,IAAI,CAAC3D,KAAvB;AACA6F,cAAAA,YAAY,GAAGE,GAAG,CAAC,CAAD,CAAH,GAASpC,IAAI,CAAC3D,KAA7B;;AAEA,mBAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2H,IAAI,CAAC3D,KAAzB,EAAgC,EAAEhE,CAAlC,EAAqC;AACnC,oBAAMiK,IAAI,GAAGhC,SAAS,CAAC8B,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,CAAvB,GAA2B9B,SAAS,CAAC8B,GAAG,CAAC,CAAD,CAAH,EAAD,CAAjD;AACAC,gBAAAA,KAAK,IAAIC,IAAT;AACA/B,gBAAAA,SAAS,CAAC4B,QAAD,CAAT,GAAsBE,KAAtB;AACAF,gBAAAA,QAAQ;AACT;;AAED;;AAEF,iBAAK,CAAL;AACEC,cAAAA,GAAG,CAAC,CAAD,CAAH,GAASF,YAAT;AACAE,cAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAASpC,IAAI,CAAC3D,KAAvB;AACA+F,cAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAH,GAASpC,IAAI,CAAC3D,KAAvB;AACA6F,cAAAA,YAAY,GAAGE,GAAG,CAAC,CAAD,CAAH,GAASpC,IAAI,CAAC3D,KAA7B;;AAEA,mBAAK,IAAIhE,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG2H,IAAI,CAAC3D,KAAzB,EAAgC,EAAEhE,EAAlC,EAAqC;AACnC,oBAAMiK,KAAI,GAAGhC,SAAS,CAAC8B,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,EAAvB,GAA4B9B,SAAS,CAAC8B,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,EAAnD,GAAwD9B,SAAS,CAAC8B,GAAG,CAAC,CAAD,CAAH,EAAD,CAAT,IAAuB,CAA5F;;AACAC,gBAAAA,KAAK,IAAIC,KAAT;AACA/B,gBAAAA,SAAS,CAAC4B,QAAD,CAAT,GAAsBE,KAAtB;AACAF,gBAAAA,QAAQ;AACT;;AAED;AA5BJ;AA8BD;AACF;;AAED,aAAO,IAAIpP,QAAJ,CAAawN,SAAS,CAACpP,MAAvB,CAAP;AACD;;AAED,aAASoR,aAAT,CAAuBvC,IAAvB,EAA6B;AAC3B,UAAIvK,UAAU,GAAGuK,IAAI,CAACI,MAAtB;AACA,UAAInL,QAAQ,GAAG;AACb/B,QAAAA,KAAK,EAAE8M,IAAI,CAAC/B,MAAL,CAAY/K;AADN,OAAf;AAGA,UAAIyD,SAAS,GAAG,IAAII,UAAJ,CAAeiJ,IAAI,CAAC3D,KAAL,GAAa2D,IAAI,CAACgB,KAAlB,IAA2BJ,SAAS,CAACC,QAAV,CAAmB7F,MAAnB,GAA4BgF,IAAI,CAACpP,IAAjC,GAAwCwB,UAAnE,CAAf,CAAhB,CAL2B,CAKqF;;AAEhH,UAAIoQ,SAAS,GAAG;AACdC,QAAAA,OAAO,EAAEC,UAAU,CAACjN,UAAD,EAAaR,QAAb,CADL;AAEd0N,QAAAA,uBAAuB,EAAED,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAFrB;AAGd2N,QAAAA,qBAAqB,EAAEF,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAHnB;AAId4N,QAAAA,gBAAgB,EAAEH,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAJd;AAKd6N,QAAAA,gBAAgB,EAAEJ,UAAU,CAACjN,UAAD,EAAaR,QAAb,CALd;AAMd8N,QAAAA,iBAAiB,EAAEL,UAAU,CAACjN,UAAD,EAAaR,QAAb,CANf;AAOd+N,QAAAA,mBAAmB,EAAEN,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAPjB;AAQdgO,QAAAA,UAAU,EAAEP,UAAU,CAACjN,UAAD,EAAaR,QAAb,CARR;AASdiO,QAAAA,wBAAwB,EAAER,UAAU,CAACjN,UAAD,EAAaR,QAAb,CATtB;AAUdkO,QAAAA,wBAAwB,EAAET,UAAU,CAACjN,UAAD,EAAaR,QAAb,CAVtB;AAWdmO,QAAAA,aAAa,EAAEV,UAAU,CAACjN,UAAD,EAAaR,QAAb;AAXX,OAAhB;AAaA,UAAIuN,SAAS,CAACC,OAAV,GAAoB,CAAxB,EAA2B,MAAM,sBAAsB7B,SAAS,CAACyC,WAAhC,GAA8C,WAA9C,GAA4Db,SAAS,CAACC,OAAtE,GAAgF,iBAAtF,CApBA,CAoByG;;AAEpI,UAAIa,YAAY,GAAG,IAAIlO,KAAJ,EAAnB;AACA,UAAImO,QAAQ,GAAGrC,WAAW,CAACzL,UAAD,EAAaR,QAAb,CAAX,GAAoC7C,UAAnD;;AAEA,aAAOmR,QAAQ,GAAG,CAAlB,EAAqB;AACnB,YAAIC,IAAI,GAAGC,yBAAyB,CAAChO,UAAU,CAACtE,MAAZ,EAAoB8D,QAApB,CAApC;AACA,YAAI/B,KAAK,GAAGkO,UAAU,CAAC3L,UAAD,EAAaR,QAAb,CAAtB;AACA,YAAIoO,WAAW,GAAGnQ,KAAK,IAAI,CAAT,GAAa,CAA/B;AACA,YAAIwQ,GAAG,GAAG,CAACxQ,KAAK,IAAI,CAAV,IAAe,CAAzB;AACA,YAAIiH,KAAK,GAAG,IAAIwJ,SAAJ,CAAc,CAACD,GAAD,CAAd,EAAqB,CAArB,CAAZ;AACA,YAAI9S,IAAI,GAAGwQ,UAAU,CAAC3L,UAAD,EAAaR,QAAb,CAArB;AACAqO,QAAAA,YAAY,CAAC1H,IAAb,CAAkB;AAChB4H,UAAAA,IAAI,EAAEA,IADU;AAEhBrJ,UAAAA,KAAK,EAAEA,KAFS;AAGhBvJ,UAAAA,IAAI,EAAEA,IAHU;AAIhByS,UAAAA,WAAW,EAAEA;AAJG,SAAlB;AAMAE,QAAAA,QAAQ,IAAIC,IAAI,CAACxI,MAAL,GAAc,CAA1B;AACD,OAvC0B,CAuCzB;;;AAGF,UAAI6F,QAAQ,GAAGD,SAAS,CAACC,QAAzB;AACA,UAAI5E,WAAW,GAAG,IAAI7G,KAAJ,CAAU4K,IAAI,CAACa,QAAf,CAAlB;;AAEA,WAAK,IAAI/M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,IAAI,CAACa,QAAzB,EAAmC,EAAE/M,CAArC,EAAwC;AACtC,YAAIwN,EAAE,GAAGrF,WAAW,CAACnI,CAAD,CAAX,GAAiB,EAA1B;AACA,YAAI8P,OAAO,GAAG/C,QAAQ,CAAC/M,CAAD,CAAtB;AACAwN,QAAAA,EAAE,CAACkC,IAAH,GAAUI,OAAO,CAACJ,IAAlB;AACAlC,QAAAA,EAAE,CAAC+B,WAAH,GAAiB7Q,OAAjB;AACA8O,QAAAA,EAAE,CAAC/C,OAAH,GAAa,KAAb;AACA+C,QAAAA,EAAE,CAAC1Q,IAAH,GAAUgT,OAAO,CAACC,SAAlB;AACAvC,QAAAA,EAAE,CAACwC,OAAH,GAAaF,OAAO,CAACE,OAArB;AACAxC,QAAAA,EAAE,CAACjF,KAAH,GAAW2D,IAAI,CAAC3D,KAAhB;AACAiF,QAAAA,EAAE,CAAC/E,MAAH,GAAYyD,IAAI,CAACgB,KAAjB;AACD;;AAED,UAAIjF,MAAM,GAAG;AACXO,QAAAA,GAAG,EAAE,IAAIlH,KAAJ,CAAU,CAAV;AADM,OAAb;;AAIA,WAAK,IAAI6I,QAAM,GAAG,CAAlB,EAAqBA,QAAM,GAAG+B,IAAI,CAACa,QAAnC,EAA6C,EAAE5C,QAA/C,EAAuD;AACrD,YAAIqD,EAAE,GAAGrF,WAAW,CAACgC,QAAD,CAApB;;AAEA,aAAK,IAAInK,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGwP,YAAY,CAACtI,MAAjC,EAAyC,EAAElH,GAA3C,EAA8C;AAC5C,cAAIiQ,IAAI,GAAGT,YAAY,CAACxP,GAAD,CAAvB;;AAEA,cAAIwN,EAAE,CAACkC,IAAH,IAAWO,IAAI,CAACP,IAApB,EAA0B;AACxBlC,YAAAA,EAAE,CAAC+B,WAAH,GAAiBU,IAAI,CAACV,WAAtB;;AAEA,gBAAIU,IAAI,CAAC5J,KAAL,IAAc,CAAlB,EAAqB;AACnB4B,cAAAA,MAAM,CAACO,GAAP,CAAWyH,IAAI,CAAC5J,KAAhB,IAAyB8D,QAAzB;AACD;;AAEDqD,YAAAA,EAAE,CAACrD,MAAH,GAAYA,QAAZ;AACD;AACF;AACF,OA7E0B,CA6EzB;;;AAGF,UAAIuE,SAAS,CAACK,gBAAV,GAA6B,CAAjC,EAAoC;AAClC,gBAAQL,SAAS,CAACY,aAAlB;AACE,eAAK9Q,cAAL;AACE,gBAAI4J,QAAQ,GAAG,IAAIoB,WAAJ,CAAgBkF,SAAS,CAACU,wBAA1B,CAAf;AACA9I,YAAAA,aAAa,CAAC4F,IAAI,CAACC,KAAN,EAAaxK,UAAb,EAAyBR,QAAzB,EAAmCuN,SAAS,CAACK,gBAA7C,EAA+D3G,QAA/D,EAAyEsG,SAAS,CAACU,wBAAnF,CAAb;AACA;;AAEF,eAAK3Q,OAAL;AACE,gBAAI4N,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBpL,QAAQ,CAAC/B,KAA1B,EAAiC+B,QAAQ,CAAC/B,KAAT,GAAiBsP,SAAS,CAACU,wBAA5D,CAAjB;AACA,gBAAIvI,IAAI,GAAGkH,MAAM,CAACrR,UAAP,CAAkB2P,UAAlB,CAAX,CAFF,CAE4C;;AAE1C,gBAAIjE,QAAQ,GAAG,IAAIoB,WAAJ,CAAgB3C,IAAI,CAACxJ,MAArB,CAAf;AACA8D,YAAAA,QAAQ,CAAC/B,KAAT,IAAkBsP,SAAS,CAACU,wBAA5B;AACA;AAZJ;AAcD,OA/F0B,CA+FzB;;;AAGF,UAAIV,SAAS,CAACM,gBAAV,GAA6B,CAAjC,EAAoC;AAClC,YAAIkB,QAAQ,GAAG;AACb/D,UAAAA,KAAK,EAAED,IAAI,CAACC,KADC;AAEbhC,UAAAA,MAAM,EAAEhJ,QAFK;AAGbsG,UAAAA,IAAI,EAAEiH,SAAS,CAACM;AAHH,SAAf;AAKA,YAAI3G,QAAQ,GAAG,IAAImB,WAAJ,CAAgBkD,aAAa,CAACwD,QAAD,CAAb,CAAwB7S,MAAxC,CAAf;AACA8D,QAAAA,QAAQ,CAAC/B,KAAT,IAAkBsP,SAAS,CAACM,gBAA5B;AACD,OA1G0B,CA0GzB;;;AAGF,UAAIN,SAAS,CAACS,UAAV,GAAuB,CAA3B,EAA8B;AAC5B,YAAI9C,UAAU,GAAGH,IAAI,CAACC,KAAL,CAAWI,KAAX,CAAiBpL,QAAQ,CAAC/B,KAA1B,EAAiC+B,QAAQ,CAAC/B,KAAT,GAAiBsP,SAAS,CAACO,iBAA5D,CAAjB;AACA,YAAIpI,IAAI,GAAGkH,MAAM,CAACrR,UAAP,CAAkB2P,UAAlB,CAAX,CAF4B,CAEc;;AAE1C,YAAI8D,SAAS,GAAG3I,eAAe,CAACX,IAAI,CAACxJ,MAAN,CAA/B;AACA8D,QAAAA,QAAQ,CAAC/B,KAAT,IAAkBsP,SAAS,CAACO,iBAA5B;AACD,OAnH0B,CAmHzB;;;AAGF,UAAIjC,YAAY,GAAG,CAAnB;AACA,UAAI3D,UAAU,GAAG,IAAI/H,KAAJ,CAAU6G,WAAW,CAACjB,MAAtB,CAAjB;;AAEA,WAAK,IAAIlH,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGqJ,UAAU,CAACnC,MAA/B,EAAuC,EAAElH,GAAzC,EAA4C;AAC1CqJ,QAAAA,UAAU,CAACrJ,GAAD,CAAV,GAAgB,IAAIsB,KAAJ,EAAhB;AACD;;AAED,WAAK,IAAI8I,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8B,IAAI,CAACgB,KAAzB,EAAgC,EAAE9C,CAAlC,EAAqC;AACnC,aAAK,IAAIgG,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGjI,WAAW,CAACjB,MAAtC,EAA8C,EAAEkJ,IAAhD,EAAsD;AACpD/G,UAAAA,UAAU,CAAC+G,IAAD,CAAV,CAAiBtI,IAAjB,CAAsBkF,YAAtB;AACAA,UAAAA,YAAY,IAAI7E,WAAW,CAACiI,IAAD,CAAX,CAAkB7H,KAAlB,GAA0B2D,IAAI,CAACpP,IAA/B,GAAsCwB,UAAtD;AACD;AACF,OAlI0B,CAkIzB;;;AAGF0J,MAAAA,cAAc,CAACC,MAAD,EAASoB,UAAT,EAAqBlB,WAArB,EAAkCC,QAAlC,EAA4CC,QAA5C,EAAsDxF,SAAtD,CAAd,CArI2B,CAqIqD;;AAEhF,WAAK,IAAI7C,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGmI,WAAW,CAACjB,MAAhC,EAAwC,EAAElH,IAA1C,EAA6C;AAC3C,YAAIwN,EAAE,GAAGrF,WAAW,CAACnI,IAAD,CAApB;AACA,YAAIwN,EAAE,CAAC/C,OAAP,EAAgB;;AAEhB,gBAAQ+C,EAAE,CAAC+B,WAAX;AACE,eAAK3Q,GAAL;AACE,gBAAI4M,GAAG,GAAG,CAAV;AACA,gBAAI6E,SAAS,GAAG,CAAhB;;AAEA,iBAAK,IAAIjG,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG8B,IAAI,CAACgB,KAAzB,EAAgC,EAAE9C,GAAlC,EAAqC;AACnC,kBAAIkG,cAAc,GAAGjH,UAAU,CAACrJ,IAAD,CAAV,CAAcwL,GAAd,CAArB;;AAEA,mBAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiD,EAAE,CAACjF,KAAvB,EAA8B,EAAEgC,CAAhC,EAAmC;AACjC,qBAAK,IAAIgG,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGjS,UAAU,GAAGkP,EAAE,CAAC1Q,IAA1C,EAAgD,EAAEyT,IAAlD,EAAwD;AACtD1N,kBAAAA,SAAS,CAACyN,cAAc,EAAf,CAAT,GAA8BH,SAAS,CAACE,SAAS,GAAGE,IAAI,GAAG/C,EAAE,CAACjF,KAAV,GAAkBiF,EAAE,CAAC/E,MAAlC,CAAvC;AACD;;AAED4H,gBAAAA,SAAS;AACV;;AAED7E,cAAAA,GAAG;AACJ;;AAED;;AAEF,eAAK7M,SAAL,CArBF,CAqBkB;;AAEhB;AACE,kBAAM,kDAAN;AAxBJ;AA0BD;;AAED,aAAO,IAAIM,QAAJ,CAAa4D,SAAS,CAACxF,MAAvB,CAAP;AACD;;AAED,aAASsS,yBAAT,CAAmCtS,MAAnC,EAA2C8M,MAA3C,EAAmD;AACjD,UAAIqG,UAAU,GAAG,IAAIvN,UAAJ,CAAe5F,MAAf,CAAjB;AACA,UAAIoT,SAAS,GAAG,CAAhB;;AAEA,aAAOD,UAAU,CAACrG,MAAM,CAAC/K,KAAP,GAAeqR,SAAhB,CAAV,IAAwC,CAA/C,EAAkD;AAChDA,QAAAA,SAAS,IAAI,CAAb;AACD;;AAED,UAAIC,WAAW,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBJ,UAAU,CAACjE,KAAX,CAAiBpC,MAAM,CAAC/K,KAAxB,EAA+B+K,MAAM,CAAC/K,KAAP,GAAeqR,SAA9C,CAAzB,CAAlB;AACAtG,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAeqR,SAAf,GAA2B,CAA1C;AACA,aAAOC,WAAP;AACD;;AAED,aAASG,sBAAT,CAAgCxT,MAAhC,EAAwC8M,MAAxC,EAAgD1C,IAAhD,EAAsD;AACpD,UAAIiJ,WAAW,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyB,IAAI3N,UAAJ,CAAe5F,MAAf,EAAuBkP,KAAvB,CAA6BpC,MAAM,CAAC/K,KAApC,EAA2C+K,MAAM,CAAC/K,KAAP,GAAeqI,IAA1D,CAAzB,CAAlB;AACA0C,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAeqI,IAA9B;AACA,aAAOiJ,WAAP;AACD;;AAED,aAASI,UAAT,CAAoBxI,QAApB,EAA8B6B,MAA9B,EAAsC;AACpC,UAAI4G,KAAK,GAAGzI,QAAQ,CAAC/I,SAAT,CAAmB,CAAnB,EAAsB,IAAtB,CAAZ;AACA4K,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAejB,UAA9B;AACA,aAAO4S,KAAP;AACD;;AAED,aAASC,aAAT,CAAuB1I,QAAvB,EAAiC6B,MAAjC,EAAyC;AACvC,UAAII,CAAC,GAAG0G,UAAU,CAAC3I,QAAD,EAAW6B,MAAX,CAAlB;AACA,UAAIC,CAAC,GAAG1D,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAnB;AACA,aAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,aAAS8G,aAAT,CAAuB5I,QAAvB,EAAiC6B,MAAjC,EAAyC;AACvC,UAAII,CAAC,GAAG7D,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAnB;AACA,UAAIC,CAAC,GAAG1D,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAnB;AACA,aAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,aAAS6G,UAAT,CAAoB3I,QAApB,EAA8B6B,MAA9B,EAAsC;AACpC,UAAIgH,KAAK,GAAG7I,QAAQ,CAAC8I,QAAT,CAAkBjH,MAAM,CAAC/K,KAAzB,EAAgC,IAAhC,CAAZ;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAef,UAA9B;AACA,aAAO8S,KAAP;AACD;;AAED,aAASzK,WAAT,CAAqB4B,QAArB,EAA+B6B,MAA/B,EAAuC;AACrC,UAAIkH,MAAM,GAAG/I,QAAQ,CAAC/I,SAAT,CAAmB4K,MAAM,CAAC/K,KAA1B,EAAiC,IAAjC,CAAb;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAef,UAA9B;AACA,aAAOgT,MAAP;AACD;;AAED,aAASjQ,eAAT,CAAyBF,UAAzB,EAAqCiJ,MAArC,EAA6C;AAC3C,UAAImH,KAAK,GAAGpQ,UAAU,CAACiJ,MAAM,CAAC/K,KAAR,CAAtB;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAeb,SAA9B;AACA,aAAO+S,KAAP;AACD;;AAED,aAAShE,UAAT,CAAoBhF,QAApB,EAA8B6B,MAA9B,EAAsC;AACpC,UAAImH,KAAK,GAAGhJ,QAAQ,CAACP,QAAT,CAAkBoC,MAAM,CAAC/K,KAAzB,CAAZ;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,GAAe+K,MAAM,CAAC/K,KAAP,GAAeb,SAA9B;AACA,aAAO+S,KAAP;AACD;;AAED,aAAS1C,UAAT,CAAoBtG,QAApB,EAA8B6B,MAA9B,EAAsC;AACpC,UAAIoH,GAAG,GAAGC,MAAM,CAAClJ,QAAQ,CAACmJ,WAAT,CAAqBtH,MAAM,CAAC/K,KAA5B,EAAmC,IAAnC,CAAD,CAAhB;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,IAAgBjB,UAAhB;AACA,aAAOoT,GAAP;AACD;;AAED,aAASG,YAAT,CAAsBpJ,QAAtB,EAAgC6B,MAAhC,EAAwC;AACtC,UAAI4B,KAAK,GAAGzD,QAAQ,CAACqJ,UAAT,CAAoBxH,MAAM,CAAC/K,KAA3B,EAAkC,IAAlC,CAAZ;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,IAAgBhB,YAAhB;AACA,aAAO2N,KAAP;AACD;;AAED,aAAS6F,aAAT,CAAuBtJ,QAAvB,EAAiC6B,MAAjC,EAAyC;AACvC,aAAO1N,SAAS,CAACoP,WAAV,CAAsB6F,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAlC,CAAP;AACD,KAnuCsB,CAmuCrB;;;AAGF,aAASS,aAAT,CAAuBiH,MAAvB,EAA+B;AAC7B,UAAIrS,QAAQ,GAAG,CAACqS,MAAM,GAAG,MAAV,KAAqB,EAApC;AAAA,UACIC,QAAQ,GAAGD,MAAM,GAAG,MADxB;AAEA,aAAO,CAACA,MAAM,IAAI,EAAV,GAAe,CAAC,CAAhB,GAAoB,CAArB,KAA2BrS,QAAQ,GAAGA,QAAQ,KAAK,IAAb,GAAoBsS,QAAQ,GAAGC,GAAH,GAASC,QAArC,GAAgDlT,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYS,QAAQ,GAAG,EAAvB,KAA8B,IAAIsS,QAAQ,GAAG,KAA7C,CAAnD,GAAyG,kBAAkBA,QAAQ,GAAG,KAA7B,CAA5I,CAAP;AACD;;AAED,aAAS1E,WAAT,CAAqB9E,QAArB,EAA+B6B,MAA/B,EAAuC;AACrC,UAAI8H,MAAM,GAAG3J,QAAQ,CAACoC,SAAT,CAAmBP,MAAM,CAAC/K,KAA1B,EAAiC,IAAjC,CAAb;AACA+K,MAAAA,MAAM,CAAC/K,KAAP,IAAgBd,UAAhB;AACA,aAAO2T,MAAP;AACD;;AAED,aAASC,YAAT,CAAsB7U,MAAtB,EAA8B8M,MAA9B,EAAsC;AACpC,aAAOS,aAAa,CAACwC,WAAW,CAAC/P,MAAD,EAAS8M,MAAT,CAAZ,CAApB;AACD;;AAED,aAASgI,WAAT,CAAqB7J,QAArB,EAA+BjL,MAA/B,EAAuC8M,MAAvC,EAA+C1C,IAA/C,EAAqD;AACnD,UAAI2K,WAAW,GAAGjI,MAAM,CAAC/K,KAAzB;AACA,UAAI2N,QAAQ,GAAG,EAAf;;AAEA,aAAO5C,MAAM,CAAC/K,KAAP,GAAegT,WAAW,GAAG3K,IAAd,GAAqB,CAA3C,EAA8C;AAC5C,YAAIiI,IAAI,GAAGC,yBAAyB,CAACtS,MAAD,EAAS8M,MAAT,CAApC;AACA,YAAI4F,SAAS,GAAGkB,UAAU,CAAC3I,QAAD,EAAW6B,MAAX,CAA1B;AACA,YAAI6F,OAAO,GAAG1C,UAAU,CAAChF,QAAD,EAAW6B,MAAX,CAAxB;AACAA,QAAAA,MAAM,CAAC/K,KAAP,IAAgB,CAAhB,CAJ4C,CAIzB;;AAEnB,YAAIiT,SAAS,GAAGpB,UAAU,CAAC3I,QAAD,EAAW6B,MAAX,CAA1B;AACA,YAAImI,SAAS,GAAGrB,UAAU,CAAC3I,QAAD,EAAW6B,MAAX,CAA1B;AACA4C,QAAAA,QAAQ,CAACjF,IAAT,CAAc;AACZ4H,UAAAA,IAAI,EAAEA,IADM;AAEZK,UAAAA,SAAS,EAAEA,SAFC;AAGZC,UAAAA,OAAO,EAAEA,OAHG;AAIZqC,UAAAA,SAAS,EAAEA,SAJC;AAKZC,UAAAA,SAAS,EAAEA;AALC,SAAd;AAOD;;AAEDnI,MAAAA,MAAM,CAAC/K,KAAP,IAAgB,CAAhB;AACA,aAAO2N,QAAP;AACD;;AAED,aAASwF,mBAAT,CAA6BjK,QAA7B,EAAuC6B,MAAvC,EAA+C;AAC7C,UAAIqI,IAAI,GAAGd,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAvB;AACA,UAAIsI,IAAI,GAAGf,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAvB;AACA,UAAIuI,MAAM,GAAGhB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAzB;AACA,UAAIwI,MAAM,GAAGjB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAzB;AACA,UAAIyI,KAAK,GAAGlB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAxB;AACA,UAAI0I,KAAK,GAAGnB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAxB;AACA,UAAI2I,MAAM,GAAGpB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAzB;AACA,UAAI4I,MAAM,GAAGrB,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAzB;AACA,aAAO;AACLqI,QAAAA,IAAI,EAAEA,IADD;AAELC,QAAAA,IAAI,EAAEA,IAFD;AAGLC,QAAAA,MAAM,EAAEA,MAHH;AAILC,QAAAA,MAAM,EAAEA,MAJH;AAKLC,QAAAA,KAAK,EAAEA,KALF;AAMLC,QAAAA,KAAK,EAAEA,KANF;AAOLC,QAAAA,MAAM,EAAEA,MAPH;AAQLC,QAAAA,MAAM,EAAEA;AARH,OAAP;AAUD;;AAED,aAASC,gBAAT,CAA0B1K,QAA1B,EAAoC6B,MAApC,EAA4C;AAC1C,UAAI8I,gBAAgB,GAAG,CAAC,gBAAD,EAAmB,iBAAnB,EAAsC,kBAAtC,EAA0D,iBAA1D,EAA6E,iBAA7E,EAAgG,mBAAhG,EAAqH,iBAArH,EAAwI,kBAAxI,EAA4J,kBAA5J,EAAgL,kBAAhL,CAAvB;AACA,UAAI1D,WAAW,GAAGjC,UAAU,CAAChF,QAAD,EAAW6B,MAAX,CAA5B;AACA,aAAO8I,gBAAgB,CAAC1D,WAAD,CAAvB;AACD;;AAED,aAAS2D,UAAT,CAAoB5K,QAApB,EAA8B6B,MAA9B,EAAsC;AACpC,UAAIgJ,IAAI,GAAGzM,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAtB;AACA,UAAIiJ,IAAI,GAAG1M,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAtB;AACA,UAAIkJ,IAAI,GAAG3M,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAtB;AACA,UAAImJ,IAAI,GAAG5M,WAAW,CAAC4B,QAAD,EAAW6B,MAAX,CAAtB;AACA,aAAO;AACLgJ,QAAAA,IAAI,EAAEA,IADD;AAELC,QAAAA,IAAI,EAAEA,IAFD;AAGLC,QAAAA,IAAI,EAAEA,IAHD;AAILC,QAAAA,IAAI,EAAEA;AAJD,OAAP;AAMD;;AAED,aAASC,cAAT,CAAwBjL,QAAxB,EAAkC6B,MAAlC,EAA0C;AACxC,UAAIqJ,UAAU,GAAG,CAAC,cAAD,CAAjB;AACA,UAAIC,SAAS,GAAGnG,UAAU,CAAChF,QAAD,EAAW6B,MAAX,CAA1B;AACA,aAAOqJ,UAAU,CAACC,SAAD,CAAjB;AACD;;AAED,aAASC,QAAT,CAAkBpL,QAAlB,EAA4B6B,MAA5B,EAAoC;AAClC,UAAII,CAAC,GAAGmH,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAApB;AACA,UAAIC,CAAC,GAAGsH,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAApB;AACA,aAAO,CAACI,CAAD,EAAIH,CAAJ,CAAP;AACD;;AAED,aAASuJ,QAAT,CAAkBrL,QAAlB,EAA4B6B,MAA5B,EAAoC;AAClC,UAAII,CAAC,GAAGmH,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAApB;AACA,UAAIC,CAAC,GAAGsH,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAApB;AACA,UAAIyJ,CAAC,GAAGlC,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAApB;AACA,aAAO,CAACI,CAAD,EAAIH,CAAJ,EAAOwJ,CAAP,CAAP;AACD;;AAED,aAASC,UAAT,CAAoBvL,QAApB,EAA8BjL,MAA9B,EAAsC8M,MAAtC,EAA8CrN,IAA9C,EAAoD2K,IAApD,EAA0D;AACxD,UAAI3K,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,cAA9B,IAAgDA,IAAI,KAAK,YAA7D,EAA2E;AACzE,eAAO+T,sBAAsB,CAACxT,MAAD,EAAS8M,MAAT,EAAiB1C,IAAjB,CAA7B;AACD,OAFD,MAEO,IAAI3K,IAAI,KAAK,QAAb,EAAuB;AAC5B,eAAOqV,WAAW,CAAC7J,QAAD,EAAWjL,MAAX,EAAmB8M,MAAnB,EAA2B1C,IAA3B,CAAlB;AACD,OAFM,MAEA,IAAI3K,IAAI,KAAK,gBAAb,EAA+B;AACpC,eAAOyV,mBAAmB,CAACjK,QAAD,EAAW6B,MAAX,CAA1B;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,aAAb,EAA4B;AACjC,eAAOkW,gBAAgB,CAAC1K,QAAD,EAAW6B,MAAX,CAAvB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,OAAb,EAAsB;AAC3B,eAAOoW,UAAU,CAAC5K,QAAD,EAAW6B,MAAX,CAAjB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,WAAb,EAA0B;AAC/B,eAAOyW,cAAc,CAACjL,QAAD,EAAW6B,MAAX,CAArB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,OAAb,EAAsB;AAC3B,eAAO4U,YAAY,CAACpJ,QAAD,EAAW6B,MAAX,CAAnB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,KAAb,EAAoB;AACzB,eAAO4W,QAAQ,CAACpL,QAAD,EAAW6B,MAAX,CAAf;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,KAAb,EAAoB;AACzB,eAAO6W,QAAQ,CAACrL,QAAD,EAAW6B,MAAX,CAAf;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,KAAb,EAAoB;AACzB,eAAOmU,UAAU,CAAC3I,QAAD,EAAW6B,MAAX,CAAjB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,UAAb,EAAyB;AAC9B,eAAOkU,aAAa,CAAC1I,QAAD,EAAW6B,MAAX,CAApB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,UAAb,EAAyB;AAC9B,eAAOoU,aAAa,CAAC5I,QAAD,EAAW6B,MAAX,CAApB;AACD,OAFM,MAEA,IAAIrN,IAAI,KAAK,SAAb,EAAwB;AAC7BqN,QAAAA,MAAM,CAAC/K,KAAP,IAAgBqI,IAAhB;AACA,eAAO,SAAP;AACD,OAHM,MAGA;AACL0C,QAAAA,MAAM,CAAC/K,KAAP,IAAgBqI,IAAhB;AACA,eAAOqM,SAAP;AACD;AACF;;AAED,QAAIC,cAAc,GAAG,IAAI9U,QAAJ,CAAa5B,MAAb,CAArB;AACA,QAAI6D,UAAU,GAAG,IAAI+B,UAAJ,CAAe5F,MAAf,CAAjB;AACA,QAAIyP,SAAS,GAAG,EAAhB;AACAiH,IAAAA,cAAc,CAACxU,SAAf,CAAyB,CAAzB,EAA4B,IAA5B,EA/2CuB,CA+2CY;;AAEnCwU,IAAAA,cAAc,CAAChM,QAAf,CAAwB,CAAxB,EAA2B,IAA3B,EAj3CuB,CAi3CW;;AAElCgM,IAAAA,cAAc,CAAChM,QAAf,CAAwB,CAAxB,EAA2B,IAA3B,EAn3CuB,CAm3CW;AAClC;;AAEA,QAAIoC,MAAM,GAAG;AACX/K,MAAAA,KAAK,EAAE;AADI,KAAb,CAt3CuB,CAw3CpB;;AAEH,QAAI4U,WAAW,GAAG,IAAlB;;AAEA,WAAOA,WAAP,EAAoB;AAClB,UAAIC,aAAa,GAAGtE,yBAAyB,CAACtS,MAAD,EAAS8M,MAAT,CAA7C;;AAEA,UAAI8J,aAAa,IAAI,CAArB,EAAwB;AACtBD,QAAAA,WAAW,GAAG,KAAd;AACD,OAFD,MAEO;AACL,YAAIE,aAAa,GAAGvE,yBAAyB,CAACtS,MAAD,EAAS8M,MAAT,CAA7C;AACA,YAAIgK,aAAa,GAAGzN,WAAW,CAACqN,cAAD,EAAiB5J,MAAjB,CAA/B;AACA,YAAIiK,cAAc,GAAGP,UAAU,CAACE,cAAD,EAAiB1W,MAAjB,EAAyB8M,MAAzB,EAAiC+J,aAAjC,EAAgDC,aAAhD,CAA/B;;AAEA,YAAIC,cAAc,KAAKN,SAAvB,EAAkC;AAChC9F,UAAAA,OAAO,CAACqG,IAAR,mEAAyEH,aAAzE;AACD,SAFD,MAEO;AACLpH,UAAAA,SAAS,CAACmH,aAAD,CAAT,GAA2BG,cAA3B;AACD;AACF;AACF,KA54CsB,CA44CrB;;;AAGF,QAAIE,gBAAgB,GAAGxH,SAAS,CAACyH,UAAV,CAAqBjB,IAArB,GAA4B,CAAnD;AACA,QAAIkB,UAAJ;AACA,QAAI3H,iBAAJ;;AAEA,YAAQC,SAAS,CAACyC,WAAlB;AACE,WAAK,gBAAL;AACE1C,QAAAA,iBAAiB,GAAG,CAApB;AACA2H,QAAAA,UAAU,GAAGvI,aAAb;AACA;;AAEF,WAAK,iBAAL;AACEY,QAAAA,iBAAiB,GAAG,CAApB;AACA2H,QAAAA,UAAU,GAAGpI,aAAb;AACA;;AAEF,WAAK,kBAAL;AACES,QAAAA,iBAAiB,GAAG,CAApB;AACA2H,QAAAA,UAAU,GAAG9H,aAAb;AACA;;AAEF,WAAK,iBAAL;AACEG,QAAAA,iBAAiB,GAAG,EAApB;AACA2H,QAAAA,UAAU,GAAG9H,aAAb;AACA;;AAEF,WAAK,iBAAL;AACEG,QAAAA,iBAAiB,GAAG,EAApB;AACA2H,QAAAA,UAAU,GAAG7H,aAAb;AACA;;AAEF,WAAK,mBAAL;AACEE,QAAAA,iBAAiB,GAAG,EAApB;AACA2H,QAAAA,UAAU,GAAG1G,aAAb;AACA;;AAEF,WAAK,kBAAL;AACEjB,QAAAA,iBAAiB,GAAG,EAApB;AACA2H,QAAAA,UAAU,GAAG/F,aAAb;AACA;;AAEF,WAAK,kBAAL;AACE5B,QAAAA,iBAAiB,GAAG,GAApB;AACA2H,QAAAA,UAAU,GAAG/F,aAAb;AACA;;AAEF;AACE,cAAM,sBAAsB3B,SAAS,CAACyC,WAAhC,GAA8C,iBAApD;AA1CJ;;AA6CA,QAAIkF,MAAJ;AACA,QAAIC,QAAJ,CAj8CuB,CAi8CT;;AAEd,QAAI3E,SAAS,GAAGjD,SAAS,CAACC,QAAV,CAAmB,CAAnB,EAAsBgD,SAAtC;;AAEA,QAAIA,SAAS,KAAK,CAAlB,EAAqB;AACnB;AACA,cAAQ,KAAKjT,IAAb;AACE,aAAKZ,gBAAL;AACA,aAAKF,SAAL;AACE0Y,UAAAA,QAAQ,GAAGxC,YAAX;AACAuC,UAAAA,MAAM,GAAGnW,UAAT;AACA;;AAEF,aAAKrC,aAAL;AACEyY,UAAAA,QAAQ,GAAGtH,WAAX;AACAqH,UAAAA,MAAM,GAAGnW,UAAT;AACA;AAVJ;AAYD,KAdD,MAcO,IAAIyR,SAAS,KAAK,CAAlB,EAAqB;AAC1B;AACA,cAAQ,KAAKjT,IAAb;AACE,aAAKZ,gBAAL;AACA,aAAKF,SAAL;AACE0Y,UAAAA,QAAQ,GAAGhD,YAAX;AACA+C,UAAAA,MAAM,GAAGrW,YAAT;AACA;;AAEF,aAAKnC,aAAL;AACEyY,UAAAA,QAAQ,GAAG9C,aAAX;AACA6C,UAAAA,MAAM,GAAGrW,YAAT;AATJ;AAWD,KAbM,MAaA;AACL,YAAM,4CAA4C2R,SAA5C,GAAwD,OAAxD,GAAkEjD,SAAS,CAACyC,WAA5E,GAA0F,GAAhG;AACD;;AAED,QAAIoF,SAAS,GAAGL,gBAAgB,GAAGzH,iBAAnC;;AAEA,SAAK,IAAI7M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2U,SAApB,EAA+B3U,CAAC,EAAhC,EAAoC;AAClC8Q,MAAAA,UAAU,CAACiD,cAAD,EAAiB5J,MAAjB,CAAV,CADkC,CACE;AACrC,KAx+CsB,CAw+CrB;;;AAGF,QAAI5B,KAAK,GAAGuE,SAAS,CAACyH,UAAV,CAAqBlB,IAArB,GAA4BvG,SAAS,CAACyH,UAAV,CAAqBpB,IAAjD,GAAwD,CAApE;AACA,QAAI1K,MAAM,GAAGqE,SAAS,CAACyH,UAAV,CAAqBjB,IAArB,GAA4BxG,SAAS,CAACyH,UAAV,CAAqBnB,IAAjD,GAAwD,CAArE,CA5+CuB,CA4+CiD;AACxE;;AAEA,QAAIwB,WAAW,GAAG,CAAlB;AACA,QAAInN,IAAI,GAAGc,KAAK,GAAGE,MAAR,GAAiBmM,WAA5B,CAh/CuB,CAg/CkB;;AAEzC,YAAQ,KAAK9X,IAAb;AACE,WAAKZ,gBAAL;AACA,WAAKF,SAAL;AACE,YAAI6Y,SAAS,GAAG,IAAItL,YAAJ,CAAiB9B,IAAjB,CAAhB;;AAEA,YAAIqF,SAAS,CAACC,QAAV,CAAmB7F,MAAnB,GAA4B0N,WAAhC,EAA6C;AAC3CC,UAAAA,SAAS,CAAChL,IAAV,CAAe,CAAf,EAAkB,CAAlB,EAAqBpC,IAArB;AACD;;AAED;;AAEF,WAAKxL,aAAL;AACE,YAAI4Y,SAAS,GAAG,IAAIrL,WAAJ,CAAgB/B,IAAhB,CAAhB;;AAEA,YAAIqF,SAAS,CAACC,QAAV,CAAmB7F,MAAnB,GAA4B0N,WAAhC,EAA6C;AAC3CC,UAAAA,SAAS,CAAChL,IAAV,CAAe,MAAf,EAAuB,CAAvB,EAA0BpC,IAA1B,EAD2C,CACV;AAClC;;AAED;;AAEF;AACEuG,QAAAA,OAAO,CAACC,KAAR,CAAc,qCAAd,EAAqD,KAAKnR,IAA1D;AACA;AAtBJ;;AAyBA,QAAIgY,cAAc,GAAG;AACnBC,MAAAA,CAAC,EAAE,CADgB;AAEnBC,MAAAA,CAAC,EAAE,CAFgB;AAGnBC,MAAAA,CAAC,EAAE,CAHgB;AAInBC,MAAAA,CAAC,EAAE;AAJgB,KAArB;AAMA,QAAIC,eAAe,GAAG;AACpB1N,MAAAA,IAAI,EAAE,CADc;AAEpBc,MAAAA,KAAK,EAAEA,KAFa;AAGpB2E,MAAAA,KAAK,EAAEL,iBAHa;AAIpB1C,MAAAA,MAAM,EAAEA,MAJY;AAKpBgC,MAAAA,KAAK,EAAEjL,UALa;AAMpBoL,MAAAA,MAAM,EAAEyH,cANY;AAOpBjX,MAAAA,IAAI,EAAEiT,SAPc;AAQpBhD,MAAAA,QAAQ,EAAED,SAAS,CAACC,QAAV,CAAmB7F;AART,KAAtB;AAUA,QAAIkO,IAAJ;AACA,QAAI3N,IAAJ;AACA,QAAI6E,MAAJ;AACA,QAAIoB,SAAS,GAAG;AACdtO,MAAAA,KAAK,EAAE;AADO,KAAhB;;AAIA,SAAK,IAAIiW,gBAAgB,GAAG,CAA5B,EAA+BA,gBAAgB,GAAG5M,MAAM,GAAGoE,iBAA3D,EAA8EwI,gBAAgB,EAA9F,EAAkG;AAChGD,MAAAA,IAAI,GAAG1O,WAAW,CAACqN,cAAD,EAAiB5J,MAAjB,CAAlB,CADgG,CACpD;;AAE5C1C,MAAAA,IAAI,GAAGf,WAAW,CAACqN,cAAD,EAAiB5J,MAAjB,CAAlB,CAHgG,CAGpD;;AAE5CgL,MAAAA,eAAe,CAACjI,KAAhB,GAAwBkI,IAAI,GAAGvI,iBAAP,GAA2BpE,MAA3B,GAAoCA,MAAM,GAAG2M,IAA7C,GAAoDvI,iBAA5E;AACAsI,MAAAA,eAAe,CAAChL,MAAhB,GAAyBA,MAAzB;AACAgL,MAAAA,eAAe,CAAC1N,IAAhB,GAAuBA,IAAvB;AACA6E,MAAAA,MAAM,GAAGkI,UAAU,CAACW,eAAD,CAAnB;AACAhL,MAAAA,MAAM,CAAC/K,KAAP,IAAgBqI,IAAhB;;AAEA,WAAK,IAAI6N,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGzI,iBAA9B,EAAiDyI,MAAM,EAAvD,EAA2D;AACzD,YAAIC,MAAM,GAAGD,MAAM,GAAGD,gBAAgB,GAAGxI,iBAAzC;AACA,YAAI0I,MAAM,IAAI9M,MAAd,EAAsB;;AAEtB,aAAK,IAAI+M,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAG1I,SAAS,CAACC,QAAV,CAAmB7F,MAAvD,EAA+DsO,SAAS,EAAxE,EAA4E;AAC1E,cAAIC,IAAI,GAAGX,cAAc,CAAChI,SAAS,CAACC,QAAV,CAAmByI,SAAnB,EAA8B9F,IAA/B,CAAzB;;AAEA,eAAK,IAAInF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,KAApB,EAA2BgC,CAAC,EAA5B,EAAgC;AAC9B,gBAAI/B,GAAG,GAAG8M,MAAM,IAAIxI,SAAS,CAACC,QAAV,CAAmB7F,MAAnB,GAA4BqB,KAAhC,CAAN,GAA+CiN,SAAS,GAAGjN,KAA3D,GAAmEgC,CAA7E;AACAmD,YAAAA,SAAS,CAACtO,KAAV,GAAkBoJ,GAAG,GAAGiM,MAAxB;AACA,gBAAIiB,GAAG,GAAGhB,QAAQ,CAACpI,MAAD,EAASoB,SAAT,CAAlB;AACAmH,YAAAA,SAAS,CAAC,CAACpM,MAAM,GAAG,CAAT,GAAa8M,MAAd,KAAyBhN,KAAK,GAAGqM,WAAjC,IAAgDrK,CAAC,GAAGqK,WAApD,GAAkEa,IAAnE,CAAT,GAAoFC,GAApF;AACD;AACF;AACF;AACF;;AAED,QAAI,KAAK5Y,IAAL,KAAcZ,gBAAlB,EAAoC;AAClC,UAAIyZ,CAAJ,EAAO3V,IAAP;;AACA,UAAMyH,KAAI,GAAGoN,SAAS,CAAC3N,MAAvB;AACA,UAAM0O,SAAS,GAAG,IAAI3S,UAAJ,CAAewE,KAAf,CAAlB;;AAEA,WAAK,IAAI/D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+E,MAApB,EAA4B,EAAE/E,CAA9B,EAAiC;AAC/B,aAAK,IAAImS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtN,KAApB,EAA2B,EAAEsN,CAA7B,EAAgC;AAC9B7V,UAAAA,IAAC,GAAG0D,CAAC,GAAG6E,KAAJ,GAAY,CAAZ,GAAgBsN,CAAC,GAAG,CAAxB;AACA,cAAMC,GAAG,GAAGjB,SAAS,CAAC7U,IAAD,CAArB;AACA,cAAM+V,KAAK,GAAGlB,SAAS,CAAC7U,IAAC,GAAG,CAAL,CAAvB;AACA,cAAMgW,IAAI,GAAGnB,SAAS,CAAC7U,IAAC,GAAG,CAAL,CAAtB;AACA2V,UAAAA,CAAC,GAAGG,GAAG,GAAGC,KAAN,GAAcD,GAAd,GAAoBC,KAAxB;AACAJ,UAAAA,CAAC,GAAGK,IAAI,GAAGL,CAAP,GAAWK,IAAX,GAAkBL,CAAtB;;AAEA,cAAIA,CAAC,GAAG,KAAR,EAAe;AACbC,YAAAA,SAAS,CAAC5V,IAAD,CAAT,GAAe4V,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmB4V,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmB4V,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmB,CAAxE;AACD,WAFD,MAEO;AACL,gBAAMiW,GAAG,GAAG9W,KAAK,CAACwW,CAAD,CAAjB;AACAA,YAAAA,CAAC,GAAGM,GAAG,CAAC,CAAD,CAAH,GAAS,GAAT,GAAeN,CAAnB;AACAC,YAAAA,SAAS,CAAC5V,IAAD,CAAT,GAAe8V,GAAG,GAAGH,CAArB;AACAC,YAAAA,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmB+V,KAAK,GAAGJ,CAA3B;AACAC,YAAAA,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmBgW,IAAI,GAAGL,CAA1B;AACAC,YAAAA,SAAS,CAAC5V,IAAC,GAAG,CAAL,CAAT,GAAmBiW,GAAG,CAAC,CAAD,CAAH,GAAS,GAA5B;AACD;AACF;AACF;;AAEDpB,MAAAA,SAAS,GAAGe,SAAZ;AACD;;AAED,QAAMM,MAAM,GAAG,KAAKpZ,IAAL,KAAcZ,gBAAd,GAAiCC,UAAjC,GAA8CC,UAA7D;AACA,WAAO;AACL+Z,MAAAA,MAAM,EAAErJ,SADH;AAELvE,MAAAA,KAAK,EAAEA,KAFF;AAGLE,MAAAA,MAAM,EAAEA,MAHH;AAIL5B,MAAAA,IAAI,EAAEgO,SAJD;AAKLqB,MAAAA,MAAM,EAAEA,MALH;AAMLpZ,MAAAA,IAAI,EAAE,KAAKA;AANN,KAAP;AAQD,GAvmD6E;AAwmD9EsZ,EAAAA,WAAW,EAAE,qBAAUhX,KAAV,EAAiB;AAC5B,SAAKtC,IAAL,GAAYsC,KAAZ;AACA,WAAO,IAAP;AACD,GA3mD6E;AA4mD9EiX,EAAAA,IAAI,EAAE,cAAUC,GAAV,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,OAAnC,EAA4C;AAChD,aAASC,cAAT,CAAwBC,OAAxB,EAAiCC,OAAjC,EAA0C;AACxC,cAAQD,OAAO,CAAC7Z,IAAhB;AACE,aAAKZ,gBAAL;AACEya,UAAAA,OAAO,CAACE,QAAR,GAAmBta,YAAnB;AACAoa,UAAAA,OAAO,CAACG,SAAR,GAAoBta,aAApB;AACAma,UAAAA,OAAO,CAACI,SAAR,GAAoBva,aAApB;AACAma,UAAAA,OAAO,CAACK,eAAR,GAA0B,KAA1B;AACAL,UAAAA,OAAO,CAACM,KAAR,GAAgB,KAAhB;AACA;;AAEF,aAAKjb,SAAL;AACA,aAAKC,aAAL;AACE0a,UAAAA,OAAO,CAACE,QAAR,GAAmBxa,cAAnB;AACAsa,UAAAA,OAAO,CAACG,SAAR,GAAoBxa,YAApB;AACAqa,UAAAA,OAAO,CAACI,SAAR,GAAoBza,YAApB;AACAqa,UAAAA,OAAO,CAACK,eAAR,GAA0B,KAA1B;AACAL,UAAAA,OAAO,CAACM,KAAR,GAAgB,KAAhB;AACA;AAhBJ;;AAmBA,UAAIV,MAAJ,EAAYA,MAAM,CAACI,OAAD,EAAUC,OAAV,CAAN;AACb;;AAED,WAAO7a,iBAAiB,CAACgB,SAAlB,CAA4BsZ,IAA5B,CAAiCxZ,IAAjC,CAAsC,IAAtC,EAA4CyZ,GAA5C,EAAiDI,cAAjD,EAAiEF,UAAjE,EAA6EC,OAA7E,CAAP;AACD;AAroD6E,CAA1D,CAAtB;AAwoDA,SAAS9Z,SAAT","sourcesContent":["import { DataTextureLoader, FloatType, HalfFloatType, UnsignedByteType, RGBEFormat, RGBAFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = FloatType;\n};\n\nEXRLoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: EXRLoader,\n  parse: function (buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    var tmpDataView = new DataView(new ArrayBuffer(8));\n\n    function frexp(value) {\n      if (value === 0) return [value, 0];\n      tmpDataView.setFloat64(0, value);\n      var bits = tmpDataView.getUint32(0) >>> 20 & 0x7ff;\n\n      if (bits === 0) {\n        // denormal\n        tmpDataView.setFloat64(0, value * Math.pow(2, 64)); // exp + 64\n\n        bits = (tmpDataView.getUint32(0) >>> 20 & 0x7ff) - 64;\n      }\n\n      var exponent = bits - 1022;\n      var mantissa = ldexp(value, -exponent);\n      return [mantissa, exponent];\n    }\n\n    function ldexp(mantissa, exponent) {\n      var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n      var result = mantissa;\n\n      for (let i = 0; i < steps; i++) result *= Math.pow(2, Math.floor((exponent + i) / steps));\n\n      return result;\n    }\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (let i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (let i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (let i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (let i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (let i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (let i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (let t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (let i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (let i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n\n        let offset = 0;\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (let y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n\n          for (let x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n\n          for (let x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (let row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (let column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (let i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (let i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var tmpBufSize = info.width * scanlineBlockSize * (EXRHeader.channels.length * info.type);\n      var outBuffer = new Uint16Array(tmpBufSize);\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (let i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n\n      if (typeof fflate === 'undefined') {\n        console.error('THREE.EXRLoader: External library fflate.min.js required.');\n      }\n\n      var rawBuffer = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (EXRHeader.channels.length * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'; // Read channel ruleset information\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (let offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n\n        for (let i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (let i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (let y = 0; y < info.lines; ++y) {\n        for (let chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (let i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (let y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (let x = 0; x < cd.width; ++x) {\n                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseUlong(dataView, offset) {\n      var uLong = dataView.getUint32(0, true);\n      offset.value = offset.value + ULONG_SIZE;\n      return uLong;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseInt64(dataView, offset) {\n      var int = Number(dataView.getBigInt64(offset.value, true));\n      offset.value += ULONG_SIZE;\n      return int;\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    var bufferDataView = new DataView(buffer);\n    var uInt8Array = new Uint8Array(buffer);\n    var EXRHeader = {};\n    bufferDataView.getUint32(0, true); // magic\n\n    bufferDataView.getUint8(4, true); // versionByteZero\n\n    bufferDataView.getUint8(5, true); // fullMask\n    // start of header\n\n    var offset = {\n      value: 8\n    }; // start at 8, after magic stuff\n\n    var keepReading = true;\n\n    while (keepReading) {\n      var attributeName = parseNullTerminatedString(buffer, offset);\n\n      if (attributeName == 0) {\n        keepReading = false;\n      } else {\n        var attributeType = parseNullTerminatedString(buffer, offset);\n        var attributeSize = parseUint32(bufferDataView, offset);\n        var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n\n        if (attributeValue === undefined) {\n          console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n        } else {\n          EXRHeader[attributeName] = attributeValue;\n        }\n      }\n    } // offsets\n\n\n    var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n    var uncompress;\n    var scanlineBlockSize;\n\n    switch (EXRHeader.compression) {\n      case 'NO_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRAW;\n        break;\n\n      case 'RLE_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRLE;\n        break;\n\n      case 'ZIPS_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'ZIP_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'PIZ_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressPIZ;\n        break;\n\n      case 'PXR24_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressPXR;\n        break;\n\n      case 'DWAA_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressDWA;\n        break;\n\n      case 'DWAB_COMPRESSION':\n        scanlineBlockSize = 256;\n        uncompress = uncompressDWA;\n        break;\n\n      default:\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n    }\n\n    var size_t;\n    var getValue; // mixed pixelType not supported\n\n    var pixelType = EXRHeader.channels[0].pixelType;\n\n    if (pixelType === 1) {\n      // half\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat16;\n          size_t = INT16_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = parseUint16;\n          size_t = INT16_SIZE;\n          break;\n      }\n    } else if (pixelType === 2) {\n      // float\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat32;\n          size_t = FLOAT32_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = decodeFloat32;\n          size_t = FLOAT32_SIZE;\n      }\n    } else {\n      throw 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n    }\n\n    var numBlocks = dataWindowHeight / scanlineBlockSize;\n\n    for (let i = 0; i < numBlocks; i++) {\n      parseUlong(bufferDataView, offset); // scanlineOffset\n    } // we should be passed the scanline offset table, start reading pixel data\n\n\n    var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n    var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1; // Firefox only supports RGBA (half) float textures\n    // var numChannels = EXRHeader.channels.length;\n\n    var numChannels = 4;\n    var size = width * height * numChannels; // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n    switch (this.type) {\n      case UnsignedByteType:\n      case FloatType:\n        var byteArray = new Float32Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(1, 0, size);\n        }\n\n        break;\n\n      case HalfFloatType:\n        var byteArray = new Uint16Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n        }\n\n        break;\n\n      default:\n        console.error('THREE.EXRLoader: unsupported type: ', this.type);\n        break;\n    }\n\n    var channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3\n    };\n    var compressionInfo = {\n      size: 0,\n      width: width,\n      lines: scanlineBlockSize,\n      offset: offset,\n      array: uInt8Array,\n      viewer: bufferDataView,\n      type: pixelType,\n      channels: EXRHeader.channels.length\n    };\n    var line;\n    var size;\n    var viewer;\n    var tmpOffset = {\n      value: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n      line = parseUint32(bufferDataView, offset); // line_no\n\n      size = parseUint32(bufferDataView, offset); // data_len\n\n      compressionInfo.lines = line + scanlineBlockSize > height ? height - line : scanlineBlockSize;\n      compressionInfo.offset = offset;\n      compressionInfo.size = size;\n      viewer = uncompress(compressionInfo);\n      offset.value += size;\n\n      for (let line_y = 0; line_y < scanlineBlockSize; line_y++) {\n        var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n        if (true_y >= height) break;\n\n        for (let channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n          var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < width; x++) {\n            var idx = line_y * (EXRHeader.channels.length * width) + channelID * width + x;\n            tmpOffset.value = idx * size_t;\n            var val = getValue(viewer, tmpOffset);\n            byteArray[(height - 1 - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n          }\n        }\n      }\n    }\n\n    if (this.type === UnsignedByteType) {\n      let v, i;\n      const size = byteArray.length;\n      const RGBEArray = new Uint8Array(size);\n\n      for (let h = 0; h < height; ++h) {\n        for (let w = 0; w < width; ++w) {\n          i = h * width * 4 + w * 4;\n          const red = byteArray[i];\n          const green = byteArray[i + 1];\n          const blue = byteArray[i + 2];\n          v = red > green ? red : green;\n          v = blue > v ? blue : v;\n\n          if (v < 1e-32) {\n            RGBEArray[i] = RGBEArray[i + 1] = RGBEArray[i + 2] = RGBEArray[i + 3] = 0;\n          } else {\n            const res = frexp(v);\n            v = res[0] * 256 / v;\n            RGBEArray[i] = red * v;\n            RGBEArray[i + 1] = green * v;\n            RGBEArray[i + 2] = blue * v;\n            RGBEArray[i + 3] = res[1] + 128;\n          }\n        }\n      }\n\n      byteArray = RGBEArray;\n    }\n\n    const format = this.type === UnsignedByteType ? RGBEFormat : RGBAFormat ;\n    return {\n      header: EXRHeader,\n      width: width,\n      height: height,\n      data: byteArray,\n      format: format,\n      type: this.type\n    };\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n\n        case FloatType:\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\n\nexport { EXRLoader };\n"]},"metadata":{},"sourceType":"module"}