{"ast":null,"code":"import _objectSpread from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _get from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport { forwardRef, useRef, useCallback, useEffect, createElement } from 'react';\nvar $node = Symbol.for(\"Animated:node\");\n\nvar isAnimated = function isAnimated(value) {\n  return !!value && value[$node] === value;\n};\n\nvar getAnimated = function getAnimated(owner) {\n  return owner && owner[$node];\n};\n\nvar setAnimated = function setAnimated(owner, node) {\n  return defineHidden(owner, $node, node);\n};\n\nvar getPayload = function getPayload(owner) {\n  return owner && owner[$node] && owner[$node].getPayload();\n};\n\nvar Animated = /*#__PURE__*/function () {\n  function Animated() {\n    _classCallCheck(this, Animated);\n\n    setAnimated(this, this);\n  }\n\n  _createClass(Animated, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return this.payload || [];\n    }\n  }]);\n\n  return Animated;\n}();\n\nvar AnimatedValue = /*#__PURE__*/function (_Animated) {\n  _inherits(AnimatedValue, _Animated);\n\n  var _super = _createSuper(AnimatedValue);\n\n  function AnimatedValue(_value) {\n    var _this;\n\n    _classCallCheck(this, AnimatedValue);\n\n    _this = _super.call(this);\n    _this._value = _value;\n    _this.done = true;\n    _this.durationProgress = 0;\n\n    if (is.num(_this._value)) {\n      _this.lastPosition = _this._value;\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimatedValue, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return [this];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this._value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, step) {\n      if (is.num(value)) {\n        this.lastPosition = value;\n\n        if (step) {\n          value = Math.round(value / step) * step;\n\n          if (this.done) {\n            this.lastPosition = value;\n          }\n        }\n      }\n\n      if (this._value === value) {\n        return false;\n      }\n\n      this._value = value;\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var done = this.done;\n      this.done = false;\n\n      if (is.num(this._value)) {\n        this.elapsedTime = 0;\n        this.durationProgress = 0;\n        this.lastPosition = this._value;\n        if (done) this.lastVelocity = null;\n        this.v0 = null;\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedValue(value);\n    }\n  }]);\n\n  return AnimatedValue;\n}(Animated);\n\nvar AnimatedString = /*#__PURE__*/function (_AnimatedValue) {\n  _inherits(AnimatedString, _AnimatedValue);\n\n  var _super2 = _createSuper(AnimatedString);\n\n  function AnimatedString(value) {\n    var _this2;\n\n    _classCallCheck(this, AnimatedString);\n\n    _this2 = _super2.call(this, 0);\n    _this2._string = null;\n    _this2._toString = createInterpolator({\n      output: [value, value]\n    });\n    return _this2;\n  }\n\n  _createClass(AnimatedString, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var value = this._string;\n      return value == null ? this._string = this._toString(this._value) : value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (is.str(value)) {\n        if (value == this._string) {\n          return false;\n        }\n\n        this._string = value;\n        this._value = 1;\n      } else if (_get(_getPrototypeOf(AnimatedString.prototype), \"setValue\", this).call(this, value)) {\n        this._string = null;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(goal) {\n      if (goal) {\n        this._toString = createInterpolator({\n          output: [this.getValue(), goal]\n        });\n      }\n\n      this._value = 0;\n\n      _get(_getPrototypeOf(AnimatedString.prototype), \"reset\", this).call(this);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedString(value);\n    }\n  }]);\n\n  return AnimatedString;\n}(AnimatedValue);\n\nvar TreeContext = {\n  dependencies: null\n};\n\nvar AnimatedObject = /*#__PURE__*/function (_Animated2) {\n  _inherits(AnimatedObject, _Animated2);\n\n  var _super3 = _createSuper(AnimatedObject);\n\n  function AnimatedObject(source) {\n    var _this3;\n\n    _classCallCheck(this, AnimatedObject);\n\n    _this3 = _super3.call(this);\n    _this3.source = source;\n\n    _this3.setValue(source);\n\n    return _this3;\n  }\n\n  _createClass(AnimatedObject, [{\n    key: \"getValue\",\n    value: function getValue(animated) {\n      var values = {};\n      eachProp(this.source, function (source, key) {\n        if (isAnimated(source)) {\n          values[key] = source.getValue(animated);\n        } else if (hasFluidValue(source)) {\n          values[key] = getFluidValue(source);\n        } else if (!animated) {\n          values[key] = source;\n        }\n      });\n      return values;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      this.source = source;\n      this.payload = this._makePayload(source);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.payload) {\n        each(this.payload, function (node) {\n          return node.reset();\n        });\n      }\n    }\n  }, {\n    key: \"_makePayload\",\n    value: function _makePayload(source) {\n      if (source) {\n        var payload = new Set();\n        eachProp(source, this._addToPayload, payload);\n        return Array.from(payload);\n      }\n    }\n  }, {\n    key: \"_addToPayload\",\n    value: function _addToPayload(source) {\n      var _this4 = this;\n\n      if (TreeContext.dependencies && hasFluidValue(source)) {\n        TreeContext.dependencies.add(source);\n      }\n\n      var payload = getPayload(source);\n\n      if (payload) {\n        each(payload, function (node) {\n          return _this4.add(node);\n        });\n      }\n    }\n  }]);\n\n  return AnimatedObject;\n}(Animated);\n\nvar AnimatedArray = /*#__PURE__*/function (_AnimatedObject) {\n  _inherits(AnimatedArray, _AnimatedObject);\n\n  var _super4 = _createSuper(AnimatedArray);\n\n  function AnimatedArray(source) {\n    _classCallCheck(this, AnimatedArray);\n\n    return _super4.call(this, source);\n  }\n\n  _createClass(AnimatedArray, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.source.map(function (node) {\n        return node.getValue();\n      });\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      var payload = this.getPayload();\n\n      if (source.length == payload.length) {\n        return payload.some(function (node, i) {\n          return node.setValue(source[i]);\n        });\n      }\n\n      _get(_getPrototypeOf(AnimatedArray.prototype), \"setValue\", this).call(this, source.map(makeAnimated));\n\n      return true;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(source) {\n      return new AnimatedArray(source);\n    }\n  }]);\n\n  return AnimatedArray;\n}(AnimatedObject);\n\nfunction makeAnimated(value) {\n  var nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  var parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nvar withAnimated = function withAnimated(Component, host) {\n  var hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef(function (givenProps, givenRef) {\n    var instanceRef = useRef(null);\n    var ref = hasInstance && useCallback(function (value) {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n\n    var _getAnimatedState = getAnimatedState(givenProps, host),\n        _getAnimatedState2 = _slicedToArray(_getAnimatedState, 2),\n        props = _getAnimatedState2[0],\n        deps = _getAnimatedState2[1];\n\n    var forceUpdate = useForceUpdate();\n\n    var callback = function callback() {\n      var instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    var observer = new PropsObserver(callback, deps);\n    var observerRef = useRef();\n    useLayoutEffect(function () {\n      var lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, function (dep) {\n        return addFluidObserver(dep, observer);\n      });\n\n      if (lastObserver) {\n        each(lastObserver.deps, function (dep) {\n          return removeFluidObserver(dep, lastObserver);\n        });\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(function () {\n      return function () {\n        var observer2 = observerRef.current;\n        each(observer2.deps, function (dep) {\n          return removeFluidObserver(dep, observer2);\n        });\n      };\n    });\n    var usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */createElement(Component, _objectSpread(_objectSpread({}, usedProps), {}, {\n      ref: ref\n    }));\n  });\n};\n\nvar PropsObserver = /*#__PURE__*/function () {\n  function PropsObserver(update, deps) {\n    _classCallCheck(this, PropsObserver);\n\n    this.update = update;\n    this.deps = deps;\n  }\n\n  _createClass(PropsObserver, [{\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == \"change\") {\n        raf.write(this.update);\n      }\n    }\n  }]);\n\n  return PropsObserver;\n}();\n\nfunction getAnimatedState(props, host) {\n  var dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _objectSpread(_objectSpread({}, props), {}, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nvar cacheKey = Symbol.for(\"AnimatedComponent\");\n\nvar createHost = function createHost(components) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$applyAnimatedVal = _ref.applyAnimatedValues,\n      applyAnimatedValues = _ref$applyAnimatedVal === void 0 ? function () {\n    return false;\n  } : _ref$applyAnimatedVal,\n      _ref$createAnimatedSt = _ref.createAnimatedStyle,\n      createAnimatedStyle = _ref$createAnimatedSt === void 0 ? function (style) {\n    return new AnimatedObject(style);\n  } : _ref$createAnimatedSt,\n      _ref$getComponentProp = _ref.getComponentProps,\n      getComponentProps = _ref$getComponentProp === void 0 ? function (props) {\n    return props;\n  } : _ref$getComponentProp;\n\n  var hostConfig = {\n    applyAnimatedValues: applyAnimatedValues,\n    createAnimatedStyle: createAnimatedStyle,\n    getComponentProps: getComponentProps\n  };\n\n  var animated = function animated(Component) {\n    var displayName = getDisplayName(Component) || \"Anonymous\";\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = \"Animated(\".concat(displayName, \")\");\n    return Component;\n  };\n\n  eachProp(components, function (Component, key) {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated: animated\n  };\n};\n\nvar getDisplayName = function getDisplayName(arg) {\n  return is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n};\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedValue.ts","src/AnimatedString.ts","src/context.ts","src/AnimatedObject.ts","src/AnimatedArray.ts","src/getAnimatedType.ts","src/withAnimated.tsx","src/createHost.ts"],"names":["AnimatedString2","AnimatedValue2","AnimatedArray2","AnimatedObject2","withAnimated2"],"mappings":"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","sourcesContent":["import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport { forwardRef, useRef, useCallback, useEffect, createElement } from 'react';\n\nconst $node = Symbol.for(\"Animated:node\");\nconst isAnimated = (value) => !!value && value[$node] === value;\nconst getAnimated = (owner) => owner && owner[$node];\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\nconst getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n  getPayload() {\n    return this.payload || [];\n  }\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.durationProgress = 0;\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n  getPayload() {\n    return [this];\n  }\n  getValue() {\n    return this._value;\n  }\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n      if (step) {\n        value = Math.round(value / step) * step;\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n    if (this._value === value) {\n      return false;\n    }\n    this._value = value;\n    return true;\n  }\n  reset() {\n    const {done} = this;\n    this.done = false;\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done)\n        this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n  static create(value) {\n    return new AnimatedString(value);\n  }\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n    return true;\n  }\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n    this._value = 0;\n    super.reset();\n  }\n}\n\nconst TreeContext = {dependencies: null};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n  reset() {\n    if (this.payload) {\n      each(this.payload, (node) => node.reset());\n    }\n  }\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n    const payload = getPayload(source);\n    if (payload) {\n      each(payload, (node) => this.add(node));\n    }\n  }\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n  getValue() {\n    return this.source.map((node) => node.getValue());\n  }\n  setValue(source) {\n    const payload = this.getPayload();\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n}\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback((value) => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n    const callback = () => {\n      const instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, (dep) => addFluidObserver(dep, observer));\n      if (lastObserver) {\n        each(lastObserver.deps, (dep) => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */ createElement(Component, {\n      ...usedProps,\n      ref\n    });\n  });\n};\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n}\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style)\n    };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref))\n      ref(value);\n    else\n      ref.current = value;\n  }\n  return value;\n}\n\nconst cacheKey = Symbol.for(\"AnimatedComponent\");\nconst createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = (style) => new AnimatedObject(style),\n  getComponentProps = (props) => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n  const animated = (Component) => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\nconst getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}