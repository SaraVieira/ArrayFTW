{"ast":null,"code":"import _slicedToArray from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format } from 'three';\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nvar BasisTextureLoader = function BasisTextureLoader(manager) {\n  Loader.call(this, manager);\n  this.transcoderPath = '';\n  this.transcoderBinary = null;\n  this.transcoderPending = null;\n  this.workerLimit = 4;\n  this.workerPool = [];\n  this.workerNextTaskID = 1;\n  this.workerSourceURL = '';\n  this.workerConfig = null;\n};\n\nBasisTextureLoader.taskCache = new WeakMap();\nBasisTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: BasisTextureLoader,\n  setTranscoderPath: function setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  },\n  setWorkerLimit: function setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  },\n  detectSupport: function detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n    return this;\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    var _this = this;\n\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    var texture = new CompressedTexture();\n    loader.load(url, function (buffer) {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (BasisTextureLoader.taskCache.has(buffer)) {\n        var cachedTask = BasisTextureLoader.taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      _this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  },\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync: function parseInternalAsync(options) {\n    var levels = options.levels;\n    var buffers = new Set();\n\n    for (var i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n\n    return this._createTexture(Array.from(buffers), _objectSpread(_objectSpread({}, options), {}, {\n      lowLevel: true\n    }));\n  },\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture: function _createTexture(buffers, config) {\n    var _this2 = this;\n\n    var worker;\n    var taskID;\n    var taskConfig = config || {};\n    var taskCost = 0;\n\n    for (var i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n\n    var texturePending = this._allocateWorker(taskCost).then(function (_worker) {\n      worker = _worker;\n      taskID = _this2.workerNextTaskID++;\n      return new Promise(function (resolve, reject) {\n        worker._callbacks[taskID] = {\n          resolve: resolve,\n          reject: reject\n        };\n        worker.postMessage({\n          type: 'transcode',\n          id: taskID,\n          buffers: buffers,\n          taskConfig: taskConfig\n        }, buffers);\n      });\n    }).then(function (message) {\n      var mipmaps = message.mipmaps,\n          width = message.width,\n          height = message.height,\n          format = message.format;\n      var texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    texturePending.catch(function () {\n      return true;\n    }).then(function () {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    }); // Cache the task result.\n\n    BasisTextureLoader.taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n    return texturePending;\n  },\n  _initTranscoder: function _initTranscoder() {\n    var _this3 = this;\n\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      var jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      var jsContent = new Promise(function (resolve, reject) {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\n      }); // Load transcoder WASM binary.\n\n      var binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      var binaryContent = new Promise(function (resolve, reject) {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            jsContent = _ref2[0],\n            binaryContent = _ref2[1];\n\n        var fn = BasisTextureLoader.BasisWorker.toString();\n        var body = ['/* constants */', 'var _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'var _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'var _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this3.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        _this3.transcoderBinary = binaryContent;\n      });\n    }\n\n    return this.transcoderPending;\n  },\n  _allocateWorker: function _allocateWorker(taskCost) {\n    var _this4 = this;\n\n    return this._initTranscoder().then(function () {\n      if (_this4.workerPool.length < _this4.workerLimit) {\n        var worker = new Worker(_this4.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          config: _this4.workerConfig,\n          transcoderBinary: _this4.transcoderBinary\n        });\n\n        worker.onmessage = function (e) {\n          var message = e.data;\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        _this4.workerPool.push(worker);\n      } else {\n        _this4.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      var worker = _this4.workerPool[_this4.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  },\n  dispose: function dispose() {\n    for (var i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n});\n/* CONSTANTS */\n\nBasisTextureLoader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nBasisTextureLoader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nBasisTextureLoader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nBasisTextureLoader.BasisWorker = function () {\n  var config;\n  var transcoderPending;\n  var BasisModule;\n  var EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  var TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  var BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  onmessage = function onmessage(e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(function () {\n          try {\n            var _ref3 = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]),\n                width = _ref3.width,\n                height = _ref3.height,\n                hasAlpha = _ref3.hasAlpha,\n                mipmaps = _ref3.mipmaps,\n                format = _ref3.format;\n\n            var buffers = [];\n\n            for (var i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width: width,\n              height: height,\n              hasAlpha: hasAlpha,\n              mipmaps: mipmaps,\n              format: format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(function (resolve) {\n      BasisModule = {\n        wasmBinary: wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(function () {\n      BasisModule.initializeBasis();\n    });\n  }\n\n  function transcodeLowLevel(taskConfig) {\n    var basisFormat = taskConfig.basisFormat,\n        width = taskConfig.width,\n        height = taskConfig.height,\n        hasAlpha = taskConfig.hasAlpha;\n\n    var _getTranscoderFormat = getTranscoderFormat(basisFormat, width, height, hasAlpha),\n        transcoderFormat = _getTranscoderFormat.transcoderFormat,\n        engineFormat = _getTranscoderFormat.engineFormat;\n\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\n    var mipmaps = [];\n\n    if (basisFormat === BasisFormat.ETC1S) {\n      var transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      var _taskConfig$globalDat = taskConfig.globalData,\n          endpointCount = _taskConfig$globalDat.endpointCount,\n          endpointsData = _taskConfig$globalDat.endpointsData,\n          selectorCount = _taskConfig$globalDat.selectorCount,\n          selectorsData = _taskConfig$globalDat.selectorsData,\n          tablesData = _taskConfig$globalDat.tablesData;\n\n      try {\n        var ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\n\n        for (var i = 0; i < taskConfig.levels.length; i++) {\n          var level = taskConfig.levels[i];\n          var imageDesc = taskConfig.globalData.imageDescs[i];\n          var dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          var dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (var _i = 0; _i < taskConfig.levels.length; _i++) {\n        var level = taskConfig.levels[_i];\n        var dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        var dst = new Uint8Array(dstByteLength);\n        var ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n\n    return {\n      width: width,\n      height: height,\n      hasAlpha: hasAlpha,\n      mipmaps: mipmaps,\n      format: engineFormat\n    };\n  }\n\n  function transcode(buffer) {\n    var basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    var basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    var width = basisFile.getImageWidth(0, 0);\n    var height = basisFile.getImageHeight(0, 0);\n    var levels = basisFile.getNumLevels(0);\n    var hasAlpha = basisFile.getHasAlpha();\n\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n\n    var _getTranscoderFormat2 = getTranscoderFormat(basisFormat, width, height, hasAlpha),\n        transcoderFormat = _getTranscoderFormat2.transcoderFormat,\n        engineFormat = _getTranscoderFormat2.engineFormat;\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\n    }\n\n    var mipmaps = [];\n\n    for (var mip = 0; mip < levels; mip++) {\n      var mipWidth = basisFile.getImageWidth(0, mip);\n      var mipHeight = basisFile.getImageHeight(0, mip);\n      var dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      var status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width: width,\n      height: height,\n      hasAlpha: hasAlpha,\n      mipmaps: mipmaps,\n      format: engineFormat\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  var FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  var ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  var UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    var transcoderFormat;\n    var engineFormat;\n    var options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (var i = 0; i < options.length; i++) {\n      var opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat: transcoderFormat,\n        engineFormat: engineFormat\n      };\n    }\n\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat: transcoderFormat,\n      engineFormat: engineFormat\n    };\n  }\n\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      // GL requires extra padding for very small textures:\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n      var paddedWidth = width + 3 & ~3;\n      var paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n};\n\nexport { BasisTextureLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/BasisTextureLoader.js"],"names":["Loader","FileLoader","CompressedTexture","UnsignedByteType","LinearFilter","LinearMipmapLinearFilter","RGBAFormat","RGBA_ASTC_4x4_Format","RGBA_BPTC_Format","RGBA_ETC2_EAC_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGB_PVRTC_4BPPV1_Format","RGB_S3TC_DXT1_Format","BasisTextureLoader","manager","call","transcoderPath","transcoderBinary","transcoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","workerConfig","taskCache","WeakMap","prototype","Object","assign","create","constructor","setTranscoderPath","path","setWorkerLimit","detectSupport","renderer","astcSupported","extensions","has","etc1Supported","etc2Supported","dxtSupported","bptcSupported","pvrtcSupported","load","url","onLoad","onProgress","onError","loader","setResponseType","setWithCredentials","withCredentials","texture","buffer","cachedTask","get","promise","then","catch","_createTexture","_texture","copy","needsUpdate","parseInternalAsync","options","levels","buffers","Set","i","length","add","data","Array","from","lowLevel","config","worker","taskID","taskConfig","taskCost","byteLength","texturePending","_allocateWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","message","mipmaps","width","height","format","minFilter","magFilter","generateMipmaps","_taskLoad","set","_initTranscoder","jsLoader","setPath","jsContent","undefined","binaryLoader","binaryContent","all","fn","BasisWorker","toString","body","JSON","stringify","EngineFormat","TranscoderFormat","BasisFormat","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","onmessage","e","console","error","push","sort","a","b","dispose","terminate","ETC1S","UASTC_4x4","ETC1","ETC2","BC1","BC3","BC4","BC5","BC7_M6_OPAQUE_ONLY","BC7_M5","PVRTC1_4_RGB","PVRTC1_4_RGBA","ASTC_4x4","ATC_RGB","ATC_RGBA_INTERPOLATED_ALPHA","RGBA32","RGB565","BGR565","RGBA4444","BasisModule","_EngineFormat","_TranscoderFormat","_BasisFormat","init","transcodeLowLevel","transcode","hasAlpha","self","wasmBinary","onRuntimeInitialized","BASIS","initializeBasis","basisFormat","getTranscoderFormat","transcoderFormat","engineFormat","blockByteLength","getBytesPerBlockOrPixel","assert","isFormatSupported","transcoder","LowLevelETC1SImageTranscoder","globalData","endpointCount","endpointsData","selectorCount","selectorsData","tablesData","ok","decodePalettes","decodeTables","level","imageDesc","imageDescs","dstByteLength","getTranscodedImageByteLength","dst","Uint8Array","transcodeImage","getWidthInBlocks","getHeightInBlocks","index","rgbSliceByteOffset","rgbSliceByteLength","alphaSliceByteOffset","alphaSliceByteLength","imageFlags","delete","transcodeUASTCImage","basisFile","BasisFile","isUASTC","getImageWidth","getImageHeight","getNumLevels","getHasAlpha","cleanup","close","Error","startTranscoding","mip","mipWidth","mipHeight","getImageTranscodedSizeInBytes","status","FORMAT_OPTIONS","if","priorityETC1S","Infinity","priorityUASTC","needsPowerOfTwo","ETC1S_OPTIONS","UASTC_OPTIONS","opt","includes","isPowerOfTwo","warn","Math","ceil","getFormatBlockWidth","getFormatBlockHeight","formatIsUncompressed","paddedWidth","paddedHeight","max","value"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format } from 'three';\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nvar BasisTextureLoader = function (manager) {\n  Loader.call(this, manager);\n  this.transcoderPath = '';\n  this.transcoderBinary = null;\n  this.transcoderPending = null;\n  this.workerLimit = 4;\n  this.workerPool = [];\n  this.workerNextTaskID = 1;\n  this.workerSourceURL = '';\n  this.workerConfig = null;\n};\n\nBasisTextureLoader.taskCache = new WeakMap();\nBasisTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: BasisTextureLoader,\n  setTranscoderPath: function (path) {\n    this.transcoderPath = path;\n    return this;\n  },\n  setWorkerLimit: function (workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  },\n  detectSupport: function (renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    var texture = new CompressedTexture();\n    loader.load(url, buffer => {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (BasisTextureLoader.taskCache.has(buffer)) {\n        var cachedTask = BasisTextureLoader.taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  },\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync: function (options) {\n    var {\n      levels\n    } = options;\n    var buffers = new Set();\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options,\n      lowLevel: true\n    });\n  },\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture: function (buffers, config) {\n    var worker;\n    var taskID;\n    var taskConfig = config || {};\n    var taskCost = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n\n    var texturePending = this._allocateWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'transcode',\n          id: taskID,\n          buffers: buffers,\n          taskConfig: taskConfig\n        }, buffers);\n      });\n    }).then(message => {\n      var {\n        mipmaps,\n        width,\n        height,\n        format\n      } = message;\n      var texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    texturePending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    }); // Cache the task result.\n\n    BasisTextureLoader.taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n    return texturePending;\n  },\n  _initTranscoder: function () {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      var jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      var jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\n      }); // Load transcoder WASM binary.\n\n      var binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      var binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        var fn = BasisTextureLoader.BasisWorker.toString();\n        var body = ['/* constants */', 'var _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'var _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'var _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent;\n      });\n    }\n\n    return this.transcoderPending;\n  },\n  _allocateWorker: function (taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        var worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary\n        });\n\n        worker.onmessage = function (e) {\n          var message = e.data;\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      var worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  },\n  dispose: function () {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n});\n/* CONSTANTS */\n\nBasisTextureLoader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nBasisTextureLoader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nBasisTextureLoader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nBasisTextureLoader.BasisWorker = function () {\n  var config;\n  var transcoderPending;\n  var BasisModule;\n  var EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  var TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  var BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  onmessage = function (e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            var {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n            var buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n    });\n  }\n\n  function transcodeLowLevel(taskConfig) {\n    var {\n      basisFormat,\n      width,\n      height,\n      hasAlpha\n    } = taskConfig;\n    var {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\n    var mipmaps = [];\n\n    if (basisFormat === BasisFormat.ETC1S) {\n      var transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      var {\n        endpointCount,\n        endpointsData,\n        selectorCount,\n        selectorsData,\n        tablesData\n      } = taskConfig.globalData;\n\n      try {\n        var ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\n\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          var level = taskConfig.levels[i];\n          var imageDesc = taskConfig.globalData.imageDescs[i];\n          var dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          var dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (let i = 0; i < taskConfig.levels.length; i++) {\n        var level = taskConfig.levels[i];\n        var dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        var dst = new Uint8Array(dstByteLength);\n        var ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n\n  function transcode(buffer) {\n    var basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    var basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    var width = basisFile.getImageWidth(0, 0);\n    var height = basisFile.getImageHeight(0, 0);\n    var levels = basisFile.getNumLevels(0);\n    var hasAlpha = basisFile.getHasAlpha();\n\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n\n    var {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\n    }\n\n    var mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      var mipWidth = basisFile.getImageWidth(0, mip);\n      var mipHeight = basisFile.getImageHeight(0, mip);\n      var dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      var status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  var FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  var ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  var UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    var transcoderFormat;\n    var engineFormat;\n    var options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      var opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      // GL requires extra padding for very small textures:\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n      var paddedWidth = width + 3 & ~3;\n      var paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n};\n\nexport { BasisTextureLoader };\n"]},"metadata":{},"sourceType":"module"}