{"ast":null,"code":"import { Vector3 } from 'three';\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nvar hilbert2D = function hilbert2D(center, size, iterations, v0, v1, v2, v3) {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3;\n  var vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nvar hilbert3D = function hilbert3D(center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3,\n      v4 = v4 !== undefined ? v4 : 4,\n      v5 = v5 !== undefined ? v5 : 5,\n      v6 = v6 !== undefined ? v6 : 6,\n      v7 = v7 !== undefined ? v7 : 7;\n  var vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nvar gosper = function gosper(size) {\n  size = size !== undefined ? size : 1;\n\n  function fractalize(config) {\n    var output;\n    var input = config.axiom;\n\n    for (var i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (var j = 0, jl = input.length; j < jl; j++) {\n        var char = input[j];\n\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    var currX = 0,\n        currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n\n    for (var i = 0, l = fractal.length; i < l; i++) {\n      var char = fractal[i];\n\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nexport { gosper, hilbert2D, hilbert3D };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/utils/GeometryUtils.js"],"names":["Vector3","hilbert2D","center","size","iterations","v0","v1","v2","v3","undefined","half","vec_s","x","y","z","vec","tmp","Array","prototype","push","apply","hilbert3D","v4","v5","v6","v7","gosper","fractalize","config","output","input","axiom","i","il","steps","j","jl","length","char","rules","toPoints","currX","currY","angle","path","fractal","l","Math","cos","sin","A","B","points","PI"],"mappings":"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","sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nconst hilbert2D = (center, size, iterations, v0, v1, v2, v3) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3;\n  var vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nconst hilbert3D = (center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3,\n      v4 = v4 !== undefined ? v4 : 4,\n      v5 = v5 !== undefined ? v5 : 5,\n      v6 = v6 !== undefined ? v6 : 6,\n      v7 = v7 !== undefined ? v7 : 7;\n  var vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nconst gosper = size => {\n  size = size !== undefined ? size : 1;\n\n  function fractalize(config) {\n    var output;\n    var input = config.axiom;\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        var char = input[j];\n\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    var currX = 0,\n        currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      var char = fractal[i];\n\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nexport { gosper, hilbert2D, hilbert3D };\n"]},"metadata":{},"sourceType":"module"}