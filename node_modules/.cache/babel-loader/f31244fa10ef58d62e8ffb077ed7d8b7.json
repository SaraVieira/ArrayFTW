{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nvar ColladaLoader = function ColladaLoader(manager) {\n  Loader.call(this, manager);\n};\n\nColladaLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: ColladaLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n\n  },\n  parse: function parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for (var i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n\n        for (var i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (var name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      var hasChildren = false;\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n\n        for (var i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for (var target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (var time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (var i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    var position = new Vector3();\n    var scale = new Vector3();\n    var quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n\n      for (var i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n\n        for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      var data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      var parameters = technique.parameters;\n\n      for (var key in parameters) {\n        var parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      var camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      var data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      var light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      var data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (var i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      var build = {};\n\n      for (var i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n\n      for (var i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n\n      for (var type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n\n      for (var p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (var g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (var name in inputs) {\n          var input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (var key in vertices) {\n                var id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n\n                      for (var i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n\n        for (var i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (var k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n          pushVector(_i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      var data;\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      var m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function getJointValue(jointIndex) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function setJointValue(jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            var joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                var transform = transforms[_i2]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            var angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    var matrix = new Matrix4();\n    var vector = new Vector3();\n\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n\n            for (var j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n\n          for (var _j = 0; _j < children.length; _j++) {\n            var child = children[_j];\n\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      var bones = [];\n      var boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (var i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n        var instanceCamera = getCamera(instanceCameras[_i3]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n        var instance = instanceControllers[_i4];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n        var instanceLight = getLight(instanceLights[_i5]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n        var instance = instanceGeometries[_i6]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n\n        for (var _j2 = 0, _jl = newObjects.length; _j2 < _jl; _j2++) {\n          objects.push(newObjects[_j2]);\n        }\n      } // instance nodes\n\n\n      for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n        objects.push(getNode(instanceNodes[_i7]).clone());\n      }\n\n      var object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (var _i8 = 0; _i8 < objects.length; _i8++) {\n          object.add(objects[_i8]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    var fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n\n      for (var type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (var i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n\n      for (var i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      var group = new Group();\n      group.name = data.name;\n      var children = data.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      var clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n\n          for (var id in library.animations) {\n            var animationTracks = getAnimation(id);\n\n            for (var i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (var _id in clips) {\n          animations.push(getAnimationClip(_id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      var result = '';\n      var stack = [parserError];\n\n      while (stack.length) {\n        var node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0];\n    var parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      var errorElement = getElementsByTagName(parserError, 'div')[0];\n      var errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n});\nexport { ColladaLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/ColladaLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Vector3","Quaternion","Matrix4","MeshBasicMaterial","Scene","TextureLoader","Euler","MathUtils","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","MeshLambertMaterial","MeshPhongMaterial","DoubleSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","RepeatWrapping","ClampToEdgeWrapping","TGALoader","ColladaLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","options","convertUpAxis","value","warn","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nvar ColladaLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nColladaLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: ColladaLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n\n  },\n  parse: function (text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (let name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      var hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for (let target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (let time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    var position = new Vector3();\n    var scale = new Vector3();\n    var quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      var data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      var parameters = technique.parameters;\n\n      for (let key in parameters) {\n        var parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      var camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      var data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      var light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      var data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      var build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n\n      for (let type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (let name in inputs) {\n          var input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (let key in vertices) {\n                var id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      var data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      var m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            var joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                var transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            var angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        var element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    var matrix = new Matrix4();\n    var vector = new Vector3();\n\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            var child = children[j];\n\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      var bones = [];\n      var boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      var object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    var fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n\n      for (let type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (let i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      var group = new Group();\n      group.name = data.name;\n      var children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      var clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n\n          for (let id in library.animations) {\n            var animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (let id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      var result = '';\n      var stack = [parserError];\n\n      while (stack.length) {\n        var node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0];\n    var parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      var errorElement = getElementsByTagName(parserError, 'div')[0];\n      var errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n});\n\nexport { ColladaLoader };\n"]},"metadata":{},"sourceType":"module"}