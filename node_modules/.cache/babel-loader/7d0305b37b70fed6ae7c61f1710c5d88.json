{"ast":null,"code":"import _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Mesh, BoxGeometry, Vector3, ShaderMaterial, UniformsUtils, BackSide } from 'three';\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\n\nvar Sky = /*#__PURE__*/function (_Mesh) {\n  _inherits(Sky, _Mesh);\n\n  var _super = _createSuper(Sky);\n\n  function Sky() {\n    _classCallCheck(this, Sky);\n\n    return _super.call(this, new BoxGeometry(1, 1, 1), Sky.material);\n  }\n\n  return Sky;\n}(Mesh);\n\n_defineProperty(Sky, \"SkyShader\", {\n  uniforms: {\n    turbidity: {\n      value: 2\n    },\n    rayleigh: {\n      value: 1\n    },\n    mieCoefficient: {\n      value: 0.005\n    },\n    mieDirectionalG: {\n      value: 0.8\n    },\n    sunPosition: {\n      value: new Vector3()\n    },\n    up: {\n      value: new Vector3(0, 1, 0)\n    }\n  },\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\n  // K coefficient for the primaries\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\n  // rayleigh coefficients\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n  // optical length at zenith for molecules\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\n  // cutoff angle at 90 to avoid singularity in next formula.\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\n});\n\n_defineProperty(Sky, \"material\", new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: Sky.SkyShader.fragmentShader,\n  vertexShader: Sky.SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false\n}));\n\nexport { Sky };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/Sky.js"],"names":["_defineProperty","Mesh","BoxGeometry","Vector3","ShaderMaterial","UniformsUtils","BackSide","Sky","material","uniforms","turbidity","value","rayleigh","mieCoefficient","mieDirectionalG","sunPosition","up","vertexShader","join","fragmentShader","name","SkyShader","clone","side","depthWrite"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Mesh, BoxGeometry, Vector3, ShaderMaterial, UniformsUtils, BackSide } from 'three';\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\n\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), Sky.material);\n  }\n\n}\n\n_defineProperty(Sky, \"SkyShader\", {\n  uniforms: {\n    turbidity: {\n      value: 2\n    },\n    rayleigh: {\n      value: 1\n    },\n    mieCoefficient: {\n      value: 0.005\n    },\n    mieDirectionalG: {\n      value: 0.8\n    },\n    sunPosition: {\n      value: new Vector3()\n    },\n    up: {\n      value: new Vector3(0, 1, 0)\n    }\n  },\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\n  // K coefficient for the primaries\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\n  // rayleigh coefficients\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n  // optical length at zenith for molecules\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\n  // cutoff angle at 90 to avoid singularity in next formula.\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\n});\n\n_defineProperty(Sky, \"material\", new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: Sky.SkyShader.fragmentShader,\n  vertexShader: Sky.SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false\n}));\n\nexport { Sky };\n"]},"metadata":{},"sourceType":"module"}