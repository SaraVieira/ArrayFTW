{"ast":null,"code":"import { Vector3, Matrix3 } from 'three';\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nvar PLYExporter = function PLYExporter() {};\n\nPLYExporter.prototype = {\n  constructor: PLYExporter,\n  parse: function parse(object, onDone, options) {\n    if (onDone && typeof onDone === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Iterate over the valid meshes in the object\n\n\n    function traverseMeshes(cb) {\n      object.traverse(function (child) {\n        if (child.isMesh === true) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    } // Default options\n\n\n    var defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    var excludeAttributes = options.excludeAttributes;\n    var includeNormals = false;\n    var includeColors = false;\n    var includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    var vertexCount = 0;\n    var faceCount = 0;\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        var mesh = child;\n        var geometry = mesh.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n\n        if (vertices === undefined) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    var includeIndices = excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n\n    var indexByteCount = 4;\n    var header = // position\n    \"ply\\n\".concat(\"format \".concat(options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii', \" 1.0\\n\"), \"element vertex \".concat(vertexCount, \"\\n\"), \"property float x\\nproperty float y\\nproperty float z\\n\");\n\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n\n    if (includeIndices === true) {\n      // faces\n      header += \"\".concat(\"element face \".concat(faceCount, \"\\n\"), \"property list uchar int vertex_index\\n\");\n    }\n\n    header += 'end_header\\n'; // Generate attribute data\n\n    var vertex = new Vector3();\n    var normalMatrixWorld = new Matrix3();\n    var result = null;\n\n    if (options.binary === true) {\n      // Binary File Generation\n      var headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      var vOffset = headerBin.length;\n      var fOffset = headerBin.length + vertexListLength;\n      var writtenVertices = 0;\n      traverseMeshes(function (mesh, geometry) {\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (var i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (includeUVs !== false) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices === true) {\n          // Create the face list\n          if (indices !== null) {\n            for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      var writtenVertices = 0;\n      var vertexList = '';\n      var faceList = '';\n      traverseMeshes(function (mesh, geometry) {\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (var i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          var line = \"\".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z); // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z);\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += \" \".concat(uvs.getX(i), \" \").concat(uvs.getY(i));\n            } else if (includeUVs !== false) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              line += \" \".concat(Math.floor(colors.getX(i) * 255), \" \").concat(Math.floor(colors.getY(i) * 255), \" \").concat(Math.floor(colors.getZ(i) * 255));\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n\n          vertexList += \"\".concat(line, \"\\n\");\n        } // Create the face list\n\n\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n              faceList += \"3 \".concat(indices.getX(_i3 + 0) + writtenVertices);\n              faceList += \" \".concat(indices.getX(_i3 + 1) + writtenVertices);\n              faceList += \" \".concat(indices.getX(_i3 + 2) + writtenVertices, \"\\n\");\n            }\n          } else {\n            for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n              faceList += \"3 \".concat(writtenVertices + _i4, \" \").concat(writtenVertices + _i4 + 1, \" \").concat(writtenVertices + _i4 + 2, \"\\n\");\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = \"\".concat(header).concat(vertexList).concat(includeIndices ? \"\".concat(faceList, \"\\n\") : '\\n');\n    }\n\n    if (typeof onDone === 'function') requestAnimationFrame(function () {\n      return onDone(result);\n    });\n    return result;\n  }\n};\nexport { PLYExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/PLYExporter.js"],"names":["Vector3","Matrix3","PLYExporter","prototype","constructor","parse","object","onDone","options","console","warn","undefined","traverseMeshes","cb","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","hasAttribute","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame"],"mappings":"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","sourcesContent":["import { Vector3, Matrix3 } from 'three';\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nconst PLYExporter = () => {};\n\nPLYExporter.prototype = {\n  constructor: PLYExporter,\n  parse: function (object, onDone, options) {\n    if (onDone && typeof onDone === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Iterate over the valid meshes in the object\n\n\n    function traverseMeshes(cb) {\n      object.traverse(child => {\n        if (child.isMesh === true) {\n          const mesh = child;\n          const geometry = mesh.geometry;\n\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    } // Default options\n\n\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n\n        if (vertices === undefined) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    const includeIndices = excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n\n    const indexByteCount = 4;\n    let header = // position\n    `ply\\n${`format ${options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii'} 1.0\\n`}${`element vertex ${vertexCount}\\n`}property float x\\nproperty float y\\nproperty float z\\n`;\n\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n\n    if (includeIndices === true) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`;\n    }\n\n    header += 'end_header\\n'; // Generate attribute data\n\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n\n    if (options.binary === true) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      var writtenVertices = 0;\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (includeUVs !== false) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices === true) {\n          // Create the face list\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      var writtenVertices = 0;\n      let vertexList = '';\n      let faceList = '';\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          let line = `${vertex.x} ${vertex.y} ${vertex.z}`; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += ` ${vertex.x} ${vertex.y} ${vertex.z}`;\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += ` ${uvs.getX(i)} ${uvs.getY(i)}`;\n            } else if (includeUVs !== false) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              line += ` ${Math.floor(colors.getX(i) * 255)} ${Math.floor(colors.getY(i) * 255)} ${Math.floor(colors.getZ(i) * 255)}`;\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n\n          vertexList += `${line}\\n`;\n        } // Create the face list\n\n\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`;\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`;\n    }\n\n    if (typeof onDone === 'function') requestAnimationFrame(() => onDone(result));\n    return result;\n  }\n};\n\nexport { PLYExporter };\n"]},"metadata":{},"sourceType":"module"}