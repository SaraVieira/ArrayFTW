{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function buildKernel(sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    var i,\n        values,\n        sum,\n        halfWidth,\n        kMaxKernelSize = 25,\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] /= sum;\n    }\n\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/ConvolutionShader.js"],"names":["Vector2","ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kMaxKernelSize","kernelSize","ceil","Array"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,iBAAiB,GAAG;AACtBC,EAAAA,OAAO,EAAE;AACPC,IAAAA,iBAAiB,EAAE,MADZ;AAEPC,IAAAA,eAAe,EAAE;AAFV,GADa;AAKtBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAE;AADC,KADF;AAIRC,IAAAA,eAAe,EAAE;AACfD,MAAAA,KAAK,EAAE,IAAIP,OAAJ,CAAY,WAAZ,EAAyB,GAAzB;AADQ,KAJT;AAORS,IAAAA,OAAO,EAAE;AACPF,MAAAA,KAAK,EAAE;AADA;AAPD,GALY;AAgBtBG,EAAAA,YAAY,EAAE,CAAC,+BAAD,EAAkC,mBAAlC,EAAuD,eAAvD,EAAwE,sEAAxE,EAAgJ,4EAAhJ,EAA8N,GAA9N,EAAmOC,IAAnO,CAAwO,IAAxO,CAhBQ;AAiBtBC,EAAAA,cAAc,EAAE,CAAC,2CAAD,EAA8C,6BAA9C,EAA6E,+BAA7E,EAA8G,mBAA9G,EAAmI,eAAnI,EAAoJ,yBAApJ,EAA+K,yCAA/K,EAA0N,gDAA1N,EAA4Q,4DAA5Q,EAA0U,kCAA1U,EAA8W,IAA9W,EAAoX,sBAApX,EAA4Y,GAA5Y,EAAiZD,IAAjZ,CAAsZ,IAAtZ,CAjBM;AAkBtBE,EAAAA,WAAW,EAAE,qBAAUC,KAAV,EAAiB;AAC5B;AACA,aAASC,KAAT,CAAeC,CAAf,EAAkBF,KAAlB,EAAyB;AACvB,aAAOG,IAAI,CAACC,GAAL,CAAS,EAAEF,CAAC,GAAGA,CAAN,KAAY,MAAMF,KAAN,GAAcA,KAA1B,CAAT,CAAP;AACD;;AAED,QAAIK,CAAJ;AAAA,QACIC,MADJ;AAAA,QAEIC,GAFJ;AAAA,QAGIC,SAHJ;AAAA,QAIIC,cAAc,GAAG,EAJrB;AAAA,QAKIC,UAAU,GAAG,IAAIP,IAAI,CAACQ,IAAL,CAAUX,KAAK,GAAG,GAAlB,CAAJ,GAA6B,CAL9C;AAMA,QAAIU,UAAU,GAAGD,cAAjB,EAAiCC,UAAU,GAAGD,cAAb;AACjCD,IAAAA,SAAS,GAAG,CAACE,UAAU,GAAG,CAAd,IAAmB,GAA/B;AACAJ,IAAAA,MAAM,GAAG,IAAIM,KAAJ,CAAUF,UAAV,CAAT;AACAH,IAAAA,GAAG,GAAG,GAAN;;AAEA,SAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGK,UAAhB,EAA4B,EAAEL,CAA9B,EAAiC;AAC/BC,MAAAA,MAAM,CAACD,CAAD,CAAN,GAAYJ,KAAK,CAACI,CAAC,GAAGG,SAAL,EAAgBR,KAAhB,CAAjB;AACAO,MAAAA,GAAG,IAAID,MAAM,CAACD,CAAD,CAAb;AACD,KApB2B,CAoB1B;;;AAGF,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGK,UAAhB,EAA4B,EAAEL,CAA9B;AAAiCC,MAAAA,MAAM,CAACD,CAAD,CAAN,IAAaE,GAAb;AAAjC;;AAEA,WAAOD,MAAP;AACD;AA5CqB,CAAxB;AA+CA,SAASnB,iBAAT","sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    var i,\n        values,\n        sum,\n        halfWidth,\n        kMaxKernelSize = 25,\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\n\nexport { ConvolutionShader };\n"]},"metadata":{},"sourceType":"module"}