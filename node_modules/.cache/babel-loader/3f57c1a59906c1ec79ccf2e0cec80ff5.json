{"ast":null,"code":"import { Vector2, Matrix4 } from 'three';\n/**\n * TODO\n */\n\nvar SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\nexport { SAOShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/SAOShader.js"],"names":["Vector2","Matrix4","SAOShader","defines","NUM_SAMPLES","NUM_RINGS","NORMAL_TEXTURE","DIFFUSE_TEXTURE","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDepth","value","tDiffuse","tNormal","size","cameraNear","cameraFar","cameraProjectionMatrix","cameraInverseProjectionMatrix","scale","intensity","bias","minResolution","kernelRadius","randomSeed","vertexShader","join","fragmentShader"],"mappings":"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","sourcesContent":["import { Vector2, Matrix4 } from 'three';\n\n/**\n * TODO\n */\n\nvar SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\n\nexport { SAOShader };\n"]},"metadata":{},"sourceType":"module"}