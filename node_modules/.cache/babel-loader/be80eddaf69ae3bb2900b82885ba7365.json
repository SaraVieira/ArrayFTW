{"ast":null,"code":"import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nvar Water2 = function Water2(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Water2';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var flowDirection = options.flowDirection || new Vector2(1, 0);\n  var flowSpeed = options.flowSpeed || 0.03;\n  var reflectivity = options.reflectivity || 0.02;\n  var scale = options.scale || 1;\n  var shader = options.shader || Water2.WaterShader;\n  var encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n  var textureLoader = new TextureLoader();\n  var flowMap = options.flowMap || undefined;\n  var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n  var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n  var cycle = 0.15; // a cycle of a flow map phase\n\n  var halfCycle = cycle * 0.5;\n  var textureMatrix = new Matrix4();\n  var clock = new Clock(); // internal components\n\n  if (Reflector === undefined) {\n    console.error('THREE.Water: Required component Reflector not found.');\n    return;\n  }\n\n  if (Refractor === undefined) {\n    console.error('THREE.Water: Required component Refractor not found.');\n    return;\n  }\n\n  var reflector = new Reflector(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  var refractor = new Refractor(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  reflector.matrixAutoUpdate = false;\n  refractor.matrixAutoUpdate = false; // material\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true,\n    fog: true\n  });\n\n  if (flowMap !== undefined) {\n    this.material.defines.USE_FLOWMAP = '';\n    this.material.uniforms['tFlowMap'] = {\n      type: 't',\n      value: flowMap\n    };\n  } else {\n    this.material.uniforms['flowDirection'] = {\n      type: 'v2',\n      value: flowDirection\n    };\n  } // maps\n\n\n  normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n  normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n  this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n  this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n  this.material.uniforms['tNormalMap0'].value = normalMap0;\n  this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['reflectivity'].value = reflectivity;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n  this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n  this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n  this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n  this.material.uniforms['config'].value.w = scale; // scale\n  // functions\n\n  function updateTextureMatrix(camera) {\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  }\n\n  function updateFlow() {\n    var delta = clock.getDelta();\n    var config = scope.material.uniforms['config'];\n    config.value.x += flowSpeed * delta; // flowMapOffset0\n\n    config.value.y = config.value.x + halfCycle; // flowMapOffset1\n    // Important: The distance between offsets should be always the value of \"halfCycle\".\n    // Moreover, both offsets should be in the range of [ 0, cycle ].\n    // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n    if (config.value.x >= cycle) {\n      config.value.x = 0;\n      config.value.y = halfCycle;\n    } else if (config.value.y >= cycle) {\n      config.value.y = config.value.y - cycle;\n    }\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    updateTextureMatrix(camera);\n    updateFlow();\n    scope.visible = false;\n    reflector.matrixWorld.copy(scope.matrixWorld);\n    refractor.matrixWorld.copy(scope.matrixWorld);\n    reflector.onBeforeRender(renderer, scene, camera);\n    refractor.onBeforeRender(renderer, scene, camera);\n    scope.visible = true;\n  };\n};\n\nWater2.prototype = Object.create(Mesh.prototype);\nWater2.prototype.constructor = Water2;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: ['#include <common>', '#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'uniform mat4 textureMatrix;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\tvUv = uv;', '\tvCoord = textureMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvToEye = cameraPosition - worldPosition.xyz;', '\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\n  '\tgl_Position = projectionMatrix * mvPosition;', '\t#include <logdepthbuf_vertex>', '\t#include <fog_vertex>', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', 'uniform sampler2D tReflectionMap;', 'uniform sampler2D tRefractionMap;', 'uniform sampler2D tNormalMap0;', 'uniform sampler2D tNormalMap1;', '#ifdef USE_FLOWMAP', '\tuniform sampler2D tFlowMap;', '#else', '\tuniform vec2 flowDirection;', '#endif', 'uniform vec3 color;', 'uniform float reflectivity;', 'uniform vec4 config;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\t#include <logdepthbuf_fragment>', '\tfloat flowMapOffset0 = config.x;', '\tfloat flowMapOffset1 = config.y;', '\tfloat halfCycle = config.z;', '\tfloat scale = config.w;', '\tvec3 toEye = normalize( vToEye );', // determine flow direction\n  '\tvec2 flow;', '\t#ifdef USE_FLOWMAP', '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;', '\t#else', '\t\tflow = flowDirection;', '\t#endif', '\tflow.x *= - 1.0;', // sample normal maps (distort uvs with flowdata)\n  '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );', '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );', // linear interpolate to get the final normal color\n  '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;', '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );', // calculate normal vector\n  '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );', // calculate the fresnel term to blend reflection and refraction maps\n  '\tfloat theta = max( dot( toEye, normal ), 0.0 );', '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );', // calculate final uv coords\n  '\tvec3 coord = vCoord.xyz / vCoord.w;', '\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;', '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );', '\tvec4 refractColor = texture2D( tRefractionMap, uv );', // multiply water color with the mix of both textures\n  '\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '}'].join('\\n')\n};\nexport { Water2 };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/Water2.js"],"names":["Mesh","Color","Vector2","LinearEncoding","TextureLoader","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Vector4","Reflector","Refractor","Water2","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","prototype","Object","create","constructor","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","join"],"mappings":"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","sourcesContent":["import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nvar Water2 = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Water2';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var flowDirection = options.flowDirection || new Vector2(1, 0);\n  var flowSpeed = options.flowSpeed || 0.03;\n  var reflectivity = options.reflectivity || 0.02;\n  var scale = options.scale || 1;\n  var shader = options.shader || Water2.WaterShader;\n  var encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n  var textureLoader = new TextureLoader();\n  var flowMap = options.flowMap || undefined;\n  var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n  var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n  var cycle = 0.15; // a cycle of a flow map phase\n\n  var halfCycle = cycle * 0.5;\n  var textureMatrix = new Matrix4();\n  var clock = new Clock(); // internal components\n\n  if (Reflector === undefined) {\n    console.error('THREE.Water: Required component Reflector not found.');\n    return;\n  }\n\n  if (Refractor === undefined) {\n    console.error('THREE.Water: Required component Refractor not found.');\n    return;\n  }\n\n  var reflector = new Reflector(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  var refractor = new Refractor(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  reflector.matrixAutoUpdate = false;\n  refractor.matrixAutoUpdate = false; // material\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true,\n    fog: true\n  });\n\n  if (flowMap !== undefined) {\n    this.material.defines.USE_FLOWMAP = '';\n    this.material.uniforms['tFlowMap'] = {\n      type: 't',\n      value: flowMap\n    };\n  } else {\n    this.material.uniforms['flowDirection'] = {\n      type: 'v2',\n      value: flowDirection\n    };\n  } // maps\n\n\n  normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n  normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n  this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n  this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n  this.material.uniforms['tNormalMap0'].value = normalMap0;\n  this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['reflectivity'].value = reflectivity;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n  this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n  this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n  this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n  this.material.uniforms['config'].value.w = scale; // scale\n  // functions\n\n  function updateTextureMatrix(camera) {\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  }\n\n  function updateFlow() {\n    var delta = clock.getDelta();\n    var config = scope.material.uniforms['config'];\n    config.value.x += flowSpeed * delta; // flowMapOffset0\n\n    config.value.y = config.value.x + halfCycle; // flowMapOffset1\n    // Important: The distance between offsets should be always the value of \"halfCycle\".\n    // Moreover, both offsets should be in the range of [ 0, cycle ].\n    // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n    if (config.value.x >= cycle) {\n      config.value.x = 0;\n      config.value.y = halfCycle;\n    } else if (config.value.y >= cycle) {\n      config.value.y = config.value.y - cycle;\n    }\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    updateTextureMatrix(camera);\n    updateFlow();\n    scope.visible = false;\n    reflector.matrixWorld.copy(scope.matrixWorld);\n    refractor.matrixWorld.copy(scope.matrixWorld);\n    reflector.onBeforeRender(renderer, scene, camera);\n    refractor.onBeforeRender(renderer, scene, camera);\n    scope.visible = true;\n  };\n};\n\nWater2.prototype = Object.create(Mesh.prototype);\nWater2.prototype.constructor = Water2;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: ['#include <common>', '#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'uniform mat4 textureMatrix;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\tvUv = uv;', '\tvCoord = textureMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvToEye = cameraPosition - worldPosition.xyz;', '\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\n  '\tgl_Position = projectionMatrix * mvPosition;', '\t#include <logdepthbuf_vertex>', '\t#include <fog_vertex>', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', 'uniform sampler2D tReflectionMap;', 'uniform sampler2D tRefractionMap;', 'uniform sampler2D tNormalMap0;', 'uniform sampler2D tNormalMap1;', '#ifdef USE_FLOWMAP', '\tuniform sampler2D tFlowMap;', '#else', '\tuniform vec2 flowDirection;', '#endif', 'uniform vec3 color;', 'uniform float reflectivity;', 'uniform vec4 config;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\t#include <logdepthbuf_fragment>', '\tfloat flowMapOffset0 = config.x;', '\tfloat flowMapOffset1 = config.y;', '\tfloat halfCycle = config.z;', '\tfloat scale = config.w;', '\tvec3 toEye = normalize( vToEye );', // determine flow direction\n  '\tvec2 flow;', '\t#ifdef USE_FLOWMAP', '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;', '\t#else', '\t\tflow = flowDirection;', '\t#endif', '\tflow.x *= - 1.0;', // sample normal maps (distort uvs with flowdata)\n  '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );', '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );', // linear interpolate to get the final normal color\n  '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;', '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );', // calculate normal vector\n  '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );', // calculate the fresnel term to blend reflection and refraction maps\n  '\tfloat theta = max( dot( toEye, normal ), 0.0 );', '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );', // calculate final uv coords\n  '\tvec3 coord = vCoord.xyz / vCoord.w;', '\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;', '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );', '\tvec4 refractColor = texture2D( tRefractionMap, uv );', // multiply water color with the mix of both textures\n  '\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '}'].join('\\n')\n};\n\nexport { Water2 };\n"]},"metadata":{},"sourceType":"module"}