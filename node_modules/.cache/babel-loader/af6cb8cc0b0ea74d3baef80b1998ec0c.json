{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\n\nvar VTKLoader = function VTKLoader(manager) {\n  Loader.call(this, manager);\n};\n\nVTKLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: VTKLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []; // triangles vertices\n\n      var positions = []; // red, green, blue colors in the range 0 to 1\n\n      var colors = []; // normal vector, one per vertex\n\n      var normals = [];\n      var result; // pattern for detecting the end of a number sequence\n\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data.split('\\n');\n\n      for (var i in lines) {\n        var line = lines[i].trim();\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1; // split the polygon in numVertices - 2 triangles\n\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n              for (var _j = 0; _j < numVertices - 2; _j++) {\n                if (_j % 2 === 1) {\n                  i0 = parseInt(inds[_j]);\n                  i1 = parseInt(inds[_j + 2]);\n                  i2 = parseInt(inds[_j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[_j]);\n                  i1 = parseInt(inds[_j + 1]);\n                  i2 = parseInt(inds[_j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n\n      if (colors.length !== indices.length) {\n        // stagger\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n\n          for (var _i = 0; _i < numTriangles; _i++) {\n            var r = colors[3 * _i + 0];\n            var g = colors[3 * _i + 1];\n            var b = colors[3 * _i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n\n      return geometry;\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data); // Points and normals, by default, are empty\n\n      var points = [];\n      var normals = [];\n      var indices = []; // Going to make a big array of strings\n\n      var index = 0;\n\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n\n      var state, line;\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // retrieves the n-2 triangles from the triangle strip\n\n\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // divide the polygon in n-2 triangle\n\n\n            for (var _j2 = 1; _j2 < indexCount - 1; _j2++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[_j2];\n              indices[indicesIndex++] = strip[_j2 + 1];\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n          state = findString(buffer, state.next); // Now grab the binary data\n\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          } // Increment past our data\n\n\n          state.next = state.next + count;\n        } // Increment index\n\n\n        index = state.next;\n\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n\n      return geometry;\n    }\n\n    function Float32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n\n              for (var _j3 = 0; _j3 < xml.attributes.length; _j3++) {\n                var attribute = xml.attributes.item(_j3);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        } // do children\n\n\n        if (xml.hasChildNodes()) {\n          for (var _i2 = 0; _i2 < xml.childNodes.length; _i2++) {\n            var item = xml.childNodes.item(_i2);\n            var nodeName = item.nodeName;\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n\n        return obj;\n      } // Taken from Base64-js\n\n\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xff0000) >> 16;\n          arr[L++] = (tmp & 0xff00) >> 8;\n          arr[L++] = tmp & 0xff;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xff;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xff;\n          arr[L++] = tmp & 0xff;\n        }\n\n        return arr;\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        } // Check the format\n\n\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          } // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n          rawData = ele['#text'];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n\n          for (var _i3 = 1; _i3 < numBytes - 1; _i3++) {\n            blocks = blocks | byteData[_i3] << _i3 * numBytes;\n          }\n\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n\n          cSizeStart = 3 * numBytes;\n\n          for (var _i4 = 0; _i4 < blocks; _i4++) {\n            var currentBlockSize = byteData[_i4 * numBytes + cSizeStart];\n\n            for (var _j4 = 1; _j4 < numBytes - 1; _j4++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[_i4 * numBytes + cSizeStart + _j4] << _j4 * 8;\n            }\n\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n\n          for (var _i5 = 0; _i5 < dataOffsets.length - 1; _i5++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[_i5], dataOffsets[_i5 + 1])); // eslint-disable-line no-undef\n\n            content = data.buffer;\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n\n          delete ele['#text'];\n\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n\n          delete ele['#text']; // Get the content and optimize it\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n        return txt;\n      } // Main part\n      // Get Dom\n\n\n      var dom = null;\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n          dom.async = false;\n\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      } // Get the doc\n\n\n      var doc = dom.documentElement; // Convert to json\n\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n        // Loop through the sections\n\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n        var sectionIndex = 0,\n            numberOfSections = sections.length;\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n\n            var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n\n              dataArrayIndex++;\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n\n                if (numberOfPoints > 0) {\n                  for (var _i6 = 0, _len = arr.length; _i6 < _len; _i6++) {\n                    if (normalsName === arr[_i6].attributes.Name) {\n                      var components = arr[_i6].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[_i6].text, 0);\n                    }\n                  }\n                }\n\n                break;\n              // if it is points\n\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n\n                break;\n              // if it is strips\n\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n\n                  for (var _i7 = 0, _len2 = numberOfStrips; _i7 < _len2; _i7++) {\n                    var strip = [];\n\n                    for (var _s = 0, _len3 = offset[_i7], _len4 = 0; _s < _len3 - _len4; _s++) {\n                      strip.push(connectivity[_s]);\n                      if (_i7 > 0) _len4 = offset[_i7 - 1];\n                    }\n\n                    for (var _j5 = 0, _len5 = offset[_i7], _len6 = 0; _j5 < _len5 - _len6 - 2; _j5++) {\n                      if (_j5 % 2) {\n                        indices[indicesIndex++] = strip[_j5];\n                        indices[indicesIndex++] = strip[_j5 + 2];\n                        indices[indicesIndex++] = strip[_j5 + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[_j5];\n                        indices[indicesIndex++] = strip[_j5 + 1];\n                        indices[indicesIndex++] = strip[_j5 + 2];\n                      }\n\n                      if (_i7 > 0) _len6 = offset[_i7 - 1];\n                    }\n                  }\n                }\n\n                break;\n              // if it is polys\n\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                      connectivityIndex = 0;\n                  var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                        len1 = offset[i];\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n\n                    var j = 1;\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n\n                break;\n            }\n          }\n\n          sectionIndex++;\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    } // get the 5 first lines of the files to check if there is the key word binary\n\n\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n});\nexport { VTKLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/VTKLoader.js"],"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","BufferAttribute","unzlibSync","VTKLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","parseASCII","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","i1","i2","k","j","r","g","b","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","pointIndex","numberOfPoints","s","buffer","Uint8Array","dataView","DataView","points","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","state","Float32Array","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","old","Base64toByteArray","b64","Arr","Array","lookup","revLookup","code","len","charCodeAt","l","placeHolders","arr","L","parseDataArray","ele","compressed","numBytes","json","header_type","format","rawData","content","byteData","blocks","cSizeStart","headerSize","padding","dataOffsets","currentOffset","type","txt","currentBlockSize","slice","filter","el","idx","dom","window","DOMParser","parseFromString","ActiveXObject","async","loadXML","parseError","reason","srcText","doc","documentElement","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","toString","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","NumberOfStrips","connectivity","offset","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","meta","decodeText","includes"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\n\nvar VTKLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nVTKLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: VTKLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []; // triangles vertices\n\n      var positions = []; // red, green, blue colors in the range 0 to 1\n\n      var colors = []; // normal vector, one per vertex\n\n      var normals = [];\n      var result; // pattern for detecting the end of a number sequence\n\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n      var lines = data.split('\\n');\n\n      for (let i in lines) {\n        var line = lines[i].trim();\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1; // split the polygon in numVertices - 2 triangles\n\n              for (let j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n              for (let j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n\n      if (colors.length !== indices.length) {\n        // stagger\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n        geometry = geometry.toNonIndexed();\n        var numTriangles = geometry.attributes.position.count / 3;\n\n        if (colors.length === numTriangles * 3) {\n          var newColors = [];\n\n          for (let i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0];\n            var g = colors[3 * i + 1];\n            var b = colors[3 * i + 2];\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n            newColors.push(r, g, b);\n          }\n\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n\n      return geometry;\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data); // Points and normals, by default, are empty\n\n      var points = [];\n      var normals = [];\n      var indices = []; // Going to make a big array of strings\n      var index = 0;\n\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n\n      var state, line;\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n          count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // retrieves the n-2 triangles from the triangle strip\n\n\n            for (let j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n          count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            } // divide the polygon in n-2 triangle\n\n\n            for (let j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          } // increment our next pointer\n\n\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n          state = findString(buffer, state.next); // Now grab the binary data\n\n          count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          } // Increment past our data\n\n\n          state.next = state.next + count;\n        } // Increment index\n\n\n        index = state.next;\n\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n\n      return geometry;\n    }\n\n    function Float32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n\n              for (let j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        } // do children\n\n\n        if (xml.hasChildNodes()) {\n          for (let i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i);\n            var nodeName = item.nodeName;\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n\n              var tmp = xmlToJson(item);\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n\n        return obj;\n      } // Taken from Base64-js\n\n\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xff0000) >> 16;\n          arr[L++] = (tmp & 0xff00) >> 8;\n          arr[L++] = tmp & 0xff;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xff;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xff;\n          arr[L++] = tmp & 0xff;\n        }\n\n        return arr;\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        } // Check the format\n\n\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          } // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n          rawData = ele['#text'];\n          byteData = Base64toByteArray(rawData);\n          blocks = byteData[0];\n\n          for (let i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * numBytes;\n          }\n\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n\n          cSizeStart = 3 * numBytes;\n\n          for (let i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n            for (let j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n            }\n\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n\n          for (let i = 0; i < dataOffsets.length - 1; i++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n            content = data.buffer;\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n\n          delete ele['#text'];\n\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n\n          delete ele['#text']; // Get the content and optimize it\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n        return txt;\n      } // Main part\n      // Get Dom\n\n\n      var dom = null;\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n          dom.async = false;\n\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      } // Get the doc\n\n\n      var doc = dom.documentElement; // Convert to json\n\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n        // Loop through the sections\n\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n        var sectionIndex = 0,\n            numberOfSections = sections.length;\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n\n            var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n\n              dataArrayIndex++;\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n\n                if (numberOfPoints > 0) {\n                  for (let i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n\n                break;\n              // if it is points\n\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n\n                break;\n              // if it is strips\n\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                  var indicesIndex = 0;\n\n                  for (let i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n\n                    for (let s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n\n                    for (let j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n\n                break;\n              // if it is polys\n\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                      connectivityIndex = 0;\n                  var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                        len1 = offset[i];\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n\n                    var j = 1;\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n\n                break;\n            }\n          }\n\n          sectionIndex++;\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    } // get the 5 first lines of the files to check if there is the key word binary\n\n\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(LoaderUtils.decodeText(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(LoaderUtils.decodeText(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n});\n\nexport { VTKLoader };\n"]},"metadata":{},"sourceType":"module"}