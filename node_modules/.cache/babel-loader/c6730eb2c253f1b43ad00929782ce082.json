{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function retargetClip(target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function renameBones(skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function getBoneByName(name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function clone(source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/utils/SkeletonUtils.js"],"names":["Vector3","Quaternion","Matrix4","AnimationMixer","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","SkeletonHelper","Vector2","Euler","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"mappings":"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","sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n"]},"metadata":{},"sourceType":"module"}