{"ast":null,"code":"import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function dispose() {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function setSize(width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function render(renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (var i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n        width, height);\n      }\n\n      var sampleWeight = baseSampleWeight;\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/SSAARenderPass.js"],"names":["Color","UniformsUtils","ShaderMaterial","AdditiveBlending","WebGLRenderTarget","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","SSAARenderPass","scene","camera","clearColor","clearAlpha","sampleLevel","unbiased","undefined","_oldClearColor","console","error","copyShader","copyUniforms","clone","uniforms","copyMaterial","vertexShader","fragmentShader","premultipliedAlpha","transparent","blending","depthTest","depthWrite","fsQuad","prototype","Object","assign","create","constructor","dispose","sampleRenderTarget","setSize","width","height","render","renderer","writeBuffer","readBuffer","minFilter","magFilter","format","texture","name","jitterOffsets","JitterVectors","Math","max","min","autoClear","getClearColor","oldClearAlpha","getClearAlpha","baseSampleWeight","length","roundingRange","value","i","jitterOffset","setViewOffset","sampleWeight","uniformCenteredDistribution","setClearColor","setRenderTarget","clear","renderToScreen","clearViewOffset"],"mappings":"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","sourcesContent":["import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function () {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function (width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function (renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n        width, height);\n      }\n\n      var sampleWeight = baseSampleWeight;\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n\nexport { SSAARenderPass };\n"]},"metadata":{},"sourceType":"module"}