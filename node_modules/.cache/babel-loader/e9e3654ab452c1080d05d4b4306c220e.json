{"ast":null,"code":"/**\n * Based on Nvidia Cg tutorial\n */\nvar FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\nexport { FresnelShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/FresnelShader.js"],"names":["FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,aAAa,GAAG;AAClBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,gBAAgB,EAAE;AAChBC,MAAAA,KAAK,EAAE;AADS,KADV;AAIRC,IAAAA,YAAY,EAAE;AACZD,MAAAA,KAAK,EAAE;AADK,KAJN;AAORE,IAAAA,aAAa,EAAE;AACbF,MAAAA,KAAK,EAAE;AADM,KAPP;AAURG,IAAAA,aAAa,EAAE;AACbH,MAAAA,KAAK,EAAE;AADM,KAVP;AAaRI,IAAAA,KAAK,EAAE;AACLJ,MAAAA,KAAK,EAAE;AADF;AAbC,GADQ;AAkBlBK,EAAAA,YAAY,EAAE,CAAC,iCAAD,EAAoC,6BAApC,EAAmE,8BAAnE,EAAmG,8BAAnG,EAAmI,wBAAnI,EAA6J,2BAA7J,EAA0L,kCAA1L,EAA8N,eAA9N,EAA+O,6DAA/O,EAA8S,4DAA9S,EAA4W,+GAA5W,EAA6d,+CAA7d,EAA8gB,wCAA9gB,EAAwjB,0EAAxjB,EAAooB,iFAApoB,EAAutB,iFAAvtB,EAA0yB,qHAA1yB,EAAi6B,+CAAj6B,EAAk9B,GAAl9B,EAAu9BC,IAAv9B,CAA49B,IAA59B,CAlBI;AAmBlBC,EAAAA,cAAc,EAAE,CAAC,4BAAD,EAA+B,wBAA/B,EAAyD,2BAAzD,EAAsF,kCAAtF,EAA0H,eAA1H,EAA2I,gFAA3I,EAA6N,qCAA7N,EAAoQ,qFAApQ,EAA2V,qFAA3V,EAAkb,qFAAlb,EAAygB,8FAAzgB,EAAymB,GAAzmB,EAA8mBD,IAA9mB,CAAmnB,IAAnnB;AAnBE,CAApB;AAsBA,SAAST,aAAT","sourcesContent":["/**\n * Based on Nvidia Cg tutorial\n */\nvar FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\n\nexport { FresnelShader };\n"]},"metadata":{},"sourceType":"module"}