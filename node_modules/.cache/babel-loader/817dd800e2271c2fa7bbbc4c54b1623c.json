{"ast":null,"code":"import { Vector3 } from 'three';\n/**\n * Usage:\n *  var exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  var data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nvar STLExporter = function STLExporter() {};\n\nSTLExporter.prototype = {\n  constructor: STLExporter,\n  parse: function parse(scene, options) {\n    if (options === undefined) options = {};\n    var binary = options.binary !== undefined ? options.binary : false; //\n\n    var objects = [];\n    var triangles = 0;\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        var geometry = object.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        var index = geometry.index;\n        var positionAttribute = geometry.getAttribute('position');\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry: geometry\n        });\n      }\n    });\n    var output;\n    var offset = 80; // skip header\n\n    if (binary === true) {\n      var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      var arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = '';\n      output += 'solid exported\\n';\n    }\n\n    var vA = new Vector3();\n    var vB = new Vector3();\n    var vC = new Vector3();\n    var cb = new Vector3();\n    var ab = new Vector3();\n    var normal = new Vector3();\n\n    for (var i = 0, il = objects.length; i < il; i++) {\n      var object = objects[i].object3d;\n      var geometry = objects[i].geometry;\n      var index = geometry.index;\n      var positionAttribute = geometry.getAttribute('position');\n\n      if (index !== null) {\n        // indexed geometry\n        for (var j = 0; j < index.count; j += 3) {\n          var a = index.getX(j + 0);\n          var b = index.getX(j + 1);\n          var c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        // non-indexed geometry\n        for (var _j = 0; _j < positionAttribute.count; _j += 3) {\n          var a = _j + 0;\n          var b = _j + 1;\n          var c = _j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n\n    if (binary === false) {\n      output += 'endsolid exported\\n';\n    }\n\n    return output;\n\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n\n      if (object.isSkinnedMesh === true) {\n        object.boneTransform(a, vA);\n        object.boneTransform(b, vB);\n        object.boneTransform(c, vC);\n      }\n\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += '\\t\\tendloop\\n';\n        output += '\\tendfacet\\n';\n      }\n    }\n\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += \"\\tfacet normal \".concat(normal.x, \" \").concat(normal.y, \" \").concat(normal.z, \"\\n\");\n        output += '\\t\\touter loop\\n';\n      }\n    }\n\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += \"\\t\\t\\tvertex \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n      }\n    }\n  }\n};\nexport { STLExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/STLExporter.js"],"names":["Vector3","STLExporter","prototype","constructor","parse","scene","options","undefined","binary","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","output","offset","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","vB","vC","cb","ab","normal","i","il","length","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"mappings":"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","sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * Usage:\n *  var exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  var data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nconst STLExporter = () => {};\n\nSTLExporter.prototype = {\n  constructor: STLExporter,\n  parse: function (scene, options) {\n    if (options === undefined) options = {};\n    const binary = options.binary !== undefined ? options.binary : false; //\n\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute('position');\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80; // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = '';\n      output += 'solid exported\\n';\n    }\n\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute('position');\n\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          var a = index.getX(j + 0);\n          var b = index.getX(j + 1);\n          var c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          var a = j + 0;\n          var b = j + 1;\n          var c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n\n    if (binary === false) {\n      output += 'endsolid exported\\n';\n    }\n\n    return output;\n\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n\n      if (object.isSkinnedMesh === true) {\n        object.boneTransform(a, vA);\n        object.boneTransform(b, vB);\n        object.boneTransform(c, vC);\n      }\n\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += '\\t\\tendloop\\n';\n        output += '\\tendfacet\\n';\n      }\n    }\n\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += `\\tfacet normal ${normal.x} ${normal.y} ${normal.z}\\n`;\n        output += '\\t\\touter loop\\n';\n      }\n    }\n\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n      }\n    }\n  }\n};\n\nexport { STLExporter };\n"]},"metadata":{},"sourceType":"module"}