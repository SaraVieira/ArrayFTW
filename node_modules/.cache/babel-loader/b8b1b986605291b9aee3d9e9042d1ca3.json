{"ast":null,"code":"import { Color, Vector2, MeshBasicMaterial, DoubleSide, WebGLRenderTarget, MeshDepthMaterial, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {\n  this.renderScene = scene;\n  this.renderCamera = camera;\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n  this.visibleEdgeColor = new Color(1, 1, 1);\n  this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n  this.edgeGlow = 0.0;\n  this.usePatternTexture = false;\n  this.edgeThickness = 1.0;\n  this.edgeStrength = 3.0;\n  this.downSampleRatio = 2;\n  this.pulsePeriod = 0;\n  this._visibilityCache = new Map();\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\n  this.maskBufferMaterial = new MeshBasicMaterial({\n    color: 0xffffff\n  });\n  this.maskBufferMaterial.side = DoubleSide;\n  this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n  this.depthMaterial = new MeshDepthMaterial();\n  this.depthMaterial.side = DoubleSide;\n  this.depthMaterial.depthPacking = RGBADepthPacking;\n  this.depthMaterial.blending = NoBlending;\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n  this.prepareMaskMaterial.side = DoubleSide;\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n  this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n  this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n  this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n  this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n  var MAX_EDGE_THICKNESS = 4;\n  var MAX_EDGE_GLOW = 4;\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n  if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.fsQuad = new FullScreenQuad(null);\n  this.tempPulseColor1 = new Color();\n  this.tempPulseColor2 = new Color();\n  this.textureMatrix = new Matrix4();\n\n  function replaceDepthToViewZ(string, camera) {\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n  }\n};\n\nOutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: OutlinePass,\n  dispose: function dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  },\n  setSize: function setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    var resx = Math.round(width / this.downSampleRatio);\n    var resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  },\n  changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {\n    var cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (var i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  },\n  changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {\n    var cache = this._visibilityCache;\n    var selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (var i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        var bFound = false;\n\n        for (var _i = 0; _i < selectedMeshes.length; _i++) {\n          var selectedObjectId = selectedMeshes[_i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          var visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  },\n  updateTextureMatrix: function updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  },\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      var currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  },\n  getPrepareMaskMaterial: function getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\t#include <skinbase_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\tvPosition = mvPosition;', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\n'),\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n    });\n  },\n  getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}'\n    });\n  },\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}'\n    });\n  },\n  getOverlayMaterial: function getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}',\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n});\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { OutlinePass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"names":["Color","Vector2","MeshBasicMaterial","DoubleSide","WebGLRenderTarget","MeshDepthMaterial","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","pars","minFilter","magFilter","format","resx","Math","round","resy","maskBufferMaterial","color","side","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","type","isPerspectiveCamera","replace","prototype","Object","assign","create","constructor","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","join","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"mappings":"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","sourcesContent":["import { Color, Vector2, MeshBasicMaterial, DoubleSide, WebGLRenderTarget, MeshDepthMaterial, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar OutlinePass = function (resolution, scene, camera, selectedObjects) {\n  this.renderScene = scene;\n  this.renderCamera = camera;\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n  this.visibleEdgeColor = new Color(1, 1, 1);\n  this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n  this.edgeGlow = 0.0;\n  this.usePatternTexture = false;\n  this.edgeThickness = 1.0;\n  this.edgeStrength = 3.0;\n  this.downSampleRatio = 2;\n  this.pulsePeriod = 0;\n  this._visibilityCache = new Map();\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\n  this.maskBufferMaterial = new MeshBasicMaterial({\n    color: 0xffffff\n  });\n  this.maskBufferMaterial.side = DoubleSide;\n  this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n  this.depthMaterial = new MeshDepthMaterial();\n  this.depthMaterial.side = DoubleSide;\n  this.depthMaterial.depthPacking = RGBADepthPacking;\n  this.depthMaterial.blending = NoBlending;\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n  this.prepareMaskMaterial.side = DoubleSide;\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n  this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n  this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n  this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n  this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n  var MAX_EDGE_THICKNESS = 4;\n  var MAX_EDGE_GLOW = 4;\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n  if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.fsQuad = new FullScreenQuad(null);\n  this.tempPulseColor1 = new Color();\n  this.tempPulseColor2 = new Color();\n  this.textureMatrix = new Matrix4();\n\n  function replaceDepthToViewZ(string, camera) {\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n  }\n};\n\nOutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: OutlinePass,\n  dispose: function () {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  },\n  setSize: function (width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    var resx = Math.round(width / this.downSampleRatio);\n    var resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  },\n  changeVisibilityOfSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  },\n  changeVisibilityOfNonSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n    var selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        var bFound = false;\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          var selectedObjectId = selectedMeshes[i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          var visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  },\n  updateTextureMatrix: function () {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      var currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  },\n  getPrepareMaskMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\t#include <skinbase_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\tvPosition = mvPosition;', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\n'),\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n    });\n  },\n  getEdgeDetectionMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}'\n    });\n  },\n  getSeperableBlurMaterial: function (maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}'\n    });\n  },\n  getOverlayMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}',\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n});\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\n\nexport { OutlinePass };\n"]},"metadata":{},"sourceType":"module"}