{"ast":null,"code":"import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function ShadowMapViewer(light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function set(width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n      if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\nexport { ShadowMapViewer };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/utils/ShadowMapViewer.js"],"names":["OrthographicCamera","Scene","UniformsUtils","ShaderMaterial","PlaneGeometry","Mesh","Texture","LinearFilter","MeshBasicMaterial","DoubleSide","UnpackDepthRGBAShader","ShadowMapViewer","light","scope","doRenderLabel","name","undefined","userAutoClearSetting","frame","x","y","width","height","camera","window","innerWidth","innerHeight","position","set","scene","shader","uniforms","clone","material","vertexShader","fragmentShader","plane","mesh","add","labelCanvas","labelMesh","document","createElement","context","getContext","font","labelWidth","measureText","fillStyle","fillText","labelTexture","magFilter","minFilter","needsUpdate","labelMaterial","map","side","transparent","labelPlane","resetPosition","enabled","size","scale","render","renderer","tDiffuse","value","shadow","texture","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update","prototype","constructor"],"mappings":"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","sourcesContent":["import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function (light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function (width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function (x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n      if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\n\nexport { ShadowMapViewer };\n"]},"metadata":{},"sourceType":"module"}