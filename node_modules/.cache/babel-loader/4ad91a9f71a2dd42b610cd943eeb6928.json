{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvar BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1.0\n    },\n    textureHeight: {\n      value: 1.0\n    },\n    focalDepth: {\n      value: 1.0\n    },\n    focalLength: {\n      value: 24.0\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1.0\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2.0\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 0.0001\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\t//pentagonal shape', '\tfloat scale = float(rings) - 1.3;', '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\tvec4  one = vec4( 1.0 );', '\tvec4 P = vec4((coords),vec2(scale, scale));', '\tvec4 dist = vec4(0.0);', '\tfloat inorout = -4.0;', '\tdist.x = dot( P, HS0 );', '\tdist.y = dot( P, HS1 );', '\tdist.z = dot( P, HS2 );', '\tdist.w = dot( P, HS3 );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dot( dist, one );', '\tdist.x = dot( P, HS4 );', '\tdist.y = HS5.w - abs( P.z );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dist.x;', '\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\t// Depth buffer blur', '\tfloat d = 0.0;', '\tfloat kernel[9];', '\tvec2 offset[9];', '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\toffset[0] = vec2(-wh.x,-wh.y);', '\toffset[1] = vec2( 0.0, -wh.y);', '\toffset[2] = vec2( wh.x -wh.y);', '\toffset[3] = vec2(-wh.x,  0.0);', '\toffset[4] = vec2( 0.0,   0.0);', '\toffset[5] = vec2( wh.x,  0.0);', '\toffset[6] = vec2(-wh.x, wh.y);', '\toffset[7] = vec2( 0.0,  wh.y);', '\toffset[8] = vec2( wh.x, wh.y);', '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\tfor( int i=0; i<9; i++ ) {', '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\t\td += tmp * kernel[i];', '\t}', '\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\t//processing the sample', '\tvec3 col = vec3(0.0);', '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\tfloat lum = dot(col.rgb, lumcoeff);', '\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\tfloat edge = 0.002*depth; //distance based edge smoothing', '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\treturn col;', '}', 'float linearize(float depth) {', '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\tfloat rings2 = float(rings);', '\tfloat step = PI*2.0 / float(ringsamples);', '\tfloat pw = cos(j*step)*i;', '\tfloat ph = sin(j*step)*i;', '\tfloat p = 1.0;', '\tif (pentagon) {', '\t\tp = penta(vec2(pw,ph));', '\t}', '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\t//scene depth calculation', '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\t// Blur depth?', '\tif ( depthblur ) {', '\t\tdepth = linearize(bdepth(vUv.xy));', '\t}', '\t//focal plane calculation', '\tfloat fDepth = focalDepth;', '\tif (shaderFocus) {', '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\t}', '\t// dof blur factor calculation', '\tfloat blur = 0.0;', '\tif (manualdof) {', '\t\tfloat a = depth-fDepth; // Focal plane', '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\t\tblur = (a>0.0) ? b : c;', '\t} else {', '\t\tfloat f = focalLength; // focal length in mm', '\t\tfloat d = fDepth*1000.0; // focal plane in mm', '\t\tfloat o = depth*1000.0; // depth in mm', '\t\tfloat a = (o*f)/(o-f);', '\t\tfloat b = (d*f)/(d-f);', '\t\tfloat c = (d-f)/(d*fstop*CoC);', '\t\tblur = abs(a-b)*c;', '\t}', '\tblur = clamp(blur,0.0,1.0);', '\t// calculation of pattern for dithering', '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\t// getting blur x and y step factor', '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\t// calculation of final color', '\tvec3 col = vec3(0.0);', '\tif(blur < 0.05) {', '\t\t//some optimization thingy', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t} else {', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t\tfloat s = 1.0;', '\t\tint ringsamples;', '\t\tfor (int i = 1; i <= rings; i++) {', '\t\t\t/*unboxstart*/', '\t\t\tringsamples = i * samples;', '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\t\t\t\tif (j >= ringsamples) break;', '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\t\t\t}', '\t\t\t/*unboxend*/', '\t\t}', '\t\tcol /= s; //divide by sample count', '\t}', '\tif (showFocus) {', '\t\tcol = debugFocus(col, blur, depth);', '\t}', '\tif (vignetting) {', '\t\tcol *= vignette();', '\t}', '\tgl_FragColor.rgb = col;', '\tgl_FragColor.a = 1.0;', '} '].join('\\n')\n};\nvar BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1.0\n    },\n    mFar: {\n      value: 1000.0\n    }\n  },\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\t#include <begin_vertex>', '\t#include <project_vertex>', '\tvViewZDepth = - mvPosition.z;', '}'].join('\\n'),\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\n')\n};\nexport { BokehDepthShader, BokehShader2 };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/BokehShader2.js"],"names":["Vector2","BokehShader2","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar"],"mappings":"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","sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvar BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1.0\n    },\n    textureHeight: {\n      value: 1.0\n    },\n    focalDepth: {\n      value: 1.0\n    },\n    focalLength: {\n      value: 24.0\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1.0\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2.0\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 0.0001\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\t//pentagonal shape', '\tfloat scale = float(rings) - 1.3;', '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\tvec4  one = vec4( 1.0 );', '\tvec4 P = vec4((coords),vec2(scale, scale));', '\tvec4 dist = vec4(0.0);', '\tfloat inorout = -4.0;', '\tdist.x = dot( P, HS0 );', '\tdist.y = dot( P, HS1 );', '\tdist.z = dot( P, HS2 );', '\tdist.w = dot( P, HS3 );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dot( dist, one );', '\tdist.x = dot( P, HS4 );', '\tdist.y = HS5.w - abs( P.z );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dist.x;', '\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\t// Depth buffer blur', '\tfloat d = 0.0;', '\tfloat kernel[9];', '\tvec2 offset[9];', '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\toffset[0] = vec2(-wh.x,-wh.y);', '\toffset[1] = vec2( 0.0, -wh.y);', '\toffset[2] = vec2( wh.x -wh.y);', '\toffset[3] = vec2(-wh.x,  0.0);', '\toffset[4] = vec2( 0.0,   0.0);', '\toffset[5] = vec2( wh.x,  0.0);', '\toffset[6] = vec2(-wh.x, wh.y);', '\toffset[7] = vec2( 0.0,  wh.y);', '\toffset[8] = vec2( wh.x, wh.y);', '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\tfor( int i=0; i<9; i++ ) {', '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\t\td += tmp * kernel[i];', '\t}', '\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\t//processing the sample', '\tvec3 col = vec3(0.0);', '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\tfloat lum = dot(col.rgb, lumcoeff);', '\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\tfloat edge = 0.002*depth; //distance based edge smoothing', '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\treturn col;', '}', 'float linearize(float depth) {', '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\tfloat rings2 = float(rings);', '\tfloat step = PI*2.0 / float(ringsamples);', '\tfloat pw = cos(j*step)*i;', '\tfloat ph = sin(j*step)*i;', '\tfloat p = 1.0;', '\tif (pentagon) {', '\t\tp = penta(vec2(pw,ph));', '\t}', '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\t//scene depth calculation', '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\t// Blur depth?', '\tif ( depthblur ) {', '\t\tdepth = linearize(bdepth(vUv.xy));', '\t}', '\t//focal plane calculation', '\tfloat fDepth = focalDepth;', '\tif (shaderFocus) {', '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\t}', '\t// dof blur factor calculation', '\tfloat blur = 0.0;', '\tif (manualdof) {', '\t\tfloat a = depth-fDepth; // Focal plane', '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\t\tblur = (a>0.0) ? b : c;', '\t} else {', '\t\tfloat f = focalLength; // focal length in mm', '\t\tfloat d = fDepth*1000.0; // focal plane in mm', '\t\tfloat o = depth*1000.0; // depth in mm', '\t\tfloat a = (o*f)/(o-f);', '\t\tfloat b = (d*f)/(d-f);', '\t\tfloat c = (d-f)/(d*fstop*CoC);', '\t\tblur = abs(a-b)*c;', '\t}', '\tblur = clamp(blur,0.0,1.0);', '\t// calculation of pattern for dithering', '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\t// getting blur x and y step factor', '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\t// calculation of final color', '\tvec3 col = vec3(0.0);', '\tif(blur < 0.05) {', '\t\t//some optimization thingy', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t} else {', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t\tfloat s = 1.0;', '\t\tint ringsamples;', '\t\tfor (int i = 1; i <= rings; i++) {', '\t\t\t/*unboxstart*/', '\t\t\tringsamples = i * samples;', '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\t\t\t\tif (j >= ringsamples) break;', '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\t\t\t}', '\t\t\t/*unboxend*/', '\t\t}', '\t\tcol /= s; //divide by sample count', '\t}', '\tif (showFocus) {', '\t\tcol = debugFocus(col, blur, depth);', '\t}', '\tif (vignetting) {', '\t\tcol *= vignette();', '\t}', '\tgl_FragColor.rgb = col;', '\tgl_FragColor.a = 1.0;', '} '].join('\\n')\n};\nvar BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1.0\n    },\n    mFar: {\n      value: 1000.0\n    }\n  },\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\t#include <begin_vertex>', '\t#include <project_vertex>', '\tvViewZDepth = - mvPosition.z;', '}'].join('\\n'),\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\n')\n};\n\nexport { BokehDepthShader, BokehShader2 };\n"]},"metadata":{},"sourceType":"module"}