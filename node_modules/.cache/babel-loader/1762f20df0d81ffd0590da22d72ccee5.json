{"ast":null,"code":"import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = function ReflectorForSSRPass(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get: function get() {\n      return scope._isDistanceAttenuation;\n    },\n    set: function set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get: function get() {\n      return scope._isFresnel;\n    },\n    set: function set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n\n  this.material = material;\n\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnel;\\n\\t\\tvarying vec4 vUv;\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tfloat op=opacity;\\n\\t\\t\\t\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tif(depth>maxDistance) discard;\\n\\t\\t\\t\\t#ifdef isDistanceAttenuation\\n\\t\\t\\t\\t\\tfloat ratio=1.-(depth/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef isFresnel\\n\\t\\t\\t\\t\\top*=fresnel;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"names":["Mesh","Color","Vector3","Plane","Matrix4","Vector4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","LinearFilter","RGBFormat","ReflectorForSSRPass","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","_isDistanceAttenuation","defines","isDistanceAttenuation","Object","defineProperty","get","set","val","material","_isFresnel","isFresnel","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","depthTexture","minFilter","maxFilter","parameters","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","transparent","assign","clone","fragmentShader","vertexShader","doRender","renderer","scene","camera","position","length","y","copy","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","create","constructor","tDiffuse","tDepth","fresnel","join"],"mappings":"AAAA,SAASA,IAAT,EAAeC,KAAf,EAAsBC,OAAtB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+CC,OAA/C,EAAwDC,iBAAxD,EAA2EC,YAA3E,EAAyFC,iBAAzF,EAA4GC,aAA5G,EAA2HC,iBAA3H,EAA8IC,SAA9I,EAAyJC,cAAzJ,EAAyKC,aAAzK,EAAwLC,YAAxL,EAAsMC,SAAtM,QAAuN,OAAvN;;AAEA,IAAIC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUC,QAAV,EAAoBC,OAApB,EAA6B;AACrDlB,EAAAA,IAAI,CAACmB,IAAL,CAAU,IAAV,EAAgBF,QAAhB;AACA,OAAKG,IAAL,GAAY,qBAAZ;AACA,MAAIC,KAAK,GAAG,IAAZ;AACAH,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAII,KAAK,GAAGJ,OAAO,CAACI,KAAR,KAAkBC,SAAlB,GAA8B,IAAItB,KAAJ,CAAUiB,OAAO,CAACI,KAAlB,CAA9B,GAAyD,IAAIrB,KAAJ,CAAU,QAAV,CAArE;AACA,MAAIuB,YAAY,GAAGN,OAAO,CAACM,YAAR,IAAwB,GAA3C;AACA,MAAIC,aAAa,GAAGP,OAAO,CAACO,aAAR,IAAyB,GAA7C;AACA,MAAIC,QAAQ,GAAGR,OAAO,CAACQ,QAAR,IAAoB,CAAnC;AACA,MAAIC,MAAM,GAAGT,OAAO,CAACS,MAAR,IAAkBX,mBAAmB,CAACY,eAAnD;AACA,MAAIC,eAAe,GAAGX,OAAO,CAACW,eAA9B;AACA,MAAIC,KAAK,GAAG,IAAI5B,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAZ;AACA,MAAI6B,QAAQ,GAAG,IAAI7B,OAAJ,EAAf;AACA,MAAI8B,QAAQ,GAAG,IAAI9B,OAAJ,EAAf,CAbqD,CAavB;;AAE9BmB,EAAAA,KAAK,CAACY,WAAN,GAAoB,KAApB;AACAZ,EAAAA,KAAK,CAACa,WAAN,GAAoBlB,mBAAmB,CAACY,eAApB,CAAoCO,QAApC,CAA6CD,WAA7C,CAAyDE,KAA7E;AACAf,EAAAA,KAAK,CAACgB,OAAN,GAAgBrB,mBAAmB,CAACY,eAApB,CAAoCO,QAApC,CAA6CE,OAA7C,CAAqDD,KAArE;AACAf,EAAAA,KAAK,CAACiB,sBAAN,GAA+BtB,mBAAmB,CAACY,eAApB,CAAoCW,OAApC,CAA4CC,qBAA3E;AACAC,EAAAA,MAAM,CAACC,cAAP,CAAsBrB,KAAtB,EAA6B,uBAA7B,EAAsD;AACpDsB,IAAAA,GADoD,iBAC9C;AACJ,aAAOtB,KAAK,CAACiB,sBAAb;AACD,KAHmD;AAKpDM,IAAAA,GALoD,eAKhDC,GALgD,EAK3C;AACP,UAAIxB,KAAK,CAACiB,sBAAN,KAAiCO,GAArC,EAA0C;AAC1CxB,MAAAA,KAAK,CAACiB,sBAAN,GAA+BO,GAA/B;AACAxB,MAAAA,KAAK,CAACyB,QAAN,CAAeP,OAAf,CAAuBC,qBAAvB,GAA+CK,GAA/C;AACAxB,MAAAA,KAAK,CAACyB,QAAN,CAAeb,WAAf,GAA6B,IAA7B;AACD;AAVmD,GAAtD;AAaAZ,EAAAA,KAAK,CAAC0B,UAAN,GAAmB/B,mBAAmB,CAACY,eAApB,CAAoCW,OAApC,CAA4CS,SAA/D;AACAP,EAAAA,MAAM,CAACC,cAAP,CAAsBrB,KAAtB,EAA6B,WAA7B,EAA0C;AACxCsB,IAAAA,GADwC,iBAClC;AACJ,aAAOtB,KAAK,CAAC0B,UAAb;AACD,KAHuC;AAKxCH,IAAAA,GALwC,eAKpCC,GALoC,EAK/B;AACP,UAAIxB,KAAK,CAAC0B,UAAN,KAAqBF,GAAzB,EAA8B;AAC9BxB,MAAAA,KAAK,CAAC0B,UAAN,GAAmBF,GAAnB;AACAxB,MAAAA,KAAK,CAACyB,QAAN,CAAeP,OAAf,CAAuBS,SAAvB,GAAmCH,GAAnC;AACAxB,MAAAA,KAAK,CAACyB,QAAN,CAAeb,WAAf,GAA6B,IAA7B;AACD;AAVuC,GAA1C;AAaA,MAAIgB,cAAc,GAAG,IAAI9C,KAAJ,EAArB;AACA,MAAI+C,MAAM,GAAG,IAAIhD,OAAJ,EAAb;AACA,MAAIiD,sBAAsB,GAAG,IAAIjD,OAAJ,EAA7B;AACA,MAAIkD,mBAAmB,GAAG,IAAIlD,OAAJ,EAA1B;AACA,MAAImD,cAAc,GAAG,IAAIjD,OAAJ,EAArB;AACA,MAAIkD,cAAc,GAAG,IAAIpD,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,CAArB;AACA,MAAIqD,SAAS,GAAG,IAAIlD,OAAJ,EAAhB;AACA,MAAImD,IAAI,GAAG,IAAItD,OAAJ,EAAX;AACA,MAAIuD,MAAM,GAAG,IAAIvD,OAAJ,EAAb;AACA,MAAIwD,CAAC,GAAG,IAAIrD,OAAJ,EAAR;AACA,MAAIsD,aAAa,GAAG,IAAIvD,OAAJ,EAApB;AACA,MAAIwD,aAAa,GAAG,IAAItD,iBAAJ,EAApB;;AAEA,MAAIuB,eAAJ,EAAqB;AACnB,QAAIgC,YAAY,GAAG,IAAItD,YAAJ,EAAnB;AACAsD,IAAAA,YAAY,CAACzC,IAAb,GAAoBZ,iBAApB;AACAqD,IAAAA,YAAY,CAACC,SAAb,GAAyBrD,aAAzB;AACAoD,IAAAA,YAAY,CAACE,SAAb,GAAyBtD,aAAzB;AACD;;AAED,MAAIuD,UAAU,GAAG;AACfF,IAAAA,SAAS,EAAEhD,YADI;AAEfmD,IAAAA,SAAS,EAAEnD,YAFI;AAGfoD,IAAAA,MAAM,EAAEnD,SAHO;AAIf8C,IAAAA,YAAY,EAAEhC,eAAe,GAAGgC,YAAH,GAAkB;AAJhC,GAAjB;AAMA,MAAIM,YAAY,GAAG,IAAIzD,iBAAJ,CAAsBc,YAAtB,EAAoCC,aAApC,EAAmDuC,UAAnD,CAAnB;;AAEA,MAAI,CAACrD,SAAS,CAACyD,YAAV,CAAuB5C,YAAvB,CAAD,IAAyC,CAACb,SAAS,CAACyD,YAAV,CAAuB3C,aAAvB,CAA9C,EAAqF;AACnF0C,IAAAA,YAAY,CAACE,OAAb,CAAqBC,eAArB,GAAuC,KAAvC;AACD;;AAED,MAAIxB,QAAQ,GAAG,IAAIlC,cAAJ,CAAmB;AAChC2D,IAAAA,WAAW,EAAE1C,eADmB;AAEhCU,IAAAA,OAAO,EAAEE,MAAM,CAAC+B,MAAP,CAAc;AACrB3C,MAAAA,eAAe,EAAEA;AADI,KAAd,EAENb,mBAAmB,CAACY,eAApB,CAAoCW,OAF9B,CAFuB;AAKhCJ,IAAAA,QAAQ,EAAEtB,aAAa,CAAC4D,KAAd,CAAoB9C,MAAM,CAACQ,QAA3B,CALsB;AAMhCuC,IAAAA,cAAc,EAAE/C,MAAM,CAAC+C,cANS;AAOhCC,IAAAA,YAAY,EAAEhD,MAAM,CAACgD;AAPW,GAAnB,CAAf;AASA7B,EAAAA,QAAQ,CAACX,QAAT,CAAkB,UAAlB,EAA8BC,KAA9B,GAAsC+B,YAAY,CAACE,OAAnD;AACAvB,EAAAA,QAAQ,CAACX,QAAT,CAAkB,OAAlB,EAA2BC,KAA3B,GAAmCd,KAAnC;AACAwB,EAAAA,QAAQ,CAACX,QAAT,CAAkB,eAAlB,EAAmCC,KAAnC,GAA2CuB,aAA3C;;AAEA,MAAI9B,eAAJ,EAAqB;AACnBiB,IAAAA,QAAQ,CAACX,QAAT,CAAkB,QAAlB,EAA4BC,KAA5B,GAAoC+B,YAAY,CAACN,YAAjD;AACD;;AAED,OAAKf,QAAL,GAAgBA,QAAhB;;AAEA,OAAK8B,QAAL,GAAgB,UAAUC,QAAV,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmC;AACjDjC,IAAAA,QAAQ,CAACX,QAAT,CAAkB,aAAlB,EAAiCC,KAAjC,GAAyCf,KAAK,CAACa,WAAN,IAAqB6C,MAAM,CAACC,QAAP,CAAgBC,MAAhB,KAA2BF,MAAM,CAACC,QAAP,CAAgBE,CAAhE,CAAzC,CADiD,CAC4D;AAC7G;AACA;;AAEApC,IAAAA,QAAQ,CAACX,QAAT,CAAkB,SAAlB,EAA6BC,KAA7B,GAAqCf,KAAK,CAACgB,OAA3C;AACAN,IAAAA,QAAQ,CAACoD,IAAT,CAAcJ,MAAM,CAACC,QAArB,EAA+BI,SAA/B;AACApD,IAAAA,QAAQ,CAACmD,IAAT,CAAcpD,QAAd,EAAwBsD,OAAxB,CAAgCvD,KAAhC;AACAgB,IAAAA,QAAQ,CAACX,QAAT,CAAkB,SAAlB,EAA6BC,KAA7B,GAAqC,CAACL,QAAQ,CAACuD,GAAT,CAAatD,QAAb,IAAyB,CAA1B,IAA+B,CAApE,CARiD,CAQsB;AACvE;;AAEAmB,IAAAA,sBAAsB,CAACoC,qBAAvB,CAA6ClE,KAAK,CAACmE,WAAnD;AACApC,IAAAA,mBAAmB,CAACmC,qBAApB,CAA0CR,MAAM,CAACS,WAAjD;AACAnC,IAAAA,cAAc,CAACoC,eAAf,CAA+BpE,KAAK,CAACmE,WAArC;AACAtC,IAAAA,MAAM,CAACN,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB;AACAM,IAAAA,MAAM,CAACwC,YAAP,CAAoBrC,cAApB;AACAG,IAAAA,IAAI,CAACmC,UAAL,CAAgBxC,sBAAhB,EAAwCC,mBAAxC,EAhBiD,CAgBa;;AAE9D,QAAII,IAAI,CAAC8B,GAAL,CAASpC,MAAT,IAAmB,CAAvB,EAA0B;AAC1BM,IAAAA,IAAI,CAAC6B,OAAL,CAAanC,MAAb,EAAqB0C,MAArB;AACApC,IAAAA,IAAI,CAACqC,GAAL,CAAS1C,sBAAT;AACAE,IAAAA,cAAc,CAACoC,eAAf,CAA+BV,MAAM,CAACS,WAAtC;AACAlC,IAAAA,cAAc,CAACV,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAC,CAA1B;AACAU,IAAAA,cAAc,CAACoC,YAAf,CAA4BrC,cAA5B;AACAC,IAAAA,cAAc,CAACuC,GAAf,CAAmBzC,mBAAnB;AACAK,IAAAA,MAAM,CAACkC,UAAP,CAAkBxC,sBAAlB,EAA0CG,cAA1C;AACAG,IAAAA,MAAM,CAAC4B,OAAP,CAAenC,MAAf,EAAuB0C,MAAvB;AACAnC,IAAAA,MAAM,CAACoC,GAAP,CAAW1C,sBAAX;AACAS,IAAAA,aAAa,CAACoB,QAAd,CAAuBG,IAAvB,CAA4B3B,IAA5B;AACAI,IAAAA,aAAa,CAACkC,EAAd,CAAiBlD,GAAjB,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACAgB,IAAAA,aAAa,CAACkC,EAAd,CAAiBJ,YAAjB,CAA8BrC,cAA9B;AACAO,IAAAA,aAAa,CAACkC,EAAd,CAAiBT,OAAjB,CAAyBnC,MAAzB;AACAU,IAAAA,aAAa,CAACmC,MAAd,CAAqBtC,MAArB;AACAG,IAAAA,aAAa,CAACoC,GAAd,GAAoBjB,MAAM,CAACiB,GAA3B,CAjCiD,CAiCjB;;AAEhCpC,IAAAA,aAAa,CAACqC,iBAAd;AACArC,IAAAA,aAAa,CAACsC,gBAAd,CAA+Bf,IAA/B,CAAoCJ,MAAM,CAACmB,gBAA3C,EApCiD,CAoCa;;AAE9DvC,IAAAA,aAAa,CAACf,GAAd,CAAkB,GAAlB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F;AACAe,IAAAA,aAAa,CAACwC,QAAd,CAAuBvC,aAAa,CAACsC,gBAArC;AACAvC,IAAAA,aAAa,CAACwC,QAAd,CAAuBvC,aAAa,CAACwC,kBAArC;AACAzC,IAAAA,aAAa,CAACwC,QAAd,CAAuB9E,KAAK,CAACmE,WAA7B,EAzCiD,CAyCN;AAC3C;;AAEAvC,IAAAA,cAAc,CAACoD,6BAAf,CAA6CnD,MAA7C,EAAqDC,sBAArD;AACAF,IAAAA,cAAc,CAACyC,YAAf,CAA4B9B,aAAa,CAACwC,kBAA1C;AACA7C,IAAAA,SAAS,CAACX,GAAV,CAAcK,cAAc,CAACC,MAAf,CAAsBoD,CAApC,EAAuCrD,cAAc,CAACC,MAAf,CAAsBgC,CAA7D,EAAgEjC,cAAc,CAACC,MAAf,CAAsBqD,CAAtF,EAAyFtD,cAAc,CAACuD,QAAxG;AACA,QAAIN,gBAAgB,GAAGtC,aAAa,CAACsC,gBAArC;AACAxC,IAAAA,CAAC,CAAC4C,CAAF,GAAM,CAACG,IAAI,CAACC,IAAL,CAAUnD,SAAS,CAAC+C,CAApB,IAAyBJ,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DT,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAAhE;AACAjD,IAAAA,CAAC,CAACwB,CAAF,GAAM,CAACuB,IAAI,CAACC,IAAL,CAAUnD,SAAS,CAAC2B,CAApB,IAAyBgB,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DT,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,CAAhE;AACAjD,IAAAA,CAAC,CAAC6C,CAAF,GAAM,CAAC,GAAP;AACA7C,IAAAA,CAAC,CAACkD,CAAF,GAAM,CAAC,MAAMV,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,CAAP,IAAwCT,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,CAA9C,CAnDiD,CAmD4B;;AAE7EpD,IAAAA,SAAS,CAACsD,cAAV,CAAyB,MAAMtD,SAAS,CAAC+B,GAAV,CAAc5B,CAAd,CAA/B,EArDiD,CAqDC;;AAElDwC,IAAAA,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,IAA+BpD,SAAS,CAAC+C,CAAzC;AACAJ,IAAAA,gBAAgB,CAACS,QAAjB,CAA0B,CAA1B,IAA+BpD,SAAS,CAAC2B,CAAzC;AACAgB,IAAAA,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,IAAgCpD,SAAS,CAACgD,CAAV,GAAc,GAAd,GAAoB7E,QAApD;AACAwE,IAAAA,gBAAgB,CAACS,QAAjB,CAA0B,EAA1B,IAAgCpD,SAAS,CAACqD,CAA1C,CA1DiD,CA0DJ;;AAE7CzC,IAAAA,YAAY,CAACE,OAAb,CAAqByC,QAArB,GAAgCjC,QAAQ,CAACkC,cAAzC,CA5DiD,CA4DQ;;AAEzD,QAAIC,mBAAmB,GAAGnC,QAAQ,CAACoC,eAAT,EAA1B;AACA,QAAIC,gBAAgB,GAAGrC,QAAQ,CAACsC,EAAT,CAAYC,OAAnC;AACA,QAAIC,uBAAuB,GAAGxC,QAAQ,CAACyC,SAAT,CAAmBC,UAAjD;AACA1C,IAAAA,QAAQ,CAACsC,EAAT,CAAYC,OAAZ,GAAsB,KAAtB,CAjEiD,CAiEpB;;AAE7BvC,IAAAA,QAAQ,CAACyC,SAAT,CAAmBC,UAAnB,GAAgC,KAAhC,CAnEiD,CAmEV;;AAEvC1C,IAAAA,QAAQ,CAAC2C,eAAT,CAAyBrD,YAAzB;AACAU,IAAAA,QAAQ,CAAC4C,KAAT,CAAeC,OAAf,CAAuBC,KAAvB,CAA6BC,OAA7B,CAAqC,IAArC,EAtEiD,CAsEL;;AAE5C,QAAI/C,QAAQ,CAACgD,SAAT,KAAuB,KAA3B,EAAkChD,QAAQ,CAACiD,KAAT;AAClCjD,IAAAA,QAAQ,CAACkD,MAAT,CAAgBjD,KAAhB,EAAuBlB,aAAvB;AACAiB,IAAAA,QAAQ,CAACsC,EAAT,CAAYC,OAAZ,GAAsBF,gBAAtB;AACArC,IAAAA,QAAQ,CAACyC,SAAT,CAAmBC,UAAnB,GAAgCF,uBAAhC;AACAxC,IAAAA,QAAQ,CAAC2C,eAAT,CAAyBR,mBAAzB,EA5EiD,CA4EF;;AAE/C,QAAIgB,QAAQ,GAAGjD,MAAM,CAACiD,QAAtB;;AAEA,QAAIA,QAAQ,KAAKzG,SAAjB,EAA4B;AAC1BsD,MAAAA,QAAQ,CAAC4C,KAAT,CAAeO,QAAf,CAAwBA,QAAxB;AACD,KAlFgD,CAkF/C;;AAEH,GApFD;;AAsFA,OAAKf,eAAL,GAAuB,YAAY;AACjC,WAAO9C,YAAP;AACD,GAFD;AAGD,CA1LD;;AA4LAnD,mBAAmB,CAACiH,SAApB,GAAgCxF,MAAM,CAACyF,MAAP,CAAclI,IAAI,CAACiI,SAAnB,CAAhC;AACAjH,mBAAmB,CAACiH,SAApB,CAA8BE,WAA9B,GAA4CnH,mBAA5C;AACAA,mBAAmB,CAACY,eAApB,GAAsC;AACpC;AACAW,EAAAA,OAAO,EAAE;AACPC,IAAAA,qBAAqB,EAAE,IADhB;AAEPQ,IAAAA,SAAS,EAAE;AAFJ,GAF2B;AAMpCb,EAAAA,QAAQ,EAAE;AACRb,IAAAA,KAAK,EAAE;AACLc,MAAAA,KAAK,EAAE;AADF,KADC;AAIRgG,IAAAA,QAAQ,EAAE;AACRhG,MAAAA,KAAK,EAAE;AADC,KAJF;AAORiG,IAAAA,MAAM,EAAE;AACNjG,MAAAA,KAAK,EAAE;AADD,KAPA;AAURuB,IAAAA,aAAa,EAAE;AACbvB,MAAAA,KAAK,EAAE;AADM,KAVP;AAaRF,IAAAA,WAAW,EAAE;AACXE,MAAAA,KAAK,EAAE;AADI,KAbL;AAgBRC,IAAAA,OAAO,EAAE;AACPD,MAAAA,KAAK,EAAE;AADA,KAhBD;AAmBRkG,IAAAA,OAAO,EAAE;AACPlG,MAAAA,KAAK,EAAE;AADA;AAnBD,GAN0B;AA6BpCuC,EAAAA,YAAY,EAAE,CAAC,6BAAD,EAAgC,mBAAhC,EAAqD,eAArD,EAAsE,+CAAtE,EAAuH,4EAAvH,EAAqM,GAArM,EAA0M4D,IAA1M,CAA+M,IAA/M,CA7BsB;AA8BpC7D,EAAAA,cAAc;AA9BsB,CAAtC;AAkEA,SAAS1D,mBAAT","sourcesContent":["import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get() {\n      return scope._isDistanceAttenuation;\n    },\n\n    set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get() {\n      return scope._isFresnel;\n    },\n\n    set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n\n  this.material = material;\n\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnel;\n\t\tvarying vec4 vUv;\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tfloat op=opacity;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tif(depth>maxDistance) discard;\n\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\tfloat ratio=1.-(depth/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef isFresnel\n\t\t\t\t\top*=fresnel;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"]},"metadata":{},"sourceType":"module"}