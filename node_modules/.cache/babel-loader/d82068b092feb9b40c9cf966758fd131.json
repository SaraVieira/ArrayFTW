{"ast":null,"code":"import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from 'three';\nimport { Pass } from './Pass.js';\n\nvar CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {\n  this.camera = camera;\n  this.needsSwap = false;\n  this.cubeShader = ShaderLib['cube'];\n  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n    vertexShader: this.cubeShader.vertexShader,\n    fragmentShader: this.cubeShader.fragmentShader,\n    depthTest: false,\n    depthWrite: false,\n    side: BackSide\n  }));\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\n    get: function get() {\n      return this.uniforms.envMap.value;\n    }\n  });\n  this.envMap = envMap;\n  this.opacity = opacity !== undefined ? opacity : 1.0;\n  this.cubeScene = new Scene();\n  this.cubeCamera = new PerspectiveCamera();\n  this.cubeScene.add(this.cubeMesh);\n};\n\nCubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: CubeTexturePass,\n  render: function render(renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n});\nexport { CubeTexturePass };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/postprocessing/CubeTexturePass.js"],"names":["ShaderLib","Mesh","BoxGeometry","ShaderMaterial","UniformsUtils","BackSide","Scene","PerspectiveCamera","Pass","CubeTexturePass","camera","envMap","opacity","needsSwap","cubeShader","cubeMesh","uniforms","clone","vertexShader","fragmentShader","depthTest","depthWrite","side","Object","defineProperty","material","get","value","undefined","cubeScene","cubeCamera","add","prototype","assign","create","constructor","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","flipEnvMap","isCubeTexture","_needsFlipEnvMap","transparent","setRenderTarget","renderToScreen","clear"],"mappings":"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","sourcesContent":["import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from 'three';\nimport { Pass } from './Pass.js';\n\nvar CubeTexturePass = function (camera, envMap, opacity) {\n  this.camera = camera;\n  this.needsSwap = false;\n  this.cubeShader = ShaderLib['cube'];\n  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n    vertexShader: this.cubeShader.vertexShader,\n    fragmentShader: this.cubeShader.fragmentShader,\n    depthTest: false,\n    depthWrite: false,\n    side: BackSide\n  }));\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\n    get: function () {\n      return this.uniforms.envMap.value;\n    }\n  });\n  this.envMap = envMap;\n  this.opacity = opacity !== undefined ? opacity : 1.0;\n  this.cubeScene = new Scene();\n  this.cubeCamera = new PerspectiveCamera();\n  this.cubeScene.add(this.cubeMesh);\n};\n\nCubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: CubeTexturePass,\n  render: function (renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n});\n\nexport { CubeTexturePass };\n"]},"metadata":{},"sourceType":"module"}