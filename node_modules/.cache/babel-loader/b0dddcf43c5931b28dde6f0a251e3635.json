{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n\nvar UVsDebug = function UVsDebug(geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new Vector2();\n  var b = new Vector2();\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n\n    if (index) {\n      // indexed geometry\n      for (var i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (var _i = 0, _il = uvAttribute.count; _i < _il; _i += 3) {\n        face[0] = _i;\n        face[1] = _i + 1;\n        face[2] = _i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, _i / 3);\n      }\n    }\n  }\n\n  return canvas;\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n\n    for (var _j = 0, _jl = uvs.length; _j < _jl; _j++) {\n      var uv = uvs[_j];\n      a.x += uv.x;\n      a.y += uv.y;\n\n      if (_j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\n\nexport { UVsDebug };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/utils/UVsDebug.js"],"names":["Vector2","UVsDebug","geometry","size","abc","a","b","uvs","face","canvas","document","createElement","width","height","ctx","getContext","lineWidth","strokeStyle","textAlign","fillStyle","fillRect","isGeometry","console","error","index","uvAttribute","attributes","uv","i","il","count","getX","fromBufferAttribute","processFace","beginPath","set","j","jl","length","x","y","moveTo","lineTo","closePath","stroke","divideScalar","font","fillText","addVectors","vnum"],"mappings":"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","sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n\nvar UVsDebug = function (geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new Vector2();\n  var b = new Vector2();\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n\n    if (index) {\n      // indexed geometry\n      for (let i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\n        face[0] = i;\n        face[1] = i + 1;\n        face[2] = i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    }\n  }\n\n  return canvas;\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      a.x += uv.x;\n      a.y += uv.y;\n\n      if (j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\n\nexport { UVsDebug };\n"]},"metadata":{},"sourceType":"module"}