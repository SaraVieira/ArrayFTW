{"ast":null,"code":"import { Matrix4, Ray, Sphere, Vector3 } from 'three';\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nvar _vA = new Vector3();\n\nfunction meshBounds(raycaster, intersects) {\n  var geometry = this.geometry;\n  var material = this.material;\n  var matrixWorld = this.matrixWorld;\n  if (material === undefined) return; // Checking boundingSphere distance to ray\n\n  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n  _sphere.copy(geometry.boundingSphere);\n\n  _sphere.applyMatrix4(matrixWorld);\n\n  if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n  _inverseMatrix.copy(matrixWorld).invert();\n\n  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;\n  intersects.push({\n    distance: _vA.distanceTo(raycaster.ray.origin),\n    point: _vA.clone(),\n    object: this\n  });\n}\n\nexport { meshBounds };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/@react-three/drei/core/meshBounds.js"],"names":["Matrix4","Ray","Sphere","Vector3","_inverseMatrix","_ray","_sphere","_vA","meshBounds","raycaster","intersects","geometry","material","matrixWorld","undefined","boundingSphere","computeBoundingSphere","copy","applyMatrix4","ray","intersectsSphere","invert","boundingBox","intersectBox","push","distance","distanceTo","origin","point","clone","object"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,GAAlB,EAAuBC,MAAvB,EAA+BC,OAA/B,QAA8C,OAA9C;;AAEA,IAAIC,cAAc,GAAG,IAAIJ,OAAJ,EAArB;;AAEA,IAAIK,IAAI,GAAG,IAAIJ,GAAJ,EAAX;;AAEA,IAAIK,OAAO,GAAG,IAAIJ,MAAJ,EAAd;;AAEA,IAAIK,GAAG,GAAG,IAAIJ,OAAJ,EAAV;;AAEA,SAASK,UAAT,CAAoBC,SAApB,EAA+BC,UAA/B,EAA2C;AACzC,MAAIC,QAAQ,GAAG,KAAKA,QAApB;AACA,MAAIC,QAAQ,GAAG,KAAKA,QAApB;AACA,MAAIC,WAAW,GAAG,KAAKA,WAAvB;AACA,MAAID,QAAQ,KAAKE,SAAjB,EAA4B,OAJa,CAIL;;AAEpC,MAAIH,QAAQ,CAACI,cAAT,KAA4B,IAAhC,EAAsCJ,QAAQ,CAACK,qBAAT;;AAEtCV,EAAAA,OAAO,CAACW,IAAR,CAAaN,QAAQ,CAACI,cAAtB;;AAEAT,EAAAA,OAAO,CAACY,YAAR,CAAqBL,WAArB;;AAEA,MAAIJ,SAAS,CAACU,GAAV,CAAcC,gBAAd,CAA+Bd,OAA/B,MAA4C,KAAhD,EAAuD;;AAEvDF,EAAAA,cAAc,CAACa,IAAf,CAAoBJ,WAApB,EAAiCQ,MAAjC;;AAEAhB,EAAAA,IAAI,CAACY,IAAL,CAAUR,SAAS,CAACU,GAApB,EAAyBD,YAAzB,CAAsCd,cAAtC,EAhByC,CAgBc;;;AAGvD,MAAIO,QAAQ,CAACW,WAAT,KAAyB,IAAzB,IAAiCjB,IAAI,CAACkB,YAAL,CAAkBZ,QAAQ,CAACW,WAA3B,EAAwCf,GAAxC,MAAiD,IAAtF,EAA4F;AAC5FG,EAAAA,UAAU,CAACc,IAAX,CAAgB;AACdC,IAAAA,QAAQ,EAAElB,GAAG,CAACmB,UAAJ,CAAejB,SAAS,CAACU,GAAV,CAAcQ,MAA7B,CADI;AAEdC,IAAAA,KAAK,EAAErB,GAAG,CAACsB,KAAJ,EAFO;AAGdC,IAAAA,MAAM,EAAE;AAHM,GAAhB;AAKD;;AAED,SAAStB,UAAT","sourcesContent":["import { Matrix4, Ray, Sphere, Vector3 } from 'three';\n\nlet _inverseMatrix = new Matrix4();\n\nlet _ray = new Ray();\n\nlet _sphere = new Sphere();\n\nlet _vA = new Vector3();\n\nfunction meshBounds(raycaster, intersects) {\n  let geometry = this.geometry;\n  let material = this.material;\n  let matrixWorld = this.matrixWorld;\n  if (material === undefined) return; // Checking boundingSphere distance to ray\n\n  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n  _sphere.copy(geometry.boundingSphere);\n\n  _sphere.applyMatrix4(matrixWorld);\n\n  if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n  _inverseMatrix.copy(matrixWorld).invert();\n\n  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;\n  intersects.push({\n    distance: _vA.distanceTo(raycaster.ray.origin),\n    point: _vA.clone(),\n    object: this\n  });\n}\n\nexport { meshBounds };\n"]},"metadata":{},"sourceType":"module"}