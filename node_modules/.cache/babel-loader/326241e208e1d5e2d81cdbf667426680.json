{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute } from 'three';\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function PLYLoader(manager) {\n  Loader.call(this, manager);\n  this.propertyNameMapping = {};\n};\n\nPLYLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PLYLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setPropertyNameMapping: function setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  },\n  parse: function parse(data) {\n    function parseHeader(data) {\n      var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      var headerText = '';\n      var headerLength = 0;\n      var result = patternHeader.exec(data);\n\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n\n      var header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      var lines = headerText.split('\\n');\n      var currentElement;\n      var lineType, lineValues;\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        var property = {\n          type: propertValues[0]\n        };\n\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n\n        return property;\n      }\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        lineValues = line.split(/\\s+/);\n        lineType = lineValues.shift();\n        line = lineValues.join(' ');\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n\n          case 'comment':\n            header.comments.push(line);\n            break;\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n\n      return header;\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      var values = line.split(/\\s+/);\n      var element = {};\n\n      for (var i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          var n = parseASCIINumber(values.shift(), properties[i].countType);\n\n          for (var j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n\n      return element;\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var result;\n      var patternBody = /end_header\\s([\\s\\S]*)$/;\n      var body = '';\n\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n\n      var lines = body.split('\\n');\n      var currentElement = 0;\n      var currentElementCount = 0;\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n\n        if (line === '') {\n          continue;\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n\n        var element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n\n      return postProcess(buffer);\n    }\n\n    function postProcess(buffer) {\n      var geometry = new BufferGeometry(); // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z);\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n        }\n      } else if (elementName === 'face') {\n        var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n        var texcoord = element.texcoord;\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      var element = {};\n      var result,\n          read = 0;\n\n      for (var i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          var n = result[0];\n          read += result[1];\n\n          for (var j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n\n      return [element, read];\n    }\n\n    function parseBinary(data, header) {\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var little_endian = header.format === 'binary_little_endian';\n      var body = new DataView(data, header.headerLength);\n      var result,\n          loc = 0;\n\n      for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          var element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n\n      return postProcess(buffer);\n    } //\n\n\n    var geometry;\n    var scope = this;\n\n    if (data instanceof ArrayBuffer) {\n      var text = LoaderUtils.decodeText(new Uint8Array(data));\n      var header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n\n    return geometry;\n  }\n});\nexport { PLYLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/PLYLoader.js"],"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PLYLoader","manager","call","propertyNameMapping","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","lineType","lineValues","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","shift","join","format","version","push","undefined","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","ArrayBuffer","decodeText","Uint8Array"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function (manager) {\n  Loader.call(this, manager);\n  this.propertyNameMapping = {};\n};\n\nPLYLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PLYLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setPropertyNameMapping: function (mapping) {\n    this.propertyNameMapping = mapping;\n  },\n  parse: function (data) {\n    function parseHeader(data) {\n      var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      var headerText = '';\n      var headerLength = 0;\n      var result = patternHeader.exec(data);\n\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n\n      var header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      var lines = headerText.split('\\n');\n      var currentElement;\n      var lineType, lineValues;\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        var property = {\n          type: propertValues[0]\n        };\n\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n\n        return property;\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        lineValues = line.split(/\\s+/);\n        lineType = lineValues.shift();\n        line = lineValues.join(' ');\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n\n          case 'comment':\n            header.comments.push(line);\n            break;\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n\n      return header;\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      var values = line.split(/\\s+/);\n      var element = {};\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          var n = parseASCIINumber(values.shift(), properties[i].countType);\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n\n      return element;\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var result;\n      var patternBody = /end_header\\s([\\s\\S]*)$/;\n      var body = '';\n\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n\n      var lines = body.split('\\n');\n      var currentElement = 0;\n      var currentElementCount = 0;\n\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n\n        if (line === '') {\n          continue;\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n\n        var element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n\n      return postProcess(buffer);\n    }\n\n    function postProcess(buffer) {\n      var geometry = new BufferGeometry(); // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z);\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n        }\n      } else if (elementName === 'face') {\n        var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n        var texcoord = element.texcoord;\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      var element = {};\n      var result,\n          read = 0;\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          var n = result[0];\n          read += result[1];\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n\n      return [element, read];\n    }\n\n    function parseBinary(data, header) {\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var little_endian = header.format === 'binary_little_endian';\n      var body = new DataView(data, header.headerLength);\n      var result,\n          loc = 0;\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          var element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n\n      return postProcess(buffer);\n    } //\n\n\n    var geometry;\n    var scope = this;\n\n    if (data instanceof ArrayBuffer) {\n      var text = LoaderUtils.decodeText(new Uint8Array(data));\n      var header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n\n    return geometry;\n  }\n});\n\nexport { PLYLoader };\n"]},"metadata":{},"sourceType":"module"}