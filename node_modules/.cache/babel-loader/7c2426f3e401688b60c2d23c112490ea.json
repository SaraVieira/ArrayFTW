{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { TextureCubeUVNode } from './TextureCubeUVNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { NormalNode } from '../accessors/NormalNode.js';\n\nfunction TextureCubeNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value;\n  this.radianceNode = new TextureCubeUVNode(this.value, uv || new ReflectNode(ReflectNode.VECTOR), // bias should be replaced in builder.context in build process\n  bias);\n  this.irradianceNode = new TextureCubeUVNode(this.value, new NormalNode(NormalNode.WORLD), new FloatNode(1).setReadonly(true));\n}\n\nTextureCubeNode.prototype = Object.create(TempNode.prototype);\nTextureCubeNode.prototype.constructor = TextureCubeNode;\nTextureCubeNode.prototype.nodeType = 'TextureCube';\n\nTextureCubeNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    builder.require('irradiance');\n\n    if (builder.context.bias) {\n      builder.context.bias.setTexture(this.value);\n    }\n\n    var scopeNode = builder.slot === 'irradiance' ? this.irradianceNode : this.radianceNode;\n    return scopeNode.build(builder, output);\n  } else {\n    console.warn('THREE.TextureCubeNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.value = source.value;\n  return this;\n};\n\nTextureCubeNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/misc/TextureCubeNode.js"],"names":["TempNode","FloatNode","TextureCubeUVNode","ReflectNode","NormalNode","TextureCubeNode","value","uv","bias","call","radianceNode","VECTOR","irradianceNode","WORLD","setReadonly","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","require","context","setTexture","scopeNode","slot","build","console","warn","shader","format","getType","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"AAAA,SAASA,QAAT,QAAyB,qBAAzB;AACA,SAASC,SAAT,QAA0B,wBAA1B;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,UAAT,QAA2B,4BAA3B;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,EAAhC,EAAoCC,IAApC,EAA0C;AACxCR,EAAAA,QAAQ,CAACS,IAAT,CAAc,IAAd,EAAoB,IAApB;AACA,OAAKH,KAAL,GAAaA,KAAb;AACA,OAAKI,YAAL,GAAoB,IAAIR,iBAAJ,CAAsB,KAAKI,KAA3B,EAAkCC,EAAE,IAAI,IAAIJ,WAAJ,CAAgBA,WAAW,CAACQ,MAA5B,CAAxC,EAA6E;AACjGH,EAAAA,IADoB,CAApB;AAEA,OAAKI,cAAL,GAAsB,IAAIV,iBAAJ,CAAsB,KAAKI,KAA3B,EAAkC,IAAIF,UAAJ,CAAeA,UAAU,CAACS,KAA1B,CAAlC,EAAoE,IAAIZ,SAAJ,CAAc,CAAd,EAAiBa,WAAjB,CAA6B,IAA7B,CAApE,CAAtB;AACD;;AAEDT,eAAe,CAACU,SAAhB,GAA4BC,MAAM,CAACC,MAAP,CAAcjB,QAAQ,CAACe,SAAvB,CAA5B;AACAV,eAAe,CAACU,SAAhB,CAA0BG,WAA1B,GAAwCb,eAAxC;AACAA,eAAe,CAACU,SAAhB,CAA0BI,QAA1B,GAAqC,aAArC;;AAEAd,eAAe,CAACU,SAAhB,CAA0BK,QAA1B,GAAqC,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC9D,MAAID,OAAO,CAACE,QAAR,CAAiB,UAAjB,CAAJ,EAAkC;AAChCF,IAAAA,OAAO,CAACG,OAAR,CAAgB,YAAhB;;AAEA,QAAIH,OAAO,CAACI,OAAR,CAAgBjB,IAApB,EAA0B;AACxBa,MAAAA,OAAO,CAACI,OAAR,CAAgBjB,IAAhB,CAAqBkB,UAArB,CAAgC,KAAKpB,KAArC;AACD;;AAED,QAAIqB,SAAS,GAAGN,OAAO,CAACO,IAAR,KAAiB,YAAjB,GAAgC,KAAKhB,cAArC,GAAsD,KAAKF,YAA3E;AACA,WAAOiB,SAAS,CAACE,KAAV,CAAgBR,OAAhB,EAAyBC,MAAzB,CAAP;AACD,GATD,MASO;AACLQ,IAAAA,OAAO,CAACC,IAAR,CAAa,kDAAkDV,OAAO,CAACW,MAA1D,GAAmE,UAAhF;AACA,WAAOX,OAAO,CAACY,MAAR,CAAe,aAAf,EAA8B,KAAKC,OAAL,CAAab,OAAb,CAA9B,EAAqDC,MAArD,CAAP;AACD;AACF,CAdD;;AAgBAjB,eAAe,CAACU,SAAhB,CAA0BoB,IAA1B,GAAiC,UAAUC,MAAV,EAAkB;AACjDpC,EAAAA,QAAQ,CAACe,SAAT,CAAmBoB,IAAnB,CAAwB1B,IAAxB,CAA6B,IAA7B,EAAmC2B,MAAnC;AACA,OAAK9B,KAAL,GAAa8B,MAAM,CAAC9B,KAApB;AACA,SAAO,IAAP;AACD,CAJD;;AAMAD,eAAe,CAACU,SAAhB,CAA0BsB,MAA1B,GAAmC,UAAUC,IAAV,EAAgB;AACjD,MAAIC,IAAI,GAAG,KAAKC,WAAL,CAAiBF,IAAjB,CAAX;;AAEA,MAAI,CAACC,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAG,KAAKE,cAAL,CAAoBH,IAApB,CAAP;AACAC,IAAAA,IAAI,CAACjC,KAAL,GAAa,KAAKA,KAAL,CAAW+B,MAAX,CAAkBC,IAAlB,EAAwBI,IAArC;AACD;;AAED,SAAOH,IAAP;AACD,CATD;;AAWA,SAASlC,eAAT","sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { TextureCubeUVNode } from './TextureCubeUVNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { NormalNode } from '../accessors/NormalNode.js';\n\nfunction TextureCubeNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value;\n  this.radianceNode = new TextureCubeUVNode(this.value, uv || new ReflectNode(ReflectNode.VECTOR), // bias should be replaced in builder.context in build process\n  bias);\n  this.irradianceNode = new TextureCubeUVNode(this.value, new NormalNode(NormalNode.WORLD), new FloatNode(1).setReadonly(true));\n}\n\nTextureCubeNode.prototype = Object.create(TempNode.prototype);\nTextureCubeNode.prototype.constructor = TextureCubeNode;\nTextureCubeNode.prototype.nodeType = 'TextureCube';\n\nTextureCubeNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    builder.require('irradiance');\n\n    if (builder.context.bias) {\n      builder.context.bias.setTexture(this.value);\n    }\n\n    var scopeNode = builder.slot === 'irradiance' ? this.irradianceNode : this.radianceNode;\n    return scopeNode.build(builder, output);\n  } else {\n    console.warn('THREE.TextureCubeNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.value = source.value;\n  return this;\n};\n\nTextureCubeNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeNode };\n"]},"metadata":{},"sourceType":"module"}