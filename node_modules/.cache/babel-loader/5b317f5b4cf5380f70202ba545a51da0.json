{"ast":null,"code":"import { InputNode } from '../core/InputNode.js';\nimport { UVNode } from '../accessors/UVNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction TextureNode(value, uv, bias, project) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new UVNode();\n  this.bias = bias;\n  this.project = project !== undefined ? project : false;\n}\n\nTextureNode.prototype = Object.create(InputNode.prototype);\nTextureNode.prototype.constructor = TextureNode;\nTextureNode.prototype.nodeType = 'Texture';\n\nTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 't');\n};\n\nTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'sampler2D') {\n    return this.getTexture(builder, output);\n  }\n\n  var tex = this.getTexture(builder, output),\n      uv = this.uv.build(builder, this.project ? 'v4' : 'v2'),\n      bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var method, code;\n  if (this.project) method = 'texture2DProj';else method = bias ? 'tex2DBias' : 'tex2D';\n  if (bias) code = method + '( ' + tex + ', ' + uv + ', ' + bias + ' )';else code = method + '( ' + tex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  if (source.project !== undefined) this.project = source.project;\n  return this;\n};\n\nTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    if (this.value) data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.project = this.project;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/inputs/TextureNode.js"],"names":["InputNode","UVNode","ColorSpaceNode","ExpressionNode","TextureNode","value","uv","bias","project","call","shared","undefined","prototype","Object","create","constructor","nodeType","getTexture","builder","output","generate","uuid","tex","build","context","setTexture","method","code","include","isShader","ignoreCache","outputType","getType","addContext","colorSpace","fromDecoding","getTextureEncodingFromMap","input","parse","removeContext","format","copy","source","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":"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","sourcesContent":["import { InputNode } from '../core/InputNode.js';\nimport { UVNode } from '../accessors/UVNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction TextureNode(value, uv, bias, project) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new UVNode();\n  this.bias = bias;\n  this.project = project !== undefined ? project : false;\n}\n\nTextureNode.prototype = Object.create(InputNode.prototype);\nTextureNode.prototype.constructor = TextureNode;\nTextureNode.prototype.nodeType = 'Texture';\n\nTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 't');\n};\n\nTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'sampler2D') {\n    return this.getTexture(builder, output);\n  }\n\n  var tex = this.getTexture(builder, output),\n      uv = this.uv.build(builder, this.project ? 'v4' : 'v2'),\n      bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var method, code;\n  if (this.project) method = 'texture2DProj';else method = bias ? 'tex2DBias' : 'tex2D';\n  if (bias) code = method + '( ' + tex + ', ' + uv + ', ' + bias + ' )';else code = method + '( ' + tex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  if (source.project !== undefined) this.project = source.project;\n  return this;\n};\n\nTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    if (this.value) data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.project = this.project;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureNode };\n"]},"metadata":{},"sourceType":"module"}