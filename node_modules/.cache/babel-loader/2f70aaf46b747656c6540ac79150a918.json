{"ast":null,"code":"import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, LinearFilter, RGBFormat } from 'three';\n\nvar Refractor = function Refractor(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Refractor';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Refractor.RefractorShader; //\n\n  var virtualCamera = new PerspectiveCamera();\n  virtualCamera.matrixAutoUpdate = false;\n  virtualCamera.userData.refractor = true; //\n\n  var refractorPlane = new Plane();\n  var textureMatrix = new Matrix4(); // render target\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  } // material\n\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true // ensures, refractors are drawn from farthest to closest\n\n  });\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n  var visible = function () {\n    var refractorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var view = new Vector3();\n    var normal = new Vector3();\n    return function visible(camera) {\n      refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      view.subVectors(refractorWorldPosition, cameraWorldPosition);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      return view.dot(normal) < 0;\n    };\n  }();\n\n  var updateRefractorPlane = function () {\n    var normal = new Vector3();\n    var position = new Vector3();\n    var quaternion = new Quaternion();\n    var scale = new Vector3();\n    return function updateRefractorPlane() {\n      scope.matrixWorld.decompose(position, quaternion, scale);\n      normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n      normal.negate();\n      refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n    };\n  }();\n\n  var updateVirtualCamera = function () {\n    var clipPlane = new Plane();\n    var clipVector = new Vector4();\n    var q = new Vector4();\n    return function updateVirtualCamera(camera) {\n      virtualCamera.matrixWorld.copy(camera.matrixWorld);\n      virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      virtualCamera.far = camera.far; // used in WebGLBackground\n      // The following code creates an oblique view frustum for clipping.\n      // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n      // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n      clipPlane.copy(refractorPlane);\n      clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n      // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n      clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipVector.x;\n      projectionMatrix.elements[6] = clipVector.y;\n      projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipVector.w;\n    };\n  }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n  // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n  function updateTextureMatrix(camera) {\n    // this matrix does range mapping to [ 0, 1 ]\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n    // (matrix above) with the projection and view matrix of the virtual camera\n    // and the model matrix of the refractor\n\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  } //\n\n\n  function render(renderer, scene, camera) {\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    // Render\n    renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n    if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n    if (!visible(camera) === true) return; // update\n\n    updateRefractorPlane();\n    updateTextureMatrix(camera);\n    updateVirtualCamera(camera);\n    render(renderer, scene, camera);\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nRefractor.prototype = Object.create(Mesh.prototype);\nRefractor.prototype.constructor = Refractor;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Refractor };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/objects/Refractor.js"],"names":["Mesh","Color","PerspectiveCamera","Plane","Matrix4","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","LinearFilter","RGBFormat","Refractor","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","vertexShader","fragmentShader","transparent","value","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","encoding","outputEncoding","prototype","Object","create","constructor","tDiffuse","join"],"mappings":"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","sourcesContent":["import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, LinearFilter, RGBFormat } from 'three';\n\nvar Refractor = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Refractor';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Refractor.RefractorShader; //\n\n  var virtualCamera = new PerspectiveCamera();\n  virtualCamera.matrixAutoUpdate = false;\n  virtualCamera.userData.refractor = true; //\n\n  var refractorPlane = new Plane();\n  var textureMatrix = new Matrix4(); // render target\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  } // material\n\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true // ensures, refractors are drawn from farthest to closest\n\n  });\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n  var visible = function () {\n    var refractorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var view = new Vector3();\n    var normal = new Vector3();\n    return function visible(camera) {\n      refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      view.subVectors(refractorWorldPosition, cameraWorldPosition);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      return view.dot(normal) < 0;\n    };\n  }();\n\n  var updateRefractorPlane = function () {\n    var normal = new Vector3();\n    var position = new Vector3();\n    var quaternion = new Quaternion();\n    var scale = new Vector3();\n    return function updateRefractorPlane() {\n      scope.matrixWorld.decompose(position, quaternion, scale);\n      normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n      normal.negate();\n      refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n    };\n  }();\n\n  var updateVirtualCamera = function () {\n    var clipPlane = new Plane();\n    var clipVector = new Vector4();\n    var q = new Vector4();\n    return function updateVirtualCamera(camera) {\n      virtualCamera.matrixWorld.copy(camera.matrixWorld);\n      virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      virtualCamera.far = camera.far; // used in WebGLBackground\n      // The following code creates an oblique view frustum for clipping.\n      // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n      // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n      clipPlane.copy(refractorPlane);\n      clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n      // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n      clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipVector.x;\n      projectionMatrix.elements[6] = clipVector.y;\n      projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipVector.w;\n    };\n  }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n  // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n  function updateTextureMatrix(camera) {\n    // this matrix does range mapping to [ 0, 1 ]\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n    // (matrix above) with the projection and view matrix of the virtual camera\n    // and the model matrix of the refractor\n\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  } //\n\n\n  function render(renderer, scene, camera) {\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    // Render\n    renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n    if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n    if (!visible(camera) === true) return; // update\n\n    updateRefractorPlane();\n    updateTextureMatrix(camera);\n    updateVirtualCamera(camera);\n    render(renderer, scene, camera);\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nRefractor.prototype = Object.create(Mesh.prototype);\nRefractor.prototype.constructor = Refractor;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexport { Refractor };\n"]},"metadata":{},"sourceType":"module"}