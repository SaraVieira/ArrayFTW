{"ast":null,"code":"import { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\n\nfunction BasicNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xffffff);\n}\n\nBasicNode.prototype = Object.create(Node.prototype);\nBasicNode.prototype.constructor = BasicNode;\nBasicNode.prototype.nodeType = 'Basic';\n\nBasicNode.prototype.generate = function (builder) {\n  var code;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // Normal computed with derivatives when FLAT_SHADED\n    ' vNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\n    code = output.join('\\n');\n  } else {\n    // Analyze all nodes to reuse generate codes\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.mask) this.mask.analyze(builder); // Build code\n\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = [// add before: prevent undeclared normal\n    '#include <normal_fragment_begin>', color.code];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', ' if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4(' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4(' + color.result + ', 1.0 );');\n    }\n\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nBasicNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source);\n  this.color = source.color;\n  if (source.position) this.position = source.position;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.mask) this.mask = source.mask;\n  return this;\n};\n\nBasicNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.position) data.position = this.position.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { BasicNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/materials/nodes/BasicNode.js"],"names":["Node","ColorNode","BasicNode","call","color","prototype","Object","create","constructor","nodeType","generate","builder","code","isShader","position","analyzeAndFlow","cache","undefined","addParsCode","join","output","push","result","analyze","slot","alpha","mask","flow","requires","transparent","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\n\nfunction BasicNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xffffff);\n}\n\nBasicNode.prototype = Object.create(Node.prototype);\nBasicNode.prototype.constructor = BasicNode;\nBasicNode.prototype.nodeType = 'Basic';\n\nBasicNode.prototype.generate = function (builder) {\n  var code;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // Normal computed with derivatives when FLAT_SHADED\n    ' vNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\n    code = output.join('\\n');\n  } else {\n    // Analyze all nodes to reuse generate codes\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.mask) this.mask.analyze(builder); // Build code\n\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = [// add before: prevent undeclared normal\n    '#include <normal_fragment_begin>', color.code];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', ' if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4(' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4(' + color.result + ', 1.0 );');\n    }\n\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nBasicNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source);\n  this.color = source.color;\n  if (source.position) this.position = source.position;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.mask) this.mask = source.mask;\n  return this;\n};\n\nBasicNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.position) data.position = this.position.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { BasicNode };\n"]},"metadata":{},"sourceType":"module"}