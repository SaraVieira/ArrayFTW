{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { InputNode } from '../core/InputNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { TextureNode } from './TextureNode.js';\nimport { Matrix4Node } from './Matrix4Node.js';\n\nfunction ReflectorNode(mirror) {\n  TempNode.call(this, 'v4');\n  if (mirror) this.setMirror(mirror);\n}\n\nReflectorNode.prototype = Object.create(TempNode.prototype);\nReflectorNode.prototype.constructor = ReflectorNode;\nReflectorNode.prototype.nodeType = 'Reflector';\n\nReflectorNode.prototype.setMirror = function (mirror) {\n  this.mirror = mirror;\n  this.textureMatrix = new Matrix4Node(this.mirror.material.uniforms.textureMatrix.value);\n  this.localPosition = new PositionNode(PositionNode.LOCAL);\n  this.uv = new OperatorNode(this.textureMatrix, this.localPosition, OperatorNode.MUL);\n  this.uvResult = new OperatorNode(null, this.uv, OperatorNode.ADD);\n  this.texture = new TextureNode(this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true);\n};\n\nReflectorNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    this.uvResult.a = this.offset;\n    this.texture.uv = this.offset ? this.uvResult : this.uv;\n\n    if (output === 'sampler2D') {\n      return this.texture.build(builder, output);\n    }\n\n    return builder.format(this.texture.build(builder, this.type), this.type, output);\n  } else {\n    console.warn('THREE.ReflectorNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.type, output);\n  }\n};\n\nReflectorNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  this.scope.mirror = source.mirror;\n  return this;\n};\n\nReflectorNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.mirror = this.mirror.uuid;\n    if (this.offset) data.offset = this.offset.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { ReflectorNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/inputs/ReflectorNode.js"],"names":["TempNode","InputNode","PositionNode","OperatorNode","TextureNode","Matrix4Node","ReflectorNode","mirror","call","setMirror","prototype","Object","create","constructor","nodeType","textureMatrix","material","uniforms","value","localPosition","LOCAL","uv","MUL","uvResult","ADD","texture","tDiffuse","generate","builder","output","isShader","a","offset","build","format","type","console","warn","shader","copy","source","scope","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { InputNode } from '../core/InputNode.js';\nimport { PositionNode } from '../accessors/PositionNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { TextureNode } from './TextureNode.js';\nimport { Matrix4Node } from './Matrix4Node.js';\n\nfunction ReflectorNode(mirror) {\n  TempNode.call(this, 'v4');\n  if (mirror) this.setMirror(mirror);\n}\n\nReflectorNode.prototype = Object.create(TempNode.prototype);\nReflectorNode.prototype.constructor = ReflectorNode;\nReflectorNode.prototype.nodeType = 'Reflector';\n\nReflectorNode.prototype.setMirror = function (mirror) {\n  this.mirror = mirror;\n  this.textureMatrix = new Matrix4Node(this.mirror.material.uniforms.textureMatrix.value);\n  this.localPosition = new PositionNode(PositionNode.LOCAL);\n  this.uv = new OperatorNode(this.textureMatrix, this.localPosition, OperatorNode.MUL);\n  this.uvResult = new OperatorNode(null, this.uv, OperatorNode.ADD);\n  this.texture = new TextureNode(this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true);\n};\n\nReflectorNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    this.uvResult.a = this.offset;\n    this.texture.uv = this.offset ? this.uvResult : this.uv;\n\n    if (output === 'sampler2D') {\n      return this.texture.build(builder, output);\n    }\n\n    return builder.format(this.texture.build(builder, this.type), this.type, output);\n  } else {\n    console.warn('THREE.ReflectorNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.type, output);\n  }\n};\n\nReflectorNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  this.scope.mirror = source.mirror;\n  return this;\n};\n\nReflectorNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.mirror = this.mirror.uuid;\n    if (this.offset) data.offset = this.offset.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { ReflectorNode };\n"]},"metadata":{},"sourceType":"module"}