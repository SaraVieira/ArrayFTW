{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { Parser, createToken, Lexer } from 'chevrotain';\n\nvar VRMLLoader = function () {\n  // class definitions\n  function VRMLLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  VRMLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: VRMLLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function parse(data, path) {\n      var nodeMap = {};\n\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = createToken({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n        'Inline', 'LOD', 'Switch', // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = createToken({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = createToken({\n          name: 'StringLiteral',\n          pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n        });\n        var HexLiteral = createToken({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = createToken({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        });\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data.routes.push(this.visit(route));\n              }\n            }\n\n            return data;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n\n            return data;\n          },\n          field: function field(ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n\n          if (ctx.node) {\n            field.type = 'node';\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n\n          if (ctx.use) {\n            field.type = 'use';\n\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n\n          return field;\n        }\n\n        return new VRMLToASTVisitor();\n      }\n\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var node = nodes[_i8];\n          var object = getNode(node);\n          if (object instanceof Object3D) scene.add(object);\n          if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n\n        return scene;\n      }\n\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n\n        return build;\n      }\n\n      function buildGroupingNode(node) {\n        var object = new Group(); //\n\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n\n            case 'bboxSize':\n              // field not supported\n              break;\n\n            case 'center':\n              // field not supported\n              break;\n\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n\n            case 'collide':\n              // field not supported\n              break;\n\n            case 'rotation':\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'scaleOrientation':\n              // field not supported\n              break;\n\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'proxy':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return object;\n      }\n\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n\n            case 'backUrl':\n              // field not supported\n              break;\n\n            case 'bottomUrl':\n              // field not supported\n              break;\n\n            case 'frontUrl':\n              // field not supported\n              break;\n\n            case 'leftUrl':\n              // field not supported\n              break;\n\n            case 'rightUrl':\n              // field not supported\n              break;\n\n            case 'topUrl':\n              // field not supported\n              break;\n\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n\n        var object;\n\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new PointsMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new LineBasicMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            } // check for vertex colors\n\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n\n        return object;\n      }\n\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n\n              break;\n\n            case 'texture':\n              var textureNode = fieldValues[0];\n\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n\n              break;\n\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n\n            delete material.map.__type;\n          } // apply texture transform\n\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n\n        return material;\n      }\n\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n\n            case 'diffuseColor':\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'emissiveColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n\n            case 'specularColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return materialData;\n      }\n\n      function parseHexColor(hex, textureType, color) {\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            var value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            break;\n\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            var value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            break;\n\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n\n      function getTextureType(num_components) {\n        var type;\n\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n\n        return type;\n      }\n\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var useAlpha = num_components === 2 || num_components === 4;\n              var textureType = getTextureType(num_components);\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\n              var data = new Uint8Array(size);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n\n                if (useAlpha === true) {\n                  var stride = k * 4;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                  data[stride + 3] = color.a;\n                } else {\n                  var stride = k * 3;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                }\n              }\n\n              texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return transformData;\n      }\n\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return worldInfo;\n      }\n\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n            solid = true,\n            creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n            normalPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var positionAttribute;\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            }\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n\n      function buildPointSetNode(node) {\n        var geometry;\n        var color, coord;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n\n      function buildConeNode(node) {\n        var radius = 1,\n            height = 2,\n            openEnded = false;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n\n      function buildCylinderNode(node) {\n        var radius = 1,\n            height = 2;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            case 'top':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'height':\n              height = fieldValues;\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = _i9 * xDimension + j; // vertices\n\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n\n        var indices = [];\n\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = _i10 + _j * xDimension;\n            var b = _i10 + (_j + 1) * xDimension;\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var index = _i11 + _j2 * (xDimension - 1);\n                var r = color[index * 3 + 0];\n                var g = color[index * 3 + 1];\n                var b = color[index * 3 + 2]; // one color per quad\n\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n              }\n            }\n\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var index = _i12 + _j3 * (xDimension - 1);\n                var xn = normal[index * 3 + 0];\n                var yn = normal[index * 3 + 1];\n                var zn = normal[index * 3 + 2]; // one normal per quad\n\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n              }\n            }\n\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n\n            case 'scale':\n              scale = fieldValues;\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          } // end cap\n\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n\n        return indices;\n      }\n\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      function flattenData(data, index) {\n        var flattenData = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n\n        return flattenData;\n      }\n\n      function expandLineIndex(index) {\n        var indices = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n\n        return indices;\n      }\n\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n\n        return new Float32BufferAttribute(array, itemSize);\n      }\n\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n\n      var ab = new Vector3();\n      var cb = new Vector3();\n\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n\n        var normals = [];\n\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n          vA.fromArray(coord, face.a * 3);\n          vB.fromArray(coord, face.b * 3);\n          vC.fromArray(coord, face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n\n        return new Float32BufferAttribute(normals, 3);\n      }\n\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n\n        return normal.normalize();\n      }\n\n      function toColorArray(colors) {\n        var array = [];\n\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA, thresholdIndexB;\n          var t = 1;\n\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  });\n\n  function VRMLLexer(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  VRMLLexer.prototype = {\n    constructor: VRMLLexer,\n    lex: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n\n      return lexingResult;\n    }\n  };\n\n  function VRMLParser(tokenVocabulary) {\n    Parser.call(this, tokenVocabulary); // eslint-disable-line no-undef\n\n    var $ = this;\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n  VRMLParser.prototype = Object.create(Parser.prototype); // eslint-disable-line no-undef\n\n  VRMLParser.prototype.constructor = VRMLParser;\n\n  function Face(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n  var TEXTURE_TYPE = {\n    INTENSITY: 1,\n    INTENSITY_ALPHA: 2,\n    RGB: 3,\n    RGBA: 4\n  };\n  return VRMLLoader;\n}();\n\nexport { VRMLLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/VRMLLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Vector3","Vector2","TextureLoader","Scene","Object3D","Group","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","DataTexture","RGBAFormat","RGBFormat","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","RepeatWrapping","ClampToEdgeWrapping","Parser","createToken","Lexer","VRMLLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree","scene","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","undefined","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","INTENSITY","value","parseInt","r","g","b","substring","a","getTextureType","num_components","texture","wrapS","wrapT","width","height","useAlpha","size","Uint8Array","k","stride","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","positionAttribute","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","inputText","tokenize","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { Parser, createToken, Lexer } from 'chevrotain';\n\nvar VRMLLoader = function () {\n  // class definitions\n  function VRMLLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  VRMLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: VRMLLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (data, path) {\n      var nodeMap = {};\n\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = createToken({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n        'Inline', 'LOD', 'Switch', // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = createToken({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = createToken({\n          name: 'StringLiteral',\n          pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n        });\n        var HexLiteral = createToken({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = createToken({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        });\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n\n        for (let i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function (ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n\n            if (ctx.route) {\n              for (let i = 0, l = ctx.route.length; i < l; i++) {\n                var route = ctx.route[i];\n                data.routes.push(this.visit(route));\n              }\n            }\n\n            return data;\n          },\n          version: function (ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function (ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n\n            if (ctx.field) {\n              for (let i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n\n            return data;\n          },\n          field: function (ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function (ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function (ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          route: function (ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n\n          if (ctx.node) {\n            field.type = 'node';\n\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n\n          if (ctx.use) {\n            field.type = 'use';\n\n            for (let i = 0, l = ctx.use.length; i < l; i++) {\n              var use = ctx.use[i];\n              field.values.push(scope.visit(use));\n            }\n          }\n\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n\n            for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n              var stringLiteral = ctx.StringLiteral[i];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n\n            for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n              var numberLiteral = ctx.NumberLiteral[i];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n\n            for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n              var hexLiteral = ctx.HexLiteral[i];\n              field.values.push(hexLiteral.image);\n            }\n          }\n\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n\n            for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n              var trueLiteral = ctx.TrueLiteral[i];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n\n            for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n              var falseLiteral = ctx.FalseLiteral[i];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n\n          return field;\n        }\n\n        return new VRMLToASTVisitor();\n      }\n\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          var object = getNode(node);\n          if (object instanceof Object3D) scene.add(object);\n          if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n\n        return scene;\n      }\n\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n\n            for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n\n        return build;\n      }\n\n      function buildGroupingNode(node) {\n        var object = new Group(); //\n\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n\n            case 'bboxSize':\n              // field not supported\n              break;\n\n            case 'center':\n              // field not supported\n              break;\n\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n\n            case 'collide':\n              // field not supported\n              break;\n\n            case 'rotation':\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'scaleOrientation':\n              // field not supported\n              break;\n\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'proxy':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return object;\n      }\n\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n\n            case 'backUrl':\n              // field not supported\n              break;\n\n            case 'bottomUrl':\n              // field not supported\n              break;\n\n            case 'frontUrl':\n              // field not supported\n              break;\n\n            case 'leftUrl':\n              // field not supported\n              break;\n\n            case 'rightUrl':\n              // field not supported\n              break;\n\n            case 'topUrl':\n              // field not supported\n              break;\n\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n\n        var object;\n\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new PointsMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new LineBasicMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            } // check for vertex colors\n\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n\n        return object;\n      }\n\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n\n              break;\n\n            case 'texture':\n              var textureNode = fieldValues[0];\n\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n\n              break;\n\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n\n            delete material.map.__type;\n          } // apply texture transform\n\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n\n        return material;\n      }\n\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n\n            case 'diffuseColor':\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'emissiveColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n\n            case 'specularColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return materialData;\n      }\n\n      function parseHexColor(hex, textureType, color) {\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            var value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            break;\n\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            var value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            break;\n\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n\n      function getTextureType(num_components) {\n        var type;\n\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n\n        return type;\n      }\n\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var useAlpha = num_components === 2 || num_components === 4;\n              var textureType = getTextureType(num_components);\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\n              var data = new Uint8Array(size);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n\n              for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n\n                if (useAlpha === true) {\n                  var stride = k * 4;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                  data[stride + 3] = color.a;\n                } else {\n                  var stride = k * 3;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                }\n              }\n\n              texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return transformData;\n      }\n\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return worldInfo;\n      }\n\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n            solid = true,\n            creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n            normalPerVertex = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var positionAttribute;\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            }\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n\n      function buildPointSetNode(node) {\n        var geometry;\n        var color, coord;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n\n      function buildConeNode(node) {\n        var radius = 1,\n            height = 2,\n            openEnded = false;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n\n      function buildCylinderNode(node) {\n        var radius = 1,\n            height = 2;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            case 'top':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'height':\n              height = fieldValues;\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n\n        for (let i = 0; i < zDimension; i++) {\n          for (let j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = i * xDimension + j; // vertices\n\n            var x = xSpacing * i;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n\n        var indices = [];\n\n        for (let i = 0; i < xDimension - 1; i++) {\n          for (let j = 0; j < zDimension - 1; j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = i + j * xDimension;\n            var b = i + (j + 1) * xDimension;\n            var c = i + 1 + (j + 1) * xDimension;\n            var d = i + 1 + j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var r = color[index * 3 + 0];\n                var g = color[index * 3 + 1];\n                var b = color[index * 3 + 2]; // one color per quad\n\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n              }\n            }\n\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var xn = normal[index * 3 + 0];\n                var yn = normal[index * 3 + 1];\n                var zn = normal[index * 3 + 2]; // one normal per quad\n\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n              }\n            }\n\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n\n            case 'scale':\n              scale = fieldValues;\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n\n        for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, i);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n\n          for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n\n        for (let i = 0; i < spineCount - 1; i++) {\n          for (let j = 0; j < crossSectionCount - 1; j++) {\n            var a = j + i * crossSectionCount;\n            var b = j + 1 + i * crossSectionCount;\n            var c = j + (i + 1) * crossSectionCount;\n            var d = j + 1 + (i + 1) * crossSectionCount;\n\n            if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = i * crossSectionCount;\n              d = (i + 1) * crossSectionCount;\n            }\n\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n\n          for (let i = 0, l = crossSection.length; i < l; i += 2) {\n            contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n          }\n\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n\n          for (let i = 0, l = faces.length; i < l; i++) {\n            var face = faces[i];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n\n          if (beginCap === true) {\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n              } else {\n                indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n              }\n            }\n          } // end cap\n\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n              }\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n\n      function parseFieldChildren(children, owner) {\n        for (let i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n\n        return indices;\n      }\n\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      function flattenData(data, index) {\n        var flattenData = [];\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n\n        return flattenData;\n      }\n\n      function expandLineIndex(index) {\n        var indices = [];\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n\n        return indices;\n      }\n\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n\n        return new Float32BufferAttribute(array, itemSize);\n      }\n\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n\n        for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n\n        for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (let i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n\n      var ab = new Vector3();\n      var cb = new Vector3();\n\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (let i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n\n        var normals = [];\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          var face = faces[i];\n          var nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n          vA.fromArray(coord, face.a * 3);\n          vB.fromArray(coord, face.b * 3);\n          vC.fromArray(coord, face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n\n        return new Float32BufferAttribute(normals, 3);\n      }\n\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (let i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n\n        return normal.normalize();\n      }\n\n      function toColorArray(colors) {\n        var array = [];\n\n        for (let i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n\n        for (let i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n\n        for (let i = 0; i < indices.count; i++) {\n          var index = indices.getX(i);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA, thresholdIndexB;\n          var t = 1;\n\n          for (let j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  });\n\n  function VRMLLexer(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  VRMLLexer.prototype = {\n    constructor: VRMLLexer,\n    lex: function (inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n\n      return lexingResult;\n    }\n  };\n\n  function VRMLParser(tokenVocabulary) {\n    Parser.call(this, tokenVocabulary); // eslint-disable-line no-undef\n\n    var $ = this;\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n  VRMLParser.prototype = Object.create(Parser.prototype); // eslint-disable-line no-undef\n\n  VRMLParser.prototype.constructor = VRMLParser;\n\n  function Face(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n  var TEXTURE_TYPE = {\n    INTENSITY: 1,\n    INTENSITY_ALPHA: 2,\n    RGB: 3,\n    RGBA: 4\n  };\n  return VRMLLoader;\n}();\n\nexport { VRMLLoader };\n"]},"metadata":{},"sourceType":"module"}