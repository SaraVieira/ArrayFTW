{"ast":null,"code":"import { DataTextureLoader, UnsignedByteType, HalfFloatType, FloatType, DataUtils, RGBFormat, RGBEFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter } from 'three'; // http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function RGBELoader(manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function parse(buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = '\\n',\n        fgets = function fgets(buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (var _j = 0; _j < numElements; _j++) {\n              RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function setDataType(value) {\n    this.type = value;\n    return this;\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { RGBELoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/RGBELoader.js"],"names":["DataTextureLoader","UnsignedByteType","HalfFloatType","FloatType","DataUtils","RGBFormat","RGBEFormat","LinearEncoding","LinearFilter","RGBEEncoding","NearestFilter","RGBELoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","RGBE_RETURN_FAILURE","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","console","error","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","p","pos","i","len","s","chunkSize","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBE_ReadHeader","line","match","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","scanline_width","num_scanlines","rgbeStart","Uint8Array","set","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","toHalfFloat","byteArray","rgbe_header_info","image_rgba_data","data","numElements","floatArray","Float32Array","j","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"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","sourcesContent":["import { DataTextureLoader, UnsignedByteType, HalfFloatType, FloatType, DataUtils, RGBFormat, RGBEFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter } from 'three';\n\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function (buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = '\\n',\n        fgets = function (buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\n\nexport { RGBELoader };\n"]},"metadata":{},"sourceType":"module"}