{"ast":null,"code":"import { TempNode } from './TempNode.js';\nvar declarationRegexp = /^struct\\s*([a-z_0-9]+)\\s*{\\s*((.|\\n)*?)}/gim,\n    propertiesRegexp = /\\s*(\\w*?)\\s*(\\w*?)(\\=|\\;)/gim;\n\nfunction StructNode(src) {\n  TempNode.call(this);\n  this.parse(src);\n}\n\nStructNode.prototype = Object.create(TempNode.prototype);\nStructNode.prototype.constructor = StructNode;\nStructNode.prototype.nodeType = 'Struct';\n\nStructNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.name);\n};\n\nStructNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nStructNode.prototype.generate = function (builder, output) {\n  if (output === 'source') {\n    return this.src + ';';\n  } else {\n    return builder.format('( ' + this.src + ' )', this.getType(builder), output);\n  }\n};\n\nStructNode.prototype.parse = function (src) {\n  this.src = src || '';\n  this.inputs = [];\n  var declaration = declarationRegexp.exec(this.src);\n\n  if (declaration) {\n    var properties = declaration[2],\n        match;\n\n    while (match = propertiesRegexp.exec(properties)) {\n      this.inputs.push({\n        type: match[1],\n        name: match[2]\n      });\n    }\n\n    this.name = declaration[1];\n  } else {\n    this.name = '';\n  }\n\n  this.type = this.name;\n};\n\nStructNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n  }\n\n  return data;\n};\n\nexport { StructNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/core/StructNode.js"],"names":["TempNode","declarationRegexp","propertiesRegexp","StructNode","src","call","parse","prototype","Object","create","constructor","nodeType","getType","builder","getTypeByFormat","name","getInputByName","i","inputs","length","generate","output","format","declaration","exec","properties","match","push","type","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":"AAAA,SAASA,QAAT,QAAyB,eAAzB;AAEA,IAAIC,iBAAiB,GAAG,6CAAxB;AAAA,IACIC,gBAAgB,GAAG,8BADvB;;AAGA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;AACvBJ,EAAAA,QAAQ,CAACK,IAAT,CAAc,IAAd;AACA,OAAKC,KAAL,CAAWF,GAAX;AACD;;AAEDD,UAAU,CAACI,SAAX,GAAuBC,MAAM,CAACC,MAAP,CAAcT,QAAQ,CAACO,SAAvB,CAAvB;AACAJ,UAAU,CAACI,SAAX,CAAqBG,WAArB,GAAmCP,UAAnC;AACAA,UAAU,CAACI,SAAX,CAAqBI,QAArB,GAAgC,QAAhC;;AAEAR,UAAU,CAACI,SAAX,CAAqBK,OAArB,GAA+B,UAAUC,OAAV,EAAmB;AAChD,SAAOA,OAAO,CAACC,eAAR,CAAwB,KAAKC,IAA7B,CAAP;AACD,CAFD;;AAIAZ,UAAU,CAACI,SAAX,CAAqBS,cAArB,GAAsC,UAAUD,IAAV,EAAgB;AACpD,MAAIE,CAAC,GAAG,KAAKC,MAAL,CAAYC,MAApB;;AAEA,SAAOF,CAAC,EAAR,EAAY;AACV,QAAI,KAAKC,MAAL,CAAYD,CAAZ,EAAeF,IAAf,KAAwBA,IAA5B,EAAkC;AAChC,aAAO,KAAKG,MAAL,CAAYD,CAAZ,CAAP;AACD;AACF;AACF,CARD;;AAUAd,UAAU,CAACI,SAAX,CAAqBa,QAArB,GAAgC,UAAUP,OAAV,EAAmBQ,MAAnB,EAA2B;AACzD,MAAIA,MAAM,KAAK,QAAf,EAAyB;AACvB,WAAO,KAAKjB,GAAL,GAAW,GAAlB;AACD,GAFD,MAEO;AACL,WAAOS,OAAO,CAACS,MAAR,CAAe,OAAO,KAAKlB,GAAZ,GAAkB,IAAjC,EAAuC,KAAKQ,OAAL,CAAaC,OAAb,CAAvC,EAA8DQ,MAA9D,CAAP;AACD;AACF,CAND;;AAQAlB,UAAU,CAACI,SAAX,CAAqBD,KAArB,GAA6B,UAAUF,GAAV,EAAe;AAC1C,OAAKA,GAAL,GAAWA,GAAG,IAAI,EAAlB;AACA,OAAKc,MAAL,GAAc,EAAd;AACA,MAAIK,WAAW,GAAGtB,iBAAiB,CAACuB,IAAlB,CAAuB,KAAKpB,GAA5B,CAAlB;;AAEA,MAAImB,WAAJ,EAAiB;AACf,QAAIE,UAAU,GAAGF,WAAW,CAAC,CAAD,CAA5B;AAAA,QACIG,KADJ;;AAGA,WAAOA,KAAK,GAAGxB,gBAAgB,CAACsB,IAAjB,CAAsBC,UAAtB,CAAf,EAAkD;AAChD,WAAKP,MAAL,CAAYS,IAAZ,CAAiB;AACfC,QAAAA,IAAI,EAAEF,KAAK,CAAC,CAAD,CADI;AAEfX,QAAAA,IAAI,EAAEW,KAAK,CAAC,CAAD;AAFI,OAAjB;AAID;;AAED,SAAKX,IAAL,GAAYQ,WAAW,CAAC,CAAD,CAAvB;AACD,GAZD,MAYO;AACL,SAAKR,IAAL,GAAY,EAAZ;AACD;;AAED,OAAKa,IAAL,GAAY,KAAKb,IAAjB;AACD,CAtBD;;AAwBAZ,UAAU,CAACI,SAAX,CAAqBsB,MAArB,GAA8B,UAAUC,IAAV,EAAgB;AAC5C,MAAIC,IAAI,GAAG,KAAKC,WAAL,CAAiBF,IAAjB,CAAX;;AAEA,MAAI,CAACC,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAG,KAAKE,cAAL,CAAoBH,IAApB,CAAP;AACAC,IAAAA,IAAI,CAAC3B,GAAL,GAAW,KAAKA,GAAhB;AACD;;AAED,SAAO2B,IAAP;AACD,CATD;;AAWA,SAAS5B,UAAT","sourcesContent":["import { TempNode } from './TempNode.js';\n\nvar declarationRegexp = /^struct\\s*([a-z_0-9]+)\\s*{\\s*((.|\\n)*?)}/gim,\n    propertiesRegexp = /\\s*(\\w*?)\\s*(\\w*?)(\\=|\\;)/gim;\n\nfunction StructNode(src) {\n  TempNode.call(this);\n  this.parse(src);\n}\n\nStructNode.prototype = Object.create(TempNode.prototype);\nStructNode.prototype.constructor = StructNode;\nStructNode.prototype.nodeType = 'Struct';\n\nStructNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.name);\n};\n\nStructNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nStructNode.prototype.generate = function (builder, output) {\n  if (output === 'source') {\n    return this.src + ';';\n  } else {\n    return builder.format('( ' + this.src + ' )', this.getType(builder), output);\n  }\n};\n\nStructNode.prototype.parse = function (src) {\n  this.src = src || '';\n  this.inputs = [];\n  var declaration = declarationRegexp.exec(this.src);\n\n  if (declaration) {\n    var properties = declaration[2],\n        match;\n\n    while (match = propertiesRegexp.exec(properties)) {\n      this.inputs.push({\n        type: match[1],\n        name: match[2]\n      });\n    }\n\n    this.name = declaration[1];\n  } else {\n    this.name = '';\n  }\n\n  this.type = this.name;\n};\n\nStructNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n  }\n\n  return data;\n};\n\nexport { StructNode };\n"]},"metadata":{},"sourceType":"module"}