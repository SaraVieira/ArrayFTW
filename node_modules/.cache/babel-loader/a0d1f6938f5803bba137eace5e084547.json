{"ast":null,"code":"import { MathUtils } from 'three';\n\nfunction Node(type) {\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = type;\n  this.userData = {};\n}\n\nNode.prototype = {\n  constructor: Node,\n  isNode: true,\n  hashProperties: undefined,\n  analyze: function analyze(builder, settings) {\n    settings = settings || {};\n    builder.analyzing = true;\n    this.build(builder.addFlow(settings.slot, settings.cache, settings.context), 'v4');\n    builder.clearVertexNodeCode();\n    builder.clearFragmentNodeCode();\n    builder.removeFlow();\n    builder.analyzing = false;\n  },\n  analyzeAndFlow: function analyzeAndFlow(builder, output, settings) {\n    settings = settings || {};\n    this.analyze(builder, settings);\n    return this.flow(builder, output, settings);\n  },\n  flow: function flow(builder, output, settings) {\n    settings = settings || {};\n    builder.addFlow(settings.slot, settings.cache, settings.context);\n    var flow = {};\n    flow.result = this.build(builder, output);\n    flow.code = builder.clearNodeCode();\n    flow.extra = builder.context.extra;\n    builder.removeFlow();\n    return flow;\n  },\n  build: function build(builder, output, uuid) {\n    output = output || this.getType(builder, output);\n    var data = builder.getNodeData(uuid || this);\n\n    if (builder.analyzing) {\n      this.appendDepsNode(builder, data, output);\n    }\n\n    if (builder.nodes.indexOf(this) === -1) {\n      builder.nodes.push(this);\n    }\n\n    if (this.updateFrame !== undefined && builder.updaters.indexOf(this) === -1) {\n      builder.updaters.push(this);\n    }\n\n    return this.generate(builder, output, uuid);\n  },\n  generate: function generate()\n  /* builder, output, uuid, type, ns */\n  {// This method needs to be implemented in subclasses\n  },\n  getHash: function getHash() {\n    var hash = '{';\n    var prop, obj;\n\n    for (prop in this) {\n      obj = this[prop];\n\n      if (obj instanceof Node) {\n        hash += '\"' + prop + '\":' + obj.getHash() + ',';\n      }\n    }\n\n    if (this.hashProperties) {\n      for (var i = 0; i < this.hashProperties.length; i++) {\n        prop = this.hashProperties[i];\n        obj = this[prop];\n        hash += '\"' + prop + '\":\"' + String(obj) + '\",';\n      }\n    }\n\n    hash += '\"id\":\"' + this.uuid + '\"}';\n    return hash;\n  },\n  appendDepsNode: function appendDepsNode(builder, data, output) {\n    data.deps = (data.deps || 0) + 1;\n    var outputLen = builder.getTypeLength(output);\n\n    if (outputLen > (data.outputMax || 0) || this.getType(builder, output)) {\n      data.outputMax = outputLen;\n      data.output = output;\n    }\n  },\n  setName: function setName(name) {\n    this.name = name;\n    return this;\n  },\n  getName: function getName()\n  /* builder */\n  {\n    return this.name;\n  },\n  getType: function getType(builder, output) {\n    return output === 'sampler2D' || output === 'samplerCube' ? output : this.type;\n  },\n  getJSONNode: function getJSONNode(meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.nodes[this.uuid] !== undefined) {\n      return meta.nodes[this.uuid];\n    }\n  },\n  copy: function copy(source) {\n    if (source.name !== undefined) this.name = source.name;\n    if (source.userData !== undefined) this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  },\n  createJSONNode: function createJSONNode(meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n    var data = {};\n    if (typeof this.nodeType !== 'string') throw new Error('Node does not allow serialization.');\n    data.uuid = this.uuid;\n    data.nodeType = this.nodeType;\n    if (this.name !== '') data.name = this.name;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n\n    if (!isRootObject) {\n      meta.nodes[this.uuid] = data;\n    }\n\n    return data;\n  },\n  toJSON: function toJSON(meta) {\n    return this.getJSONNode(meta) || this.createJSONNode(meta);\n  }\n};\nexport { Node };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/core/Node.js"],"names":["MathUtils","Node","type","uuid","generateUUID","name","userData","prototype","constructor","isNode","hashProperties","undefined","analyze","builder","settings","analyzing","build","addFlow","slot","cache","context","clearVertexNodeCode","clearFragmentNodeCode","removeFlow","analyzeAndFlow","output","flow","result","code","clearNodeCode","extra","getType","data","getNodeData","appendDepsNode","nodes","indexOf","push","updateFrame","updaters","generate","getHash","hash","prop","obj","i","length","String","deps","outputLen","getTypeLength","outputMax","setName","getName","getJSONNode","meta","isRootObject","copy","source","JSON","parse","stringify","createJSONNode","nodeType","Error","toJSON"],"mappings":"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","sourcesContent":["import { MathUtils } from 'three';\n\nfunction Node(type) {\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = type;\n  this.userData = {};\n}\n\nNode.prototype = {\n  constructor: Node,\n  isNode: true,\n  hashProperties: undefined,\n  analyze: function (builder, settings) {\n    settings = settings || {};\n    builder.analyzing = true;\n    this.build(builder.addFlow(settings.slot, settings.cache, settings.context), 'v4');\n    builder.clearVertexNodeCode();\n    builder.clearFragmentNodeCode();\n    builder.removeFlow();\n    builder.analyzing = false;\n  },\n  analyzeAndFlow: function (builder, output, settings) {\n    settings = settings || {};\n    this.analyze(builder, settings);\n    return this.flow(builder, output, settings);\n  },\n  flow: function (builder, output, settings) {\n    settings = settings || {};\n    builder.addFlow(settings.slot, settings.cache, settings.context);\n    var flow = {};\n    flow.result = this.build(builder, output);\n    flow.code = builder.clearNodeCode();\n    flow.extra = builder.context.extra;\n    builder.removeFlow();\n    return flow;\n  },\n  build: function (builder, output, uuid) {\n    output = output || this.getType(builder, output);\n    var data = builder.getNodeData(uuid || this);\n\n    if (builder.analyzing) {\n      this.appendDepsNode(builder, data, output);\n    }\n\n    if (builder.nodes.indexOf(this) === -1) {\n      builder.nodes.push(this);\n    }\n\n    if (this.updateFrame !== undefined && builder.updaters.indexOf(this) === -1) {\n      builder.updaters.push(this);\n    }\n\n    return this.generate(builder, output, uuid);\n  },\n  generate: function ()\n  /* builder, output, uuid, type, ns */\n  {// This method needs to be implemented in subclasses\n  },\n  getHash: function () {\n    var hash = '{';\n    var prop, obj;\n\n    for (prop in this) {\n      obj = this[prop];\n\n      if (obj instanceof Node) {\n        hash += '\"' + prop + '\":' + obj.getHash() + ',';\n      }\n    }\n\n    if (this.hashProperties) {\n      for (let i = 0; i < this.hashProperties.length; i++) {\n        prop = this.hashProperties[i];\n        obj = this[prop];\n        hash += '\"' + prop + '\":\"' + String(obj) + '\",';\n      }\n    }\n\n    hash += '\"id\":\"' + this.uuid + '\"}';\n    return hash;\n  },\n  appendDepsNode: function (builder, data, output) {\n    data.deps = (data.deps || 0) + 1;\n    var outputLen = builder.getTypeLength(output);\n\n    if (outputLen > (data.outputMax || 0) || this.getType(builder, output)) {\n      data.outputMax = outputLen;\n      data.output = output;\n    }\n  },\n  setName: function (name) {\n    this.name = name;\n    return this;\n  },\n  getName: function ()\n  /* builder */\n  {\n    return this.name;\n  },\n  getType: function (builder, output) {\n    return output === 'sampler2D' || output === 'samplerCube' ? output : this.type;\n  },\n  getJSONNode: function (meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.nodes[this.uuid] !== undefined) {\n      return meta.nodes[this.uuid];\n    }\n  },\n  copy: function (source) {\n    if (source.name !== undefined) this.name = source.name;\n    if (source.userData !== undefined) this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  },\n  createJSONNode: function (meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n    var data = {};\n    if (typeof this.nodeType !== 'string') throw new Error('Node does not allow serialization.');\n    data.uuid = this.uuid;\n    data.nodeType = this.nodeType;\n    if (this.name !== '') data.name = this.name;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n\n    if (!isRootObject) {\n      meta.nodes[this.uuid] = data;\n    }\n\n    return data;\n  },\n  toJSON: function (meta) {\n    return this.getJSONNode(meta) || this.createJSONNode(meta);\n  }\n};\n\nexport { Node };\n"]},"metadata":{},"sourceType":"module"}