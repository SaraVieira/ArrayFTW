{"ast":null,"code":"import { Quaternion, Vector3, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Matrix4, Mesh, Line, BufferGeometry, BufferAttribute } from 'three';\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nvar CCDIKSolver = function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh, iks) {\n    this.mesh = mesh;\n    this.iks = iks || [];\n\n    this._valid();\n  }\n\n  CCDIKSolver.prototype = {\n    constructor: CCDIKSolver,\n\n    /**\n     * Update IK bones.\n     *\n     * @return {CCDIKSolver}\n     */\n    update: function () {\n      var q = new Quaternion();\n      var targetPos = new Vector3();\n      var targetVec = new Vector3();\n      var effectorPos = new Vector3();\n      var effectorVec = new Vector3();\n      var linkPos = new Vector3();\n      var invLinkQ = new Quaternion();\n      var linkScale = new Vector3();\n      var axis = new Vector3();\n      var vector = new Vector3();\n      return function update() {\n        var bones = this.mesh.skeleton.bones;\n        var iks = this.iks; // for reference overhead reduction in loop\n\n        var math = Math;\n\n        for (var i = 0, il = iks.length; i < il; i++) {\n          var ik = iks[i];\n          var effector = bones[ik.effector];\n          var target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n          // because it calls updateMatrixWorld( true ) inside.\n\n          targetPos.setFromMatrixPosition(target.matrixWorld);\n          var links = ik.links;\n          var iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n          for (var j = 0; j < iteration; j++) {\n            var rotated = false;\n\n            for (var k = 0, kl = links.length; k < kl; k++) {\n              var link = bones[links[k].index]; // skip this link and following links.\n              // this skip is used for MMD performance optimization.\n\n              if (links[k].enabled === false) break;\n              var limitation = links[k].limitation;\n              var rotationMin = links[k].rotationMin;\n              var rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n              // because they call updateMatrixWorld( true ) inside.\n\n              link.matrixWorld.decompose(linkPos, invLinkQ, linkScale);\n              invLinkQ.invert();\n              effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n              effectorVec.subVectors(effectorPos, linkPos);\n              effectorVec.applyQuaternion(invLinkQ);\n              effectorVec.normalize();\n              targetVec.subVectors(targetPos, linkPos);\n              targetVec.applyQuaternion(invLinkQ);\n              targetVec.normalize();\n              var angle = targetVec.dot(effectorVec);\n\n              if (angle > 1.0) {\n                angle = 1.0;\n              } else if (angle < -1.0) {\n                angle = -1.0;\n              }\n\n              angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n              // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n              if (angle < 1e-5) continue;\n\n              if (ik.minAngle !== undefined && angle < ik.minAngle) {\n                angle = ik.minAngle;\n              }\n\n              if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n                angle = ik.maxAngle;\n              }\n\n              axis.crossVectors(effectorVec, targetVec);\n              axis.normalize();\n              q.setFromAxisAngle(axis, angle);\n              link.quaternion.multiply(q); // TODO: re-consider the limitation specification\n\n              if (limitation !== undefined) {\n                var c = link.quaternion.w;\n                if (c > 1.0) c = 1.0;\n                var c2 = math.sqrt(1 - c * c);\n                link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n              }\n\n              if (rotationMin !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).max(rotationMin));\n              }\n\n              if (rotationMax !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).min(rotationMax));\n              }\n\n              link.updateMatrixWorld(true);\n              rotated = true;\n            }\n\n            if (!rotated) break;\n          }\n        }\n\n        return this;\n      };\n    }(),\n\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n    createHelper: function createHelper() {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    },\n    // private methods\n    _valid: function _valid() {\n      var iks = this.iks;\n      var bones = this.mesh.skeleton.bones;\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var effector = bones[ik.effector];\n        var links = ik.links;\n        var link0 = void 0,\n            link1 = void 0;\n        link0 = effector;\n\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n\n          if (link0.parent !== link1) {\n            console.warn(\"THREE.CCDIKSolver: bone \".concat(link0.name, \" is not the child of bone \").concat(link1.name));\n          }\n\n          link0 = link1;\n        }\n      }\n    }\n  };\n  /**\n   * Visualize IK bones\n   *\n   * @param {SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n\n  function CCDIKHelper(mesh, iks) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.iks = iks || [];\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    this._init();\n  }\n\n  CCDIKHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: CCDIKHelper,\n\n    /**\n     * Updates IK bones visualization.\n     */\n    updateMatrixWorld: function () {\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n\n      function getPosition(bone, matrixWorldInv) {\n        return vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n      }\n\n      function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n        var v = getPosition(bone, matrixWorldInv);\n        array[index * 3 + 0] = v.x;\n        array[index * 3 + 1] = v.y;\n        array[index * 3 + 2] = v.z;\n      }\n\n      return function updateMatrixWorld(force) {\n        var mesh = this.root;\n\n        if (this.visible) {\n          var offset = 0;\n          var iks = this.iks;\n          var bones = mesh.skeleton.bones;\n          matrix.copy(mesh.matrixWorld).invert();\n\n          for (var i = 0, il = iks.length; i < il; i++) {\n            var ik = iks[i];\n            var targetBone = bones[ik.target];\n            var effectorBone = bones[ik.effector];\n            var targetMesh = this.children[offset++];\n            var effectorMesh = this.children[offset++];\n            targetMesh.position.copy(getPosition(targetBone, matrix));\n            effectorMesh.position.copy(getPosition(effectorBone, matrix));\n\n            for (var j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              var linkMesh = this.children[offset++];\n              linkMesh.position.copy(getPosition(linkBone, matrix));\n            }\n\n            var line = this.children[offset++];\n            var array = line.geometry.attributes.position.array;\n            setPositionOfBoneToAttributeArray(array, 0, targetBone, matrix);\n            setPositionOfBoneToAttributeArray(array, 1, effectorBone, matrix);\n\n            for (var _j = 0, _jl = ik.links.length; _j < _jl; _j++) {\n              var link = ik.links[_j];\n              var linkBone = bones[link.index];\n              setPositionOfBoneToAttributeArray(array, _j + 2, linkBone, matrix);\n            }\n\n            line.geometry.attributes.position.needsUpdate = true;\n          }\n        }\n\n        this.matrix.copy(mesh.matrixWorld);\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    }(),\n    // private method\n    _init: function _init() {\n      var scope = this;\n      var iks = this.iks;\n\n      function createLineGeometry(ik) {\n        var geometry = new BufferGeometry();\n        var vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n\n        for (var j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n\n        this.add(createLine(ik));\n      }\n    }\n  });\n  return CCDIKSolver;\n}();\n\nexport { CCDIKSolver };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/animation/CCDIKSolver.js"],"names":["Quaternion","Vector3","Object3D","SphereGeometry","MeshBasicMaterial","Color","LineBasicMaterial","Matrix4","Mesh","Line","BufferGeometry","BufferAttribute","CCDIKSolver","mesh","iks","_valid","prototype","constructor","update","q","targetPos","targetVec","effectorPos","effectorVec","linkPos","invLinkQ","linkScale","axis","vector","bones","skeleton","math","Math","i","il","length","ik","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","undefined","j","rotated","k","kl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","toVector3","max","min","updateMatrixWorld","createHelper","CCDIKHelper","geometry","userData","MMD","link0","link1","jl","parent","console","warn","name","call","root","matrix","copy","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","_init","Object","assign","create","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","attributes","needsUpdate","scope","createLineGeometry","vertices","Float32Array","setAttribute","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","add"],"mappings":"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","sourcesContent":["import { Quaternion, Vector3, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Matrix4, Mesh, Line, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nconst CCDIKSolver = (() => {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh, iks) {\n    this.mesh = mesh;\n    this.iks = iks || [];\n\n    this._valid();\n  }\n\n  CCDIKSolver.prototype = {\n    constructor: CCDIKSolver,\n\n    /**\n     * Update IK bones.\n     *\n     * @return {CCDIKSolver}\n     */\n    update: (() => {\n      const q = new Quaternion();\n      const targetPos = new Vector3();\n      const targetVec = new Vector3();\n      const effectorPos = new Vector3();\n      const effectorVec = new Vector3();\n      const linkPos = new Vector3();\n      const invLinkQ = new Quaternion();\n      const linkScale = new Vector3();\n      const axis = new Vector3();\n      const vector = new Vector3();\n      return function update() {\n        const bones = this.mesh.skeleton.bones;\n        const iks = this.iks; // for reference overhead reduction in loop\n\n        const math = Math;\n\n        for (let i = 0, il = iks.length; i < il; i++) {\n          const ik = iks[i];\n          const effector = bones[ik.effector];\n          const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n          // because it calls updateMatrixWorld( true ) inside.\n\n          targetPos.setFromMatrixPosition(target.matrixWorld);\n          const links = ik.links;\n          const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n          for (let j = 0; j < iteration; j++) {\n            let rotated = false;\n\n            for (let k = 0, kl = links.length; k < kl; k++) {\n              const link = bones[links[k].index]; // skip this link and following links.\n              // this skip is used for MMD performance optimization.\n\n              if (links[k].enabled === false) break;\n              const limitation = links[k].limitation;\n              const rotationMin = links[k].rotationMin;\n              const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n              // because they call updateMatrixWorld( true ) inside.\n\n              link.matrixWorld.decompose(linkPos, invLinkQ, linkScale);\n              invLinkQ.invert();\n              effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n              effectorVec.subVectors(effectorPos, linkPos);\n              effectorVec.applyQuaternion(invLinkQ);\n              effectorVec.normalize();\n              targetVec.subVectors(targetPos, linkPos);\n              targetVec.applyQuaternion(invLinkQ);\n              targetVec.normalize();\n              let angle = targetVec.dot(effectorVec);\n\n              if (angle > 1.0) {\n                angle = 1.0;\n              } else if (angle < -1.0) {\n                angle = -1.0;\n              }\n\n              angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n              // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n              if (angle < 1e-5) continue;\n\n              if (ik.minAngle !== undefined && angle < ik.minAngle) {\n                angle = ik.minAngle;\n              }\n\n              if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n                angle = ik.maxAngle;\n              }\n\n              axis.crossVectors(effectorVec, targetVec);\n              axis.normalize();\n              q.setFromAxisAngle(axis, angle);\n              link.quaternion.multiply(q); // TODO: re-consider the limitation specification\n\n              if (limitation !== undefined) {\n                let c = link.quaternion.w;\n                if (c > 1.0) c = 1.0;\n                const c2 = math.sqrt(1 - c * c);\n                link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n              }\n\n              if (rotationMin !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).max(rotationMin));\n              }\n\n              if (rotationMax !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).min(rotationMax));\n              }\n\n              link.updateMatrixWorld(true);\n              rotated = true;\n            }\n\n            if (!rotated) break;\n          }\n        }\n\n        return this;\n      };\n    })(),\n\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n    createHelper: function () {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    },\n    // private methods\n    _valid: function () {\n      const iks = this.iks;\n      const bones = this.mesh.skeleton.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const effector = bones[ik.effector];\n        const links = ik.links;\n        let link0, link1;\n        link0 = effector;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n\n          if (link0.parent !== link1) {\n            console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n          }\n\n          link0 = link1;\n        }\n      }\n    }\n  };\n  /**\n   * Visualize IK bones\n   *\n   * @param {SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n\n  function CCDIKHelper(mesh, iks) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.iks = iks || [];\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    this._init();\n  }\n\n  CCDIKHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: CCDIKHelper,\n\n    /**\n     * Updates IK bones visualization.\n     */\n    updateMatrixWorld: (() => {\n      const matrix = new Matrix4();\n      const vector = new Vector3();\n\n      function getPosition(bone, matrixWorldInv) {\n        return vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n      }\n\n      function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n        const v = getPosition(bone, matrixWorldInv);\n        array[index * 3 + 0] = v.x;\n        array[index * 3 + 1] = v.y;\n        array[index * 3 + 2] = v.z;\n      }\n\n      return function updateMatrixWorld(force) {\n        const mesh = this.root;\n\n        if (this.visible) {\n          let offset = 0;\n          const iks = this.iks;\n          const bones = mesh.skeleton.bones;\n          matrix.copy(mesh.matrixWorld).invert();\n\n          for (let i = 0, il = iks.length; i < il; i++) {\n            const ik = iks[i];\n            const targetBone = bones[ik.target];\n            const effectorBone = bones[ik.effector];\n            const targetMesh = this.children[offset++];\n            const effectorMesh = this.children[offset++];\n            targetMesh.position.copy(getPosition(targetBone, matrix));\n            effectorMesh.position.copy(getPosition(effectorBone, matrix));\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              const linkMesh = this.children[offset++];\n              linkMesh.position.copy(getPosition(linkBone, matrix));\n            }\n\n            const line = this.children[offset++];\n            const array = line.geometry.attributes.position.array;\n            setPositionOfBoneToAttributeArray(array, 0, targetBone, matrix);\n            setPositionOfBoneToAttributeArray(array, 1, effectorBone, matrix);\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              setPositionOfBoneToAttributeArray(array, j + 2, linkBone, matrix);\n            }\n\n            line.geometry.attributes.position.needsUpdate = true;\n          }\n        }\n\n        this.matrix.copy(mesh.matrixWorld);\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    })(),\n    // private method\n    _init: function () {\n      const scope = this;\n      const iks = this.iks;\n\n      function createLineGeometry(ik) {\n        const geometry = new BufferGeometry();\n        const vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n\n        this.add(createLine(ik));\n      }\n    }\n  });\n  return CCDIKSolver;\n})();\n\nexport { CCDIKSolver };\n"]},"metadata":{},"sourceType":"module"}