{"ast":null,"code":"import _toConsumableArray from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar updateQueue = makeQueue();\n\nvar raf = function raf(fn) {\n  return schedule(fn, updateQueue);\n};\n\nvar writeQueue = makeQueue();\n\nraf.write = function (fn) {\n  return schedule(fn, writeQueue);\n};\n\nvar onStartQueue = makeQueue();\n\nraf.onStart = function (fn) {\n  return schedule(fn, onStartQueue);\n};\n\nvar onFrameQueue = makeQueue();\n\nraf.onFrame = function (fn) {\n  return schedule(fn, onFrameQueue);\n};\n\nvar onFinishQueue = makeQueue();\n\nraf.onFinish = function (fn) {\n  return schedule(fn, onFinishQueue);\n};\n\nvar timeouts = [];\n\nraf.setTimeout = function (handler, ms) {\n  var time = raf.now() + ms;\n\n  var cancel = function cancel() {\n    var i = timeouts.findIndex(function (t) {\n      return t.cancel == cancel;\n    });\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  var timeout = {\n    time: time,\n    handler: handler,\n    cancel: cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nvar findTimeout = function findTimeout(time) {\n  return ~(~timeouts.findIndex(function (t) {\n    return t.time > time;\n  }) || ~timeouts.length);\n};\n\nraf.cancel = function (fn) {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = function (fn) {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = function (fn) {\n  var lastArgs;\n\n  function queuedFn() {\n    try {\n      fn.apply(void 0, _toConsumableArray(lastArgs));\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = function () {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nvar nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : function () {};\n\nraf.use = function (impl) {\n  return nativeRaf = impl;\n};\n\nraf.now = typeof performance != \"undefined\" ? function () {\n  return performance.now();\n} : Date.now;\n\nraf.batchedUpdates = function (fn) {\n  return fn();\n};\n\nraf.catch = console.error;\nvar ts = -1;\nvar sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  var prevTs = ts;\n  ts = raf.now();\n  var count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), function (t) {\n      return t.handler();\n    });\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  var next = new Set();\n  var current = next;\n  return {\n    add: function add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete: function _delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush: function flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, function (fn) {\n          return fn(arg) && next.add(fn);\n        });\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(function (value) {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nvar __raf = {\n  count: 0,\n  clear: function clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\nexport { __raf, raf };","map":{"version":3,"sources":["../src/raf.ts"],"names":[],"mappings":"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","sourcesContent":["let updateQueue = makeQueue();\nconst raf = (fn) => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\nraf.write = (fn) => schedule(fn, writeQueue);\nlet onStartQueue = makeQueue();\nraf.onStart = (fn) => schedule(fn, onStartQueue);\nlet onFrameQueue = makeQueue();\nraf.onFrame = (fn) => schedule(fn, onFrameQueue);\nlet onFinishQueue = makeQueue();\nraf.onFinish = (fn) => schedule(fn, onFinishQueue);\nlet timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n  let cancel = () => {\n    let i = timeouts.findIndex((t) => t.cancel == cancel);\n    if (~i)\n      timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n  let timeout = {time, handler, cancel};\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\nlet findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);\nraf.cancel = (fn) => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = (fn) => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = (fn) => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {\n};\nraf.use = (impl) => nativeRaf = impl;\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\nraf.batchedUpdates = (fn) => fn();\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), (t) => t.handler());\n    __raf.count -= count;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, (fn) => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach((value) => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nconst __raf = {\n  count: 0,\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\n\nexport { __raf, raf };\n//# sourceMappingURL=raf.mjs.map\n"]},"metadata":{},"sourceType":"module"}