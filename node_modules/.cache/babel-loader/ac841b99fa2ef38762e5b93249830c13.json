{"ast":null,"code":"import { Vector3, Color, SphericalHarmonics3, LightProbe, LinearEncoding, sRGBEncoding } from 'three';\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function fromCubeTexture(cubeTexture) {\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n\n      for (var i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n\n          case 1:\n            coord.set(1, row, col);\n            break;\n\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (var j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (var _j = 0; _j < 9; _j++) {\n      shCoefficients[_j].x *= norm;\n      shCoefficients[_j].y *= norm;\n      shCoefficients[_j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  },\n  fromCubeRenderTarget: function fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n\n      for (var i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n\n          case 1:\n            coord.set(-1, row, col);\n            break;\n\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(col, -1, row);\n            break;\n\n          case 4:\n            coord.set(col, row, 1);\n            break;\n\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (var j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (var _j2 = 0; _j2 < 9; _j2++) {\n      shCoefficients[_j2].x *= norm;\n      shCoefficients[_j2].y *= norm;\n      shCoefficients[_j2].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  }\n};\n\nvar convertColorToLinear = function convertColorToLinear(color, encoding) {\n  switch (encoding) {\n    case sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n\n    case LinearEncoding:\n      break;\n\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n\n  return color;\n};\n\nexport { LightProbeGenerator };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/lights/LightProbeGenerator.js"],"names":["Vector3","Color","SphericalHarmonics3","LightProbe","LinearEncoding","sRGBEncoding","LightProbeGenerator","fromCubeTexture","cubeTexture","norm","lengthSq","weight","totalWeight","coord","dir","color","shBasis","sh","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","convertColorToLinear","encoding","pixelIndex","col","row","Math","floor","set","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","PI","fromCubeRenderTarget","renderer","cubeRenderTarget","Uint8Array","readRenderTargetPixels","texture","convertSRGBToLinear","console","warn"],"mappings":"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","sourcesContent":["import { Vector3, Color, SphericalHarmonics3, LightProbe, LinearEncoding, sRGBEncoding } from 'three';\n\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function (cubeTexture) {\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n\n          case 1:\n            coord.set(1, row, col);\n            break;\n\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  },\n  fromCubeRenderTarget: function (renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new Vector3();\n    var dir = new Vector3();\n    var color = new Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n\n          case 1:\n            coord.set(-1, row, col);\n            break;\n\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(col, -1, row);\n            break;\n\n          case 4:\n            coord.set(col, row, 1);\n            break;\n\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n\n    return new LightProbe(sh);\n  }\n};\n\nvar convertColorToLinear = function (color, encoding) {\n  switch (encoding) {\n    case sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n\n    case LinearEncoding:\n      break;\n\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n\n  return color;\n};\n\nexport { LightProbeGenerator };\n"]},"metadata":{},"sourceType":"module"}