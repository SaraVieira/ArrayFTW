{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\n\nvar PCDLoader = function PCDLoader(manager) {\n  Loader.call(this, manager);\n  this.littleEndian = true;\n};\n\nPCDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PCDLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    function decompressLZF(inData, outLength) {\n      var inLength = inData.length;\n      var outData = new Uint8Array(outLength);\n      var inPtr = 0;\n      var outPtr = 0;\n      var ctrl;\n      var len;\n      var ref;\n\n      do {\n        ctrl = inData[inPtr++];\n\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n\n      return outData;\n    }\n\n    function parseHeader(data) {\n      var PCDheader = {};\n      var result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n\n        for (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n\n      PCDheader.offset = {};\n      var sizeSum = 0;\n\n      for (var _i = 0, _l = PCDheader.fields.length; _i < _l; _i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[_i]] = _i;\n        } else {\n          PCDheader.offset[PCDheader.fields[_i]] = sizeSum;\n          sizeSum += PCDheader.size[_i] * PCDheader.count[_i];\n        }\n      } // for binary only\n\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n\n    var textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n    var PCDheader = parseHeader(textData); // parse data\n\n    var position = [];\n    var normal = [];\n    var color = []; // ascii\n\n    if (PCDheader.data === 'ascii') {\n      var offset = PCDheader.offset;\n      var pcdData = textData.substr(PCDheader.headerLen);\n      var lines = pcdData.split('\\n');\n\n      for (var i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        var line = lines[i].split(' ');\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n\n        if (offset.rgb !== undefined) {\n          var rgb = parseFloat(line[offset.rgb]);\n          var r = rgb >> 16 & 0x0000ff;\n          var g = rgb >> 8 & 0x0000ff;\n          var b = rgb >> 0 & 0x0000ff;\n          color.push(r / 255, g / 255, b / 255);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    } // binary-compressed\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n\n    if (PCDheader.data === 'binary_compressed') {\n      var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      var compressedSize = sizes[0];\n      var decompressedSize = sizes[1];\n      var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      var dataview = new DataView(decompressed.buffer);\n      var offset = PCDheader.offset;\n\n      for (var _i2 = 0; _i2 < PCDheader.points; _i2++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * _i2, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * _i2, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * _i2, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * _i2 + 0) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * _i2 + 1) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * _i2 + 2) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * _i2, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * _i2, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * _i2, this.littleEndian));\n        }\n      }\n    } // binary\n\n\n    if (PCDheader.data === 'binary') {\n      var dataview = new DataView(data, PCDheader.headerLen);\n      var offset = PCDheader.offset;\n\n      for (var _i3 = 0, row = 0; _i3 < PCDheader.points; _i3++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    } // build geometry\n\n\n    var geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere(); // build material\n\n    var material = new PointsMaterial({\n      size: 0.005\n    });\n\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 0xffffff);\n    } // build point cloud\n\n\n    var mesh = new Points(geometry, material);\n    var name = url.split('').reverse().join('');\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split('').reverse().join('');\n    mesh.name = name;\n    return mesh;\n  }\n});\nexport { PCDLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/PCDLoader.js"],"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PointsMaterial","Points","PCDLoader","manager","call","littleEndian","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","PCDheader","result1","search","result2","exec","substr","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","decodeText","position","normal","color","pcdData","lines","line","undefined","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors","setHex","Math","random","mesh","name","reverse","join"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\n\nvar PCDLoader = function (manager) {\n  Loader.call(this, manager);\n  this.littleEndian = true;\n};\n\nPCDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PCDLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    function decompressLZF(inData, outLength) {\n      var inLength = inData.length;\n      var outData = new Uint8Array(outLength);\n      var inPtr = 0;\n      var outPtr = 0;\n      var ctrl;\n      var len;\n      var ref;\n\n      do {\n        ctrl = inData[inPtr++];\n\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n\n      return outData;\n    }\n\n    function parseHeader(data) {\n      var PCDheader = {};\n      var result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n\n      PCDheader.offset = {};\n      var sizeSum = 0;\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      } // for binary only\n\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n\n    var textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n    var PCDheader = parseHeader(textData); // parse data\n\n    var position = [];\n    var normal = [];\n    var color = []; // ascii\n\n    if (PCDheader.data === 'ascii') {\n      var offset = PCDheader.offset;\n      var pcdData = textData.substr(PCDheader.headerLen);\n      var lines = pcdData.split('\\n');\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        var line = lines[i].split(' ');\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n\n        if (offset.rgb !== undefined) {\n          var rgb = parseFloat(line[offset.rgb]);\n          var r = rgb >> 16 & 0x0000ff;\n          var g = rgb >> 8 & 0x0000ff;\n          var b = rgb >> 0 & 0x0000ff;\n          color.push(r / 255, g / 255, b / 255);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    } // binary-compressed\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n\n    if (PCDheader.data === 'binary_compressed') {\n      var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      var compressedSize = sizes[0];\n      var decompressedSize = sizes[1];\n      var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      var dataview = new DataView(decompressed.buffer);\n      var offset = PCDheader.offset;\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));\n        }\n      }\n    } // binary\n\n\n    if (PCDheader.data === 'binary') {\n      var dataview = new DataView(data, PCDheader.headerLen);\n      var offset = PCDheader.offset;\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    } // build geometry\n\n\n    var geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere(); // build material\n\n    var material = new PointsMaterial({\n      size: 0.005\n    });\n\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 0xffffff);\n    } // build point cloud\n\n\n    var mesh = new Points(geometry, material);\n    var name = url.split('').reverse().join('');\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split('').reverse().join('');\n    mesh.name = name;\n    return mesh;\n  }\n});\n\nexport { PCDLoader };\n"]},"metadata":{},"sourceType":"module"}