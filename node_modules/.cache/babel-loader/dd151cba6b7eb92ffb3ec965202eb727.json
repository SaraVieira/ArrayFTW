{"ast":null,"code":"import { Loader, Texture, FileLoader } from 'three';\n\nvar TGALoader = function TGALoader(manager) {\n  Loader.call(this, manager);\n};\n\nTGALoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: TGALoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new Texture();\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      texture.image = scope.parse(buffer);\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  },\n  parse: function parse(buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n\n          break;\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n\n          break;\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.');\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n      } // check image width and height\n\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.');\n      } // check image pixel size\n\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n      }\n    } // parse tga image buffer\n\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      var pixel_data, pixel_size, pixel_total, palettes;\n      pixel_size = header.pixel_size >> 3;\n      pixel_total = header.width * header.height * pixel_size; // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      } // read RLE\n\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        var c, count, i;\n        var shift = 0;\n        var pixels = new Uint8Array(pixel_size);\n\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1; // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            } // copy pixel array\n\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n            count *= pixel_size;\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      var colormap = palettes;\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n\n      return imageData;\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      var x_start, y_start, x_step, y_step, x_end, y_end;\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } // Load image data according to specific method\n      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n      return data;\n    } // TGA constants\n\n\n    var TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n        TGA_ORIGIN_MASK = 0x30,\n        TGA_ORIGIN_SHIFT = 0x04,\n        TGA_ORIGIN_BL = 0x00,\n        TGA_ORIGIN_BR = 0x01,\n        TGA_ORIGIN_UL = 0x02,\n        TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n    var content = new Uint8Array(buffer),\n        offset = 0,\n        header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    }; // check tga if it is valid format\n\n    tgaCheckHeader(header);\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.');\n    } // skip the needn't data\n\n\n    offset += header.id_length; // get targa information about RLE compression and palette\n\n    var use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n\n      case TGA_TYPE_RGB:\n        break;\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    } //\n\n\n    var useOffscreen = typeof OffscreenCanvas !== 'undefined';\n    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');\n    canvas.width = header.width;\n    canvas.height = header.height;\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(header.width, header.height);\n    var result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n});\nexport { TGALoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/TGALoader.js"],"names":["Loader","Texture","FileLoader","TGALoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","texture","loader","setResponseType","setPath","path","setWithCredentials","withCredentials","buffer","image","parse","needsUpdate","undefined","tgaCheckHeader","header","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle","use_pal","offset","data","pixel_data","pixel_total","palettes","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData","y_start","y_step","y_end","x_start","x_step","x_end","colormap","color","x","y","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","content","id_length","colormap_index","origin","useOffscreen","OffscreenCanvas","canvas","document","createElement","context","getContext","createImageData","result","putImageData"],"mappings":"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","sourcesContent":["import { Loader, Texture, FileLoader } from 'three';\n\nvar TGALoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nTGALoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: TGALoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new Texture();\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      texture.image = scope.parse(buffer);\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  },\n  parse: function (buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n\n          break;\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n\n          break;\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.');\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n      } // check image width and height\n\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.');\n      } // check image pixel size\n\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n      }\n    } // parse tga image buffer\n\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      var pixel_data, pixel_size, pixel_total, palettes;\n      pixel_size = header.pixel_size >> 3;\n      pixel_total = header.width * header.height * pixel_size; // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      } // read RLE\n\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        var c, count, i;\n        var shift = 0;\n        var pixels = new Uint8Array(pixel_size);\n\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1; // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            } // copy pixel array\n\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n            count *= pixel_size;\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      var colormap = palettes;\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n\n      return imageData;\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      var x_start, y_start, x_step, y_step, x_end, y_end;\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } // Load image data according to specific method\n      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n      return data;\n    } // TGA constants\n\n\n    var TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n        TGA_ORIGIN_MASK = 0x30,\n        TGA_ORIGIN_SHIFT = 0x04,\n        TGA_ORIGIN_BL = 0x00,\n        TGA_ORIGIN_BR = 0x01,\n        TGA_ORIGIN_UL = 0x02,\n        TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n    var content = new Uint8Array(buffer),\n        offset = 0,\n        header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    }; // check tga if it is valid format\n\n    tgaCheckHeader(header);\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.');\n    } // skip the needn't data\n\n\n    offset += header.id_length; // get targa information about RLE compression and palette\n\n    var use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n\n      case TGA_TYPE_RGB:\n        break;\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    } //\n\n\n    var useOffscreen = typeof OffscreenCanvas !== 'undefined';\n    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');\n    canvas.width = header.width;\n    canvas.height = header.height;\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(header.width, header.height);\n    var result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n});\n\nexport { TGALoader };\n"]},"metadata":{},"sourceType":"module"}