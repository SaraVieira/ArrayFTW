{"ast":null,"code":"import { Vector2, Matrix4 } from 'three';\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nvar SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nvar SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nvar SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/SSAOShader.js"],"names":["Vector2","Matrix4","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","cameraProjectionMatrix","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"mappings":"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","sourcesContent":["import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nvar SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nvar SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nvar SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\n\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };\n"]},"metadata":{},"sourceType":"module"}