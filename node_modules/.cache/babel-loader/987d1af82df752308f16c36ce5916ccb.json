{"ast":null,"code":"import { MeshBasicMaterial, Matrix4, Color, DoubleSide } from 'three';\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  var exporter = new ColladaExporter();\n *\n *  var data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nvar ColladaExporter = function ColladaExporter() {};\n\nColladaExporter.prototype = {\n  constructor: ColladaExporter,\n  parse: function parse(object, onDone, options) {\n    options = options || {};\n    options = Object.assign({\n      version: '1.4.1',\n      author: null,\n      textureDirectory: ''\n    }, options);\n\n    if (options.textureDirectory !== '') {\n      options.textureDirectory = \"\".concat(options.textureDirectory, \"/\").replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    var version = options.version;\n\n    if (version !== '1.4.1' && version !== '1.5.0') {\n      console.warn(\"ColladaExporter : Version \".concat(version, \" not supported for export. Only 1.4.1 and 1.5.0.\"));\n      return null;\n    } // Convert the urdf xml into a well-formatted, indented format\n\n\n    function format(urdf) {\n      var IS_END_TAG = /^<\\//;\n      var IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      var HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n      var pad = function pad(ch, num) {\n        return num > 0 ? ch + pad(ch, num - 1) : '';\n      };\n\n      var tagnum = 0;\n      return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(function (tag) {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n\n        var res = \"\".concat(pad('  ', tagnum)).concat(tag);\n\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n\n        return res;\n      }).join('\\n');\n    } // Convert an image into a png format for saving\n\n\n    function base64ToBuffer(str) {\n      var b = atob(str);\n      var buf = new Uint8Array(b.length);\n\n      for (var i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n\n      return buf;\n    }\n\n    var canvas, ctx;\n\n    function imageToData(image, ext) {\n      canvas = canvas || document.createElement('canvas');\n      ctx = ctx || canvas.getContext('2d');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n      var base64data = canvas.toDataURL(\"image/\".concat(ext), 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n      return base64ToBuffer(base64data);\n    } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n    var getFuncs = ['getX', 'getY', 'getZ', 'getW'];\n\n    function attrBufferToArray(attr) {\n      if (attr.isInterleavedBufferAttribute) {\n        // use the typed array constructor to save on memory\n        var arr = new attr.array.constructor(attr.count * attr.itemSize);\n        var size = attr.itemSize;\n\n        for (var i = 0, l = attr.count; i < l; i++) {\n          for (var j = 0; j < size; j++) {\n            arr[i * size + j] = attr[getFuncs[j]](i);\n          }\n        }\n\n        return arr;\n      } else {\n        return attr.array;\n      }\n    } // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n\n\n    function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) return arr.slice(st, st + ct);else return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    } // Returns the string for a geometry's attribute\n\n\n    function getAttribute(attr, name, params, type) {\n      var array = attrBufferToArray(attr);\n      var res = \"\".concat(\"<source id=\\\"\".concat(name, \"\\\">\") + \"<float_array id=\\\"\".concat(name, \"-array\\\" count=\\\"\").concat(array.length, \"\\\">\") + array.join(' '), \"</float_array><technique_common>\", \"<accessor source=\\\"#\".concat(name, \"-array\\\" count=\\\"\").concat(Math.floor(array.length / attr.itemSize), \"\\\" stride=\\\"\").concat(attr.itemSize, \"\\\">\")).concat(params.map(function (n) {\n        return \"<param name=\\\"\".concat(n, \"\\\" type=\\\"\").concat(type, \"\\\" />\");\n      }).join(''), \"</accessor></technique_common></source>\");\n      return res;\n    } // Returns the string for a node's transform information\n\n\n    var transMat;\n\n    function getTransform(o) {\n      // ensure the object's matrix is up to date\n      // before saving the transform\n      o.updateMatrix();\n      transMat = transMat || new Matrix4();\n      transMat.copy(o.matrix);\n      transMat.transpose();\n      return \"<matrix>\".concat(transMat.toArray().join(' '), \"</matrix>\");\n    } // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n\n\n    function processGeometry(g) {\n      var info = geometryInfo.get(g);\n\n      if (!info) {\n        // convert the geometry to bufferGeometry if it isn't already\n        var bufferGeometry = g;\n\n        if (bufferGeometry.isBufferGeometry !== true) {\n          throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        var meshid = \"Mesh\".concat(libraryGeometries.length + 1);\n        var indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        var groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        var gname = g.name ? \" name=\\\"\".concat(g.name, \"\\\"\") : '';\n        var gnode = \"<geometry id=\\\"\".concat(meshid, \"\\\"\").concat(gname, \"><mesh>\"); // define the geometry node and the vertices for the geometry\n\n        var posName = \"\".concat(meshid, \"-position\");\n        var vertName = \"\".concat(meshid, \"-vertices\");\n        gnode += getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n        gnode += \"<vertices id=\\\"\".concat(vertName, \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\").concat(posName, \"\\\" /></vertices>\"); // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n        // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n        // models with attributes that share an offset.\n        // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n        // serialize normals\n\n        var triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\".concat(vertName, \"\\\" offset=\\\"0\\\" />\");\n\n        if ('normal' in bufferGeometry.attributes) {\n          var normName = \"\".concat(meshid, \"-normal\");\n          gnode += getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n          triangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\".concat(normName, \"\\\" offset=\\\"0\\\" />\");\n        } // serialize uvs\n\n\n        if ('uv' in bufferGeometry.attributes) {\n          var uvName = \"\".concat(meshid, \"-texcoord\");\n          gnode += getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\");\n        } // serialize lightmap uvs\n\n\n        if ('uv2' in bufferGeometry.attributes) {\n          var uvName = \"\".concat(meshid, \"-texcoord2\");\n          gnode += getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"1\\\" />\");\n        } // serialize colors\n\n\n        if ('color' in bufferGeometry.attributes) {\n          var colName = \"\".concat(meshid, \"-color\");\n          gnode += getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n          triangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\".concat(colName, \"\\\" offset=\\\"0\\\" />\");\n        }\n\n        var indexArray = null;\n\n        if (bufferGeometry.index) {\n          indexArray = attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n\n          for (var i = 0, l = indexArray.length; i < l; i++) {\n            indexArray[i] = i;\n          }\n        }\n\n        for (var _i = 0, _l = groups.length; _i < _l; _i++) {\n          var group = groups[_i];\n          var subarr = subArray(indexArray, group.start, group.count);\n          var polycount = subarr.length / 3;\n          gnode += \"<triangles material=\\\"MESH_MATERIAL_\".concat(group.materialIndex, \"\\\" count=\\\"\").concat(polycount, \"\\\">\");\n          gnode += triangleInputs;\n          gnode += \"<p>\".concat(subarr.join(' '), \"</p>\");\n          gnode += '</triangles>';\n        }\n\n        gnode += '</mesh></geometry>';\n        libraryGeometries.push(gnode);\n        info = {\n          meshid: meshid,\n          bufferGeometry: bufferGeometry\n        };\n        geometryInfo.set(g, info);\n      }\n\n      return info;\n    } // Process the given texture into the image library\n    // Returns the image library\n\n\n    function processTexture(tex) {\n      var texid = imageMap.get(tex);\n\n      if (texid == null) {\n        texid = \"image-\".concat(libraryImages.length + 1);\n        var ext = 'png';\n        var name = tex.name || texid;\n        var imageNode = \"<image id=\\\"\".concat(texid, \"\\\" name=\\\"\").concat(name, \"\\\">\");\n\n        if (version === '1.5.0') {\n          imageNode += \"<init_from><ref>\".concat(options.textureDirectory).concat(name, \".\").concat(ext, \"</ref></init_from>\");\n        } else {\n          // version image node 1.4.1\n          imageNode += \"<init_from>\".concat(options.textureDirectory).concat(name, \".\").concat(ext, \"</init_from>\");\n        }\n\n        imageNode += '</image>';\n        libraryImages.push(imageNode);\n        imageMap.set(tex, texid);\n        textures.push({\n          directory: options.textureDirectory,\n          name: name,\n          ext: ext,\n          data: imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n\n      return texid;\n    } // Process the given material into the material and effect libraries\n    // Returns the material id\n\n\n    function processMaterial(m) {\n      var matid = materialMap.get(m);\n\n      if (matid == null) {\n        matid = \"Mat\".concat(libraryEffects.length + 1);\n        var type = 'phong';\n\n        if (m.isMeshLambertMaterial === true) {\n          type = 'lambert';\n        } else if (m.isMeshBasicMaterial === true) {\n          type = 'constant';\n\n          if (m.map !== null) {\n            // The Collada spec does not support diffuse texture maps with the\n            // constant shader type.\n            // mrdoob/three.js#15469\n            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n          }\n        }\n\n        var emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        var diffuse = m.color ? m.color : new Color(0, 0, 0);\n        var specular = m.specular ? m.specular : new Color(1, 1, 1);\n        var shininess = m.shininess || 0;\n        var reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        var transparencyNode = '';\n\n        if (m.transparent === true) {\n          transparencyNode += \"<transparent>\".concat(m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>', \"</transparent>\");\n\n          if (m.opacity < 1) {\n            transparencyNode += \"<transparency><float>\".concat(m.opacity, \"</float></transparency>\");\n          }\n        }\n\n        var techniqueNode = \"\".concat(\"<technique sid=\\\"common\\\"><\".concat(type, \">\"), \"<emission>\", m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"emission\\\">\".concat(emissive.r, \" \").concat(emissive.g, \" \").concat(emissive.b, \" 1</color>\"), \"</emission>\").concat(type !== 'constant' ? \"<diffuse>\".concat(m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"diffuse\\\">\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color>\"), \"</diffuse>\") : '').concat(type !== 'constant' ? \"<bump>\".concat(m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : '', \"</bump>\") : '').concat(type === 'phong' ? \"\".concat(\"<specular><color sid=\\\"specular\\\">\".concat(specular.r, \" \").concat(specular.g, \" \").concat(specular.b, \" 1</color></specular>\"), \"<shininess>\", m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : \"<float sid=\\\"shininess\\\">\".concat(shininess, \"</float>\"), \"</shininess>\") : '', \"<reflective><color>\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color></reflective>\"), \"<reflectivity><float>\".concat(reflectivity, \"</float></reflectivity>\")).concat(transparencyNode, \"</\".concat(type, \"></technique>\"));\n        var effectnode = \"\".concat(\"<effect id=\\\"\".concat(matid, \"-effect\\\">\"), \"<profile_COMMON>\", m.map ? \"<newparam sid=\\\"diffuse-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(processTexture(m.map), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"diffuse-sampler\\\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>\") : '').concat(m.specularMap ? \"<newparam sid=\\\"specular-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(processTexture(m.specularMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"specular-sampler\\\"><sampler2D><source>specular-surface</source></sampler2D></newparam>\") : '').concat(m.emissiveMap ? \"<newparam sid=\\\"emissive-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(processTexture(m.emissiveMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"emissive-sampler\\\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>\") : '').concat(m.normalMap ? \"<newparam sid=\\\"bump-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(processTexture(m.normalMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"bump-sampler\\\"><sampler2D><source>bump-surface</source></sampler2D></newparam>\") : '').concat(techniqueNode).concat(m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : '', \"</profile_COMMON></effect>\");\n        var materialName = m.name ? \" name=\\\"\".concat(m.name, \"\\\"\") : '';\n        var materialNode = \"<material id=\\\"\".concat(matid, \"\\\"\").concat(materialName, \"><instance_effect url=\\\"#\").concat(matid, \"-effect\\\" /></material>\");\n        libraryMaterials.push(materialNode);\n        libraryEffects.push(effectnode);\n        materialMap.set(m, matid);\n      }\n\n      return matid;\n    } // Recursively process the object into a scene\n\n\n    function processObject(o) {\n      var node = \"<node name=\\\"\".concat(o.name, \"\\\">\");\n      node += getTransform(o);\n\n      if (o.isMesh === true && o.geometry !== null) {\n        // function returns the id associated with the mesh and a \"BufferGeometry\" version\n        // of the geometry in case it's not a geometry.\n        var geomInfo = processGeometry(o.geometry);\n        var meshid = geomInfo.meshid;\n        var geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n        var matids = null;\n        var matidsArray = []; // get a list of materials to bind to the sub groups of the geometry.\n        // If the amount of subgroups is greater than the materials, than reuse\n        // the materials.\n\n        var mat = o.material || new MeshBasicMaterial();\n        var materials = Array.isArray(mat) ? mat : [mat];\n\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n\n        matids = matidsArray.fill().map(function (v, i) {\n          return processMaterial(materials[i % materials.length]);\n        });\n        node += \"\".concat(\"<instance_geometry url=\\\"#\".concat(meshid, \"\\\">\") + (matids != null ? \"<bind_material><technique_common>\".concat(matids.map(function (id, i) {\n          return \"\".concat(\"<instance_material symbol=\\\"MESH_MATERIAL_\".concat(i, \"\\\" target=\\\"#\").concat(id, \"\\\" >\"), \"<bind_vertex_input semantic=\\\"TEXCOORD\\\" input_semantic=\\\"TEXCOORD\\\" input_set=\\\"0\\\" /></instance_material>\");\n        }).join(''), \"</technique_common></bind_material>\") : ''), \"</instance_geometry>\");\n      }\n\n      o.children.forEach(function (c) {\n        return node += processObject(c);\n      });\n      node += '</node>';\n      return node;\n    }\n\n    var geometryInfo = new WeakMap();\n    var materialMap = new WeakMap();\n    var imageMap = new WeakMap();\n    var textures = [];\n    var libraryImages = [];\n    var libraryGeometries = [];\n    var libraryEffects = [];\n    var libraryMaterials = [];\n    var libraryVisualScenes = processObject(object);\n    var specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    var dae = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\" ?>\".concat(\"<COLLADA xmlns=\\\"\".concat(specLink, \"\\\" version=\\\"\").concat(version, \"\\\">\"), \"<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>\", options.author !== null ? \"<author>\".concat(options.author, \"</author>\") : '', \"</contributor>\", \"<created>\".concat(new Date().toISOString(), \"</created>\"), \"<modified>\".concat(new Date().toISOString(), \"</modified>\"), \"<up_axis>Y_UP</up_axis></asset>\");\n    dae += \"<library_images>\".concat(libraryImages.join(''), \"</library_images>\");\n    dae += \"<library_effects>\".concat(libraryEffects.join(''), \"</library_effects>\");\n    dae += \"<library_materials>\".concat(libraryMaterials.join(''), \"</library_materials>\");\n    dae += \"<library_geometries>\".concat(libraryGeometries.join(''), \"</library_geometries>\");\n    dae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\".concat(libraryVisualScenes, \"</visual_scene></library_visual_scenes>\");\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    var res = {\n      data: format(dae),\n      textures: textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(function () {\n        return onDone(res);\n      });\n    }\n\n    return res;\n  }\n};\nexport { ColladaExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/ColladaExporter.js"],"names":["MeshBasicMaterial","Matrix4","Color","DoubleSide","ColladaExporter","prototype","constructor","parse","object","onDone","options","Object","assign","version","author","textureDirectory","replace","console","warn","format","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","match","map","tag","test","res","join","base64ToBuffer","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","canvas","ctx","imageToData","image","ext","document","createElement","getContext","width","height","drawImage","base64data","toDataURL","getFuncs","attrBufferToArray","attr","isInterleavedBufferAttribute","arr","array","count","itemSize","size","j","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","transMat","getTransform","o","updateMatrix","copy","matrix","transpose","toArray","processGeometry","g","info","geometryInfo","get","bufferGeometry","isBufferGeometry","Error","meshid","libraryGeometries","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","uv2","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageMap","libraryImages","imageNode","textures","directory","data","original","processMaterial","m","matid","materialMap","libraryEffects","isMeshLambertMaterial","isMeshBasicMaterial","emissive","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","materialName","materialNode","libraryMaterials","processObject","node","isMesh","geometry","geomInfo","matids","matidsArray","mat","material","materials","fill","v","id","children","forEach","c","WeakMap","libraryVisualScenes","specLink","dae","Date","toISOString","requestAnimationFrame"],"mappings":"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","sourcesContent":["import { MeshBasicMaterial, Matrix4, Color, DoubleSide } from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  var exporter = new ColladaExporter();\n *\n *  var data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nconst ColladaExporter = () => {};\n\nColladaExporter.prototype = {\n  constructor: ColladaExporter,\n  parse: function (object, onDone, options) {\n    options = options || {};\n    options = Object.assign({\n      version: '1.4.1',\n      author: null,\n      textureDirectory: ''\n    }, options);\n\n    if (options.textureDirectory !== '') {\n      options.textureDirectory = `${options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    const version = options.version;\n\n    if (version !== '1.4.1' && version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    } // Convert the urdf xml into a well-formatted, indented format\n\n\n    function format(urdf) {\n      const IS_END_TAG = /^<\\//;\n      const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n      const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n\n      let tagnum = 0;\n      return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(tag => {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n\n        const res = `${pad('  ', tagnum)}${tag}`;\n\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n\n        return res;\n      }).join('\\n');\n    } // Convert an image into a png format for saving\n\n\n    function base64ToBuffer(str) {\n      const b = atob(str);\n      const buf = new Uint8Array(b.length);\n\n      for (let i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n\n      return buf;\n    }\n\n    let canvas, ctx;\n\n    function imageToData(image, ext) {\n      canvas = canvas || document.createElement('canvas');\n      ctx = ctx || canvas.getContext('2d');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n      const base64data = canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n      return base64ToBuffer(base64data);\n    } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n    const getFuncs = ['getX', 'getY', 'getZ', 'getW'];\n\n    function attrBufferToArray(attr) {\n      if (attr.isInterleavedBufferAttribute) {\n        // use the typed array constructor to save on memory\n        const arr = new attr.array.constructor(attr.count * attr.itemSize);\n        const size = attr.itemSize;\n\n        for (let i = 0, l = attr.count; i < l; i++) {\n          for (let j = 0; j < size; j++) {\n            arr[i * size + j] = attr[getFuncs[j]](i);\n          }\n        }\n\n        return arr;\n      } else {\n        return attr.array;\n      }\n    } // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n\n\n    function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) return arr.slice(st, st + ct);else return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    } // Returns the string for a geometry's attribute\n\n\n    function getAttribute(attr, name, params, type) {\n      const array = attrBufferToArray(attr);\n      const res = `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>`;\n      return res;\n    } // Returns the string for a node's transform information\n\n\n    let transMat;\n\n    function getTransform(o) {\n      // ensure the object's matrix is up to date\n      // before saving the transform\n      o.updateMatrix();\n      transMat = transMat || new Matrix4();\n      transMat.copy(o.matrix);\n      transMat.transpose();\n      return `<matrix>${transMat.toArray().join(' ')}</matrix>`;\n    } // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n\n\n    function processGeometry(g) {\n      let info = geometryInfo.get(g);\n\n      if (!info) {\n        // convert the geometry to bufferGeometry if it isn't already\n        const bufferGeometry = g;\n\n        if (bufferGeometry.isBufferGeometry !== true) {\n          throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const meshid = `Mesh${libraryGeometries.length + 1}`;\n        const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        const gname = g.name ? ` name=\"${g.name}\"` : '';\n        let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n        const posName = `${meshid}-position`;\n        const vertName = `${meshid}-vertices`;\n        gnode += getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n        gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n        // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n        // models with attributes that share an offset.\n        // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n        // serialize normals\n\n        let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n\n        if ('normal' in bufferGeometry.attributes) {\n          const normName = `${meshid}-normal`;\n          gnode += getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n          triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n        } // serialize uvs\n\n\n        if ('uv' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord`;\n          gnode += getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n        } // serialize lightmap uvs\n\n\n        if ('uv2' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord2`;\n          gnode += getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n        } // serialize colors\n\n\n        if ('color' in bufferGeometry.attributes) {\n          const colName = `${meshid}-color`;\n          gnode += getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n          triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n        }\n\n        let indexArray = null;\n\n        if (bufferGeometry.index) {\n          indexArray = attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n\n          for (let i = 0, l = indexArray.length; i < l; i++) indexArray[i] = i;\n        }\n\n        for (let i = 0, l = groups.length; i < l; i++) {\n          const group = groups[i];\n          const subarr = subArray(indexArray, group.start, group.count);\n          const polycount = subarr.length / 3;\n          gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n          gnode += triangleInputs;\n          gnode += `<p>${subarr.join(' ')}</p>`;\n          gnode += '</triangles>';\n        }\n\n        gnode += '</mesh></geometry>';\n        libraryGeometries.push(gnode);\n        info = {\n          meshid,\n          bufferGeometry\n        };\n        geometryInfo.set(g, info);\n      }\n\n      return info;\n    } // Process the given texture into the image library\n    // Returns the image library\n\n\n    function processTexture(tex) {\n      let texid = imageMap.get(tex);\n\n      if (texid == null) {\n        texid = `image-${libraryImages.length + 1}`;\n        const ext = 'png';\n        const name = tex.name || texid;\n        let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n\n        if (version === '1.5.0') {\n          imageNode += `<init_from><ref>${options.textureDirectory}${name}.${ext}</ref></init_from>`;\n        } else {\n          // version image node 1.4.1\n          imageNode += `<init_from>${options.textureDirectory}${name}.${ext}</init_from>`;\n        }\n\n        imageNode += '</image>';\n        libraryImages.push(imageNode);\n        imageMap.set(tex, texid);\n        textures.push({\n          directory: options.textureDirectory,\n          name,\n          ext,\n          data: imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n\n      return texid;\n    } // Process the given material into the material and effect libraries\n    // Returns the material id\n\n\n    function processMaterial(m) {\n      let matid = materialMap.get(m);\n\n      if (matid == null) {\n        matid = `Mat${libraryEffects.length + 1}`;\n        let type = 'phong';\n\n        if (m.isMeshLambertMaterial === true) {\n          type = 'lambert';\n        } else if (m.isMeshBasicMaterial === true) {\n          type = 'constant';\n\n          if (m.map !== null) {\n            // The Collada spec does not support diffuse texture maps with the\n            // constant shader type.\n            // mrdoob/three.js#15469\n            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n          }\n        }\n\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n\n        if (m.transparent === true) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        libraryMaterials.push(materialNode);\n        libraryEffects.push(effectnode);\n        materialMap.set(m, matid);\n      }\n\n      return matid;\n    } // Recursively process the object into a scene\n\n\n    function processObject(o) {\n      let node = `<node name=\"${o.name}\">`;\n      node += getTransform(o);\n\n      if (o.isMesh === true && o.geometry !== null) {\n        // function returns the id associated with the mesh and a \"BufferGeometry\" version\n        // of the geometry in case it's not a geometry.\n        const geomInfo = processGeometry(o.geometry);\n        const meshid = geomInfo.meshid;\n        const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n        let matids = null;\n        let matidsArray = []; // get a list of materials to bind to the sub groups of the geometry.\n        // If the amount of subgroups is greater than the materials, than reuse\n        // the materials.\n\n        const mat = o.material || new MeshBasicMaterial();\n        const materials = Array.isArray(mat) ? mat : [mat];\n\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n\n        matids = matidsArray.fill().map((v, i) => processMaterial(materials[i % materials.length]));\n        node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n      }\n\n      o.children.forEach(c => node += processObject(c));\n      node += '</node>';\n      return node;\n    }\n\n    var geometryInfo = new WeakMap();\n    var materialMap = new WeakMap();\n    var imageMap = new WeakMap();\n    var textures = [];\n    var libraryImages = [];\n    var libraryGeometries = [];\n    var libraryEffects = [];\n    var libraryMaterials = [];\n    const libraryVisualScenes = processObject(object);\n    const specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${options.author !== null ? `<author>${options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: format(dae),\n      textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n\n    return res;\n  }\n};\n\nexport { ColladaExporter };\n"]},"metadata":{},"sourceType":"module"}