{"ast":null,"code":"/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\nvar DigitalGlitch = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    //diffuse texture\n    tDisp: {\n      value: null\n    },\n    //displacement texture for digital glitch squares\n    byp: {\n      value: 0\n    },\n    //apply the glitch ?\n    amount: {\n      value: 0.08\n    },\n    angle: {\n      value: 0.02\n    },\n    seed: {\n      value: 0.02\n    },\n    seed_x: {\n      value: 0.02\n    },\n    //-1,1\n    seed_y: {\n      value: 0.02\n    },\n    //-1,1\n    distortion_x: {\n      value: 0.5\n    },\n    distortion_y: {\n      value: 0.6\n    },\n    col_s: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform int byp;', //should we apply the glitch ?\n  'uniform sampler2D tDiffuse;', 'uniform sampler2D tDisp;', 'uniform float amount;', 'uniform float angle;', 'uniform float seed;', 'uniform float seed_x;', 'uniform float seed_y;', 'uniform float distortion_x;', 'uniform float distortion_y;', 'uniform float col_s;', 'varying vec2 vUv;', 'float rand(vec2 co){', '\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);', '}', 'void main() {', '\tif(byp<1) {', '\t\tvec2 p = vUv;', '\t\tfloat xs = floor(gl_FragCoord.x / 0.5);', '\t\tfloat ys = floor(gl_FragCoord.y / 0.5);', //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n  '\t\tvec4 normal = texture2D (tDisp, p*seed*seed);', '\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {', '\t\t\tif(seed_x>0.){', '\t\t\t\tp.y = 1. - (p.y + distortion_y);', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.y = distortion_y;', '\t\t\t}', '\t\t}', '\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {', '\t\t\tif(seed_y>0.){', '\t\t\t\tp.x=distortion_x;', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.x = 1. - (p.x + distortion_x);', '\t\t\t}', '\t\t}', '\t\tp.x+=normal.x*seed_x*(seed/5.);', '\t\tp.y+=normal.y*seed_y*(seed/5.);', //base from RGB shift shader\n  '\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\t\tvec4 cr = texture2D(tDiffuse, p + offset);', '\t\tvec4 cga = texture2D(tDiffuse, p);', '\t\tvec4 cb = texture2D(tDiffuse, p - offset);', '\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', //add noise\n  '\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);', '\t\tgl_FragColor = gl_FragColor+ snow;', '\t}', '\telse {', '\t\tgl_FragColor=texture2D (tDiffuse, vUv);', '\t}', '}'].join('\\n')\n};\nexport { DigitalGlitch };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/shaders/DigitalGlitch.js"],"names":["DigitalGlitch","uniforms","tDiffuse","value","tDisp","byp","amount","angle","seed","seed_x","seed_y","distortion_x","distortion_y","col_s","vertexShader","join","fragmentShader"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,aAAa,GAAG;AAClBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAE;AADC,KADF;AAIR;AACAC,IAAAA,KAAK,EAAE;AACLD,MAAAA,KAAK,EAAE;AADF,KALC;AAQR;AACAE,IAAAA,GAAG,EAAE;AACHF,MAAAA,KAAK,EAAE;AADJ,KATG;AAYR;AACAG,IAAAA,MAAM,EAAE;AACNH,MAAAA,KAAK,EAAE;AADD,KAbA;AAgBRI,IAAAA,KAAK,EAAE;AACLJ,MAAAA,KAAK,EAAE;AADF,KAhBC;AAmBRK,IAAAA,IAAI,EAAE;AACJL,MAAAA,KAAK,EAAE;AADH,KAnBE;AAsBRM,IAAAA,MAAM,EAAE;AACNN,MAAAA,KAAK,EAAE;AADD,KAtBA;AAyBR;AACAO,IAAAA,MAAM,EAAE;AACNP,MAAAA,KAAK,EAAE;AADD,KA1BA;AA6BR;AACAQ,IAAAA,YAAY,EAAE;AACZR,MAAAA,KAAK,EAAE;AADK,KA9BN;AAiCRS,IAAAA,YAAY,EAAE;AACZT,MAAAA,KAAK,EAAE;AADK,KAjCN;AAoCRU,IAAAA,KAAK,EAAE;AACLV,MAAAA,KAAK,EAAE;AADF;AApCC,GADQ;AAyClBW,EAAAA,YAAY,EAAE,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,YAAvC,EAAqD,4EAArD,EAAmI,GAAnI,EAAwIC,IAAxI,CAA6I,IAA7I,CAzCI;AA0ClBC,EAAAA,cAAc,EAAE,CAAC,kBAAD,EAAqB;AACrC,+BADgB,EACe,0BADf,EAC2C,uBAD3C,EACoE,sBADpE,EAC4F,qBAD5F,EACmH,uBADnH,EAC4I,uBAD5I,EACqK,6BADrK,EACoM,6BADpM,EACmO,sBADnO,EAC2P,mBAD3P,EACgR,sBADhR,EACwS,oEADxS,EAC8W,GAD9W,EACmX,eADnX,EACoY,cADpY,EACoZ,iBADpZ,EACua,2CADva,EACod,2CADpd,EACigB;AACjhB,mDAFgB,EAEmC,+DAFnC,EAEoG,mBAFpG,EAEyH,sCAFzH,EAEiK,MAFjK,EAEyK,WAFzK,EAEsL,yBAFtL,EAEiN,MAFjN,EAEyN,KAFzN,EAEgO,+DAFhO,EAEiS,mBAFjS,EAEsT,uBAFtT,EAE+U,MAF/U,EAEuV,WAFvV,EAEoW,sCAFpW,EAE4Y,MAF5Y,EAEoZ,KAFpZ,EAE2Z,mCAF3Z,EAEgc,mCAFhc,EAEqe;AACrf,2DAHgB,EAG2C,8CAH3C,EAG2F,sCAH3F,EAGmI,8CAHnI,EAGmL,kDAHnL,EAGuO;AACvP,4EAJgB,EAI4D,sCAJ5D,EAIoG,IAJpG,EAI0G,SAJ1G,EAIqH,2CAJrH,EAIkK,IAJlK,EAIwK,GAJxK,EAI6KD,IAJ7K,CAIkL,IAJlL;AA1CE,CAApB;AAiDA,SAASf,aAAT","sourcesContent":["/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\nvar DigitalGlitch = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    //diffuse texture\n    tDisp: {\n      value: null\n    },\n    //displacement texture for digital glitch squares\n    byp: {\n      value: 0\n    },\n    //apply the glitch ?\n    amount: {\n      value: 0.08\n    },\n    angle: {\n      value: 0.02\n    },\n    seed: {\n      value: 0.02\n    },\n    seed_x: {\n      value: 0.02\n    },\n    //-1,1\n    seed_y: {\n      value: 0.02\n    },\n    //-1,1\n    distortion_x: {\n      value: 0.5\n    },\n    distortion_y: {\n      value: 0.6\n    },\n    col_s: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform int byp;', //should we apply the glitch ?\n  'uniform sampler2D tDiffuse;', 'uniform sampler2D tDisp;', 'uniform float amount;', 'uniform float angle;', 'uniform float seed;', 'uniform float seed_x;', 'uniform float seed_y;', 'uniform float distortion_x;', 'uniform float distortion_y;', 'uniform float col_s;', 'varying vec2 vUv;', 'float rand(vec2 co){', '\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);', '}', 'void main() {', '\tif(byp<1) {', '\t\tvec2 p = vUv;', '\t\tfloat xs = floor(gl_FragCoord.x / 0.5);', '\t\tfloat ys = floor(gl_FragCoord.y / 0.5);', //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n  '\t\tvec4 normal = texture2D (tDisp, p*seed*seed);', '\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {', '\t\t\tif(seed_x>0.){', '\t\t\t\tp.y = 1. - (p.y + distortion_y);', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.y = distortion_y;', '\t\t\t}', '\t\t}', '\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {', '\t\t\tif(seed_y>0.){', '\t\t\t\tp.x=distortion_x;', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.x = 1. - (p.x + distortion_x);', '\t\t\t}', '\t\t}', '\t\tp.x+=normal.x*seed_x*(seed/5.);', '\t\tp.y+=normal.y*seed_y*(seed/5.);', //base from RGB shift shader\n  '\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\t\tvec4 cr = texture2D(tDiffuse, p + offset);', '\t\tvec4 cga = texture2D(tDiffuse, p);', '\t\tvec4 cb = texture2D(tDiffuse, p - offset);', '\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', //add noise\n  '\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);', '\t\tgl_FragColor = gl_FragColor+ snow;', '\t}', '\telse {', '\t\tgl_FragColor=texture2D (tDiffuse, vUv);', '\t}', '}'].join('\\n')\n};\n\nexport { DigitalGlitch };\n"]},"metadata":{},"sourceType":"module"}