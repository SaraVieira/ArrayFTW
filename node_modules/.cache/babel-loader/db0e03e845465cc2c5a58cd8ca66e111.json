{"ast":null,"code":"import { Loader, FileLoader, AnimationClip, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack } from 'three';\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nvar BVHLoader = function BVHLoader(manager) {\n  Loader.call(this, manager);\n  this.animateBonePositions = true;\n  this.animateBoneRotations = true;\n};\n\nBVHLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: BVHLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(text) {\n    /*\n    reads a string array (lines) from a BVH file\n    and outputs a skeleton structure including motion data\n    returns thee root node:\n    { name: '', channels: [], children: [] }\n    */\n    function readBvh(lines) {\n      // read model structure\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.');\n      }\n\n      var list = []; // collects flat array of all bones\n\n      var root = readNode(lines, nextLine(lines), list); // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.');\n      } // number of frames\n\n\n      var tokens = nextLine(lines).split(/[\\s]+/);\n      var numFrames = parseInt(tokens[1]);\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.');\n      } // frame time\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      var frameTime = parseFloat(tokens[2]);\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.');\n      } // read frame data line by line\n\n\n      for (var i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n\n      return list;\n    }\n    /*\n    Recursively reads data from a single frame into the bone hierarchy.\n    The passed bone hierarchy has to be structured in the same order as the BVH file.\n    keyframe data is stored in bone.frames.\n    - data: splitted string array (frame values), values are shift()ed so\n    this should be empty after parsing the whole hierarchy.\n    - frameTime: playback time for this keyframe.\n    - bone: the bone to read frame data from.\n    */\n\n\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n      if (bone.type === 'ENDSITE') return; // add keyframe\n\n      var keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      var quat = new Quaternion();\n      var vx = new Vector3(1, 0, 0);\n      var vy = new Vector3(0, 1, 0);\n      var vz = new Vector3(0, 0, 1); // parse values for each channel in node\n\n      for (var i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.');\n        }\n      } // parse child nodes\n\n\n      for (var _i = 0; _i < bone.children.length; _i++) {\n        readFrameData(data, frameTime, bone.children[_i]);\n      }\n    }\n    /*\n    Recursively parses the HIERACHY section of the BVH file\n    - lines: all lines of the file. lines are consumed as we go along.\n    - firstline: line containing the node type and name e.g. 'JOINT hip'\n    - list: collects a flat list of nodes\n    returns: a BVH node including children\n    */\n\n\n    function readNode(lines, firstline, list) {\n      var node = {\n        name: '',\n        type: '',\n        frames: []\n      };\n      list.push(node); // parse node type and name\n\n      var tokens = firstline.split(/[\\s]+/);\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE';\n        node.name = 'ENDSITE'; // bvh end sites have no name\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name');\n      } // parse OFFSET\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n      }\n\n      var offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n      }\n\n      node.offset = offset; // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/);\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n        }\n\n        var numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      } // read children\n\n\n      while (true) {\n        var line = nextLine(lines);\n\n        if (line === '}') {\n          return node;\n        } else {\n          node.children.push(readNode(lines, line, list));\n        }\n      }\n    }\n    /*\n    recursively converts the internal bvh node structure to a Bone hierarchy\n    source: the bvh root node\n    list: pass an empty array, collects a flat list of all converted THREE.Bones\n    returns the root Bone\n    */\n\n\n    function toTHREEBone(source, list) {\n      var bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n\n      if (source.type !== 'ENDSITE') {\n        for (var i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n\n      return bone;\n    }\n    /*\n    builds a AnimationClip from the keyframe data saved in each bone.\n    bone: bvh root node\n    returns: a AnimationClip containing position and quaternion tracks\n    */\n\n\n    function toTHREEAnimation(bones) {\n      var tracks = []; // create a position and quaternion animation track for each node\n\n      for (var i = 0; i < bones.length; i++) {\n        var bone = bones[i];\n        if (bone.type === 'ENDSITE') continue; // track data\n\n        var times = [];\n        var positions = [];\n        var rotations = [];\n\n        for (var j = 0; j < bone.frames.length; j++) {\n          var frame = bone.frames[j];\n          times.push(frame.time); // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks);\n    }\n    /*\n    returns the next non-empty line in lines\n    */\n\n\n    function nextLine(lines) {\n      var line; // skip empty lines\n\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line;\n    }\n\n    var scope = this;\n    var lines = text.split(/[\\r\\n]+/g);\n    var bones = readBvh(lines);\n    var threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    var threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n});\nexport { BVHLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/BVHLoader.js"],"names":["Loader","FileLoader","AnimationClip","Skeleton","Vector3","Quaternion","Bone","VectorKeyframeTrack","QuaternionKeyframeTrack","BVHLoader","manager","call","animateBonePositions","animateBoneRotations","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","readBvh","lines","nextLine","list","root","readNode","tokens","split","numFrames","parseInt","isNaN","frameTime","parseFloat","i","readFrameData","data","bone","type","keyframe","time","position","rotation","frames","push","quat","vx","vy","vz","channels","length","x","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","warn","children","firstline","node","name","toUpperCase","offset","numChannels","splice","line","toTHREEBone","source","add","toTHREEAnimation","bones","tracks","times","positions","rotations","j","frame","w","threeBones","threeClip","skeleton","clip"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,aAA7B,EAA4CC,QAA5C,EAAsDC,OAAtD,EAA+DC,UAA/D,EAA2EC,IAA3E,EAAiFC,mBAAjF,EAAsGC,uBAAtG,QAAqI,OAArI;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAUC,OAAV,EAAmB;AACjCV,EAAAA,MAAM,CAACW,IAAP,CAAY,IAAZ,EAAkBD,OAAlB;AACA,OAAKE,oBAAL,GAA4B,IAA5B;AACA,OAAKC,oBAAL,GAA4B,IAA5B;AACD,CAJD;;AAMAJ,SAAS,CAACK,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAcjB,MAAM,CAACc,SAArB,CAAd,EAA+C;AACnEI,EAAAA,WAAW,EAAET,SADsD;AAEnEU,EAAAA,IAAI,EAAE,cAAUC,GAAV,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,OAAnC,EAA4C;AAChD,QAAIC,KAAK,GAAG,IAAZ;AACA,QAAIC,MAAM,GAAG,IAAIxB,UAAJ,CAAeuB,KAAK,CAACd,OAArB,CAAb;AACAe,IAAAA,MAAM,CAACC,OAAP,CAAeF,KAAK,CAACG,IAArB;AACAF,IAAAA,MAAM,CAACG,gBAAP,CAAwBJ,KAAK,CAACK,aAA9B;AACAJ,IAAAA,MAAM,CAACK,kBAAP,CAA0BN,KAAK,CAACO,eAAhC;AACAN,IAAAA,MAAM,CAACN,IAAP,CAAYC,GAAZ,EAAiB,UAAUY,IAAV,EAAgB;AAC/B,UAAI;AACFX,QAAAA,MAAM,CAACG,KAAK,CAACS,KAAN,CAAYD,IAAZ,CAAD,CAAN;AACD,OAFD,CAEE,OAAOE,CAAP,EAAU;AACV,YAAIX,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACW,CAAD,CAAP;AACD,SAFD,MAEO;AACLC,UAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AAEDV,QAAAA,KAAK,CAACd,OAAN,CAAc2B,SAAd,CAAwBjB,GAAxB;AACD;AACF,KAZD,EAYGE,UAZH,EAYeC,OAZf;AAaD,GArBkE;AAsBnEU,EAAAA,KAAK,EAAE,eAAUD,IAAV,EAAgB;AACrB;AACJ;AACA;AACA;AACA;AACA;AACI,aAASM,OAAT,CAAiBC,KAAjB,EAAwB;AACtB;AACA,UAAIC,QAAQ,CAACD,KAAD,CAAR,KAAoB,WAAxB,EAAqC;AACnCJ,QAAAA,OAAO,CAACC,KAAR,CAAc,sCAAd;AACD;;AAED,UAAIK,IAAI,GAAG,EAAX,CANsB,CAMP;;AAEf,UAAIC,IAAI,GAAGC,QAAQ,CAACJ,KAAD,EAAQC,QAAQ,CAACD,KAAD,CAAhB,EAAyBE,IAAzB,CAAnB,CARsB,CAQ6B;;AAEnD,UAAID,QAAQ,CAACD,KAAD,CAAR,KAAoB,QAAxB,EAAkC;AAChCJ,QAAAA,OAAO,CAACC,KAAR,CAAc,mCAAd;AACD,OAZqB,CAYpB;;;AAGF,UAAIQ,MAAM,GAAGJ,QAAQ,CAACD,KAAD,CAAR,CAAgBM,KAAhB,CAAsB,OAAtB,CAAb;AACA,UAAIC,SAAS,GAAGC,QAAQ,CAACH,MAAM,CAAC,CAAD,CAAP,CAAxB;;AAEA,UAAII,KAAK,CAACF,SAAD,CAAT,EAAsB;AACpBX,QAAAA,OAAO,CAACC,KAAR,CAAc,mDAAd;AACD,OApBqB,CAoBpB;;;AAGFQ,MAAAA,MAAM,GAAGJ,QAAQ,CAACD,KAAD,CAAR,CAAgBM,KAAhB,CAAsB,OAAtB,CAAT;AACA,UAAII,SAAS,GAAGC,UAAU,CAACN,MAAM,CAAC,CAAD,CAAP,CAA1B;;AAEA,UAAII,KAAK,CAACC,SAAD,CAAT,EAAsB;AACpBd,QAAAA,OAAO,CAACC,KAAR,CAAc,6CAAd;AACD,OA5BqB,CA4BpB;;;AAGF,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+BK,CAAC,EAAhC,EAAoC;AAClCP,QAAAA,MAAM,GAAGJ,QAAQ,CAACD,KAAD,CAAR,CAAgBM,KAAhB,CAAsB,OAAtB,CAAT;AACAO,QAAAA,aAAa,CAACR,MAAD,EAASO,CAAC,GAAGF,SAAb,EAAwBP,IAAxB,CAAb;AACD;;AAED,aAAOD,IAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASW,aAAT,CAAuBC,IAAvB,EAA6BJ,SAA7B,EAAwCK,IAAxC,EAA8C;AAC5C;AACA,UAAIA,IAAI,CAACC,IAAL,KAAc,SAAlB,EAA6B,OAFe,CAEP;;AAErC,UAAIC,QAAQ,GAAG;AACbC,QAAAA,IAAI,EAAER,SADO;AAEbS,QAAAA,QAAQ,EAAE,IAAItD,OAAJ,EAFG;AAGbuD,QAAAA,QAAQ,EAAE,IAAItD,UAAJ;AAHG,OAAf;AAKAiD,MAAAA,IAAI,CAACM,MAAL,CAAYC,IAAZ,CAAiBL,QAAjB;AACA,UAAIM,IAAI,GAAG,IAAIzD,UAAJ,EAAX;AACA,UAAI0D,EAAE,GAAG,IAAI3D,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAT;AACA,UAAI4D,EAAE,GAAG,IAAI5D,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAT;AACA,UAAI6D,EAAE,GAAG,IAAI7D,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAT,CAb4C,CAab;;AAE/B,WAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,IAAI,CAACY,QAAL,CAAcC,MAAlC,EAA0ChB,CAAC,EAA3C,EAA+C;AAC7C,gBAAQG,IAAI,CAACY,QAAL,CAAcf,CAAd,CAAR;AACE,eAAK,WAAL;AACEK,YAAAA,QAAQ,CAACE,QAAT,CAAkBU,CAAlB,GAAsBlB,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAhC;AACA;;AAEF,eAAK,WAAL;AACEd,YAAAA,QAAQ,CAACE,QAAT,CAAkBa,CAAlB,GAAsBrB,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAhC;AACA;;AAEF,eAAK,WAAL;AACEd,YAAAA,QAAQ,CAACE,QAAT,CAAkBc,CAAlB,GAAsBtB,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAhC;AACA;;AAEF,eAAK,WAAL;AACER,YAAAA,IAAI,CAACW,gBAAL,CAAsBV,EAAtB,EAA0Bb,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAV,GAAkCI,IAAI,CAACC,EAAvC,GAA4C,GAAtE;AACAnB,YAAAA,QAAQ,CAACG,QAAT,CAAkBiB,QAAlB,CAA2Bd,IAA3B;AACA;;AAEF,eAAK,WAAL;AACEA,YAAAA,IAAI,CAACW,gBAAL,CAAsBT,EAAtB,EAA0Bd,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAV,GAAkCI,IAAI,CAACC,EAAvC,GAA4C,GAAtE;AACAnB,YAAAA,QAAQ,CAACG,QAAT,CAAkBiB,QAAlB,CAA2Bd,IAA3B;AACA;;AAEF,eAAK,WAAL;AACEA,YAAAA,IAAI,CAACW,gBAAL,CAAsBR,EAAtB,EAA0Bf,UAAU,CAACG,IAAI,CAACgB,KAAL,GAAaC,IAAb,EAAD,CAAV,GAAkCI,IAAI,CAACC,EAAvC,GAA4C,GAAtE;AACAnB,YAAAA,QAAQ,CAACG,QAAT,CAAkBiB,QAAlB,CAA2Bd,IAA3B;AACA;;AAEF;AACE3B,YAAAA,OAAO,CAAC0C,IAAR,CAAa,wCAAb;AA7BJ;AA+BD,OA/C2C,CA+C1C;;;AAGF,WAAK,IAAI1B,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGG,IAAI,CAACwB,QAAL,CAAcX,MAAlC,EAA0ChB,EAAC,EAA3C,EAA+C;AAC7CC,QAAAA,aAAa,CAACC,IAAD,EAAOJ,SAAP,EAAkBK,IAAI,CAACwB,QAAL,CAAc3B,EAAd,CAAlB,CAAb;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASR,QAAT,CAAkBJ,KAAlB,EAAyBwC,SAAzB,EAAoCtC,IAApC,EAA0C;AACxC,UAAIuC,IAAI,GAAG;AACTC,QAAAA,IAAI,EAAE,EADG;AAET1B,QAAAA,IAAI,EAAE,EAFG;AAGTK,QAAAA,MAAM,EAAE;AAHC,OAAX;AAKAnB,MAAAA,IAAI,CAACoB,IAAL,CAAUmB,IAAV,EANwC,CAMvB;;AAEjB,UAAIpC,MAAM,GAAGmC,SAAS,CAAClC,KAAV,CAAgB,OAAhB,CAAb;;AAEA,UAAID,MAAM,CAAC,CAAD,CAAN,CAAUsC,WAAV,OAA4B,KAA5B,IAAqCtC,MAAM,CAAC,CAAD,CAAN,CAAUsC,WAAV,OAA4B,MAArE,EAA6E;AAC3EF,QAAAA,IAAI,CAACzB,IAAL,GAAY,SAAZ;AACAyB,QAAAA,IAAI,CAACC,IAAL,GAAY,SAAZ,CAF2E,CAEpD;AACxB,OAHD,MAGO;AACLD,QAAAA,IAAI,CAACC,IAAL,GAAYrC,MAAM,CAAC,CAAD,CAAlB;AACAoC,QAAAA,IAAI,CAACzB,IAAL,GAAYX,MAAM,CAAC,CAAD,CAAN,CAAUsC,WAAV,EAAZ;AACD;;AAED,UAAI1C,QAAQ,CAACD,KAAD,CAAR,KAAoB,GAAxB,EAA6B;AAC3BJ,QAAAA,OAAO,CAACC,KAAR,CAAc,uDAAd;AACD,OApBuC,CAoBtC;;;AAGFQ,MAAAA,MAAM,GAAGJ,QAAQ,CAACD,KAAD,CAAR,CAAgBM,KAAhB,CAAsB,OAAtB,CAAT;;AAEA,UAAID,MAAM,CAAC,CAAD,CAAN,KAAc,QAAlB,EAA4B;AAC1BT,QAAAA,OAAO,CAACC,KAAR,CAAc,+CAA+CQ,MAAM,CAAC,CAAD,CAAnE;AACD;;AAED,UAAIA,MAAM,CAACuB,MAAP,KAAkB,CAAtB,EAAyB;AACvBhC,QAAAA,OAAO,CAACC,KAAR,CAAc,uDAAd;AACD;;AAED,UAAI+C,MAAM,GAAG,IAAI/E,OAAJ,CAAY8C,UAAU,CAACN,MAAM,CAAC,CAAD,CAAP,CAAtB,EAAmCM,UAAU,CAACN,MAAM,CAAC,CAAD,CAAP,CAA7C,EAA0DM,UAAU,CAACN,MAAM,CAAC,CAAD,CAAP,CAApE,CAAb;;AAEA,UAAII,KAAK,CAACmC,MAAM,CAACf,CAAR,CAAL,IAAmBpB,KAAK,CAACmC,MAAM,CAACZ,CAAR,CAAxB,IAAsCvB,KAAK,CAACmC,MAAM,CAACX,CAAR,CAA/C,EAA2D;AACzDrC,QAAAA,OAAO,CAACC,KAAR,CAAc,4CAAd;AACD;;AAED4C,MAAAA,IAAI,CAACG,MAAL,GAAcA,MAAd,CAvCwC,CAuClB;;AAEtB,UAAIH,IAAI,CAACzB,IAAL,KAAc,SAAlB,EAA6B;AAC3BX,QAAAA,MAAM,GAAGJ,QAAQ,CAACD,KAAD,CAAR,CAAgBM,KAAhB,CAAsB,OAAtB,CAAT;;AAEA,YAAID,MAAM,CAAC,CAAD,CAAN,KAAc,UAAlB,EAA8B;AAC5BT,UAAAA,OAAO,CAACC,KAAR,CAAc,gDAAd;AACD;;AAED,YAAIgD,WAAW,GAAGrC,QAAQ,CAACH,MAAM,CAAC,CAAD,CAAP,CAA1B;AACAoC,QAAAA,IAAI,CAACd,QAAL,GAAgBtB,MAAM,CAACyC,MAAP,CAAc,CAAd,EAAiBD,WAAjB,CAAhB;AACAJ,QAAAA,IAAI,CAACF,QAAL,GAAgB,EAAhB;AACD,OAnDuC,CAmDtC;;;AAGF,aAAO,IAAP,EAAa;AACX,YAAIQ,IAAI,GAAG9C,QAAQ,CAACD,KAAD,CAAnB;;AAEA,YAAI+C,IAAI,KAAK,GAAb,EAAkB;AAChB,iBAAON,IAAP;AACD,SAFD,MAEO;AACLA,UAAAA,IAAI,CAACF,QAAL,CAAcjB,IAAd,CAAmBlB,QAAQ,CAACJ,KAAD,EAAQ+C,IAAR,EAAc7C,IAAd,CAA3B;AACD;AACF;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;;;AAGI,aAAS8C,WAAT,CAAqBC,MAArB,EAA6B/C,IAA7B,EAAmC;AACjC,UAAIa,IAAI,GAAG,IAAIhD,IAAJ,EAAX;AACAmC,MAAAA,IAAI,CAACoB,IAAL,CAAUP,IAAV;AACAA,MAAAA,IAAI,CAACI,QAAL,CAAc+B,GAAd,CAAkBD,MAAM,CAACL,MAAzB;AACA7B,MAAAA,IAAI,CAAC2B,IAAL,GAAYO,MAAM,CAACP,IAAnB;;AAEA,UAAIO,MAAM,CAACjC,IAAP,KAAgB,SAApB,EAA+B;AAC7B,aAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,MAAM,CAACV,QAAP,CAAgBX,MAApC,EAA4ChB,CAAC,EAA7C,EAAiD;AAC/CG,UAAAA,IAAI,CAACmC,GAAL,CAASF,WAAW,CAACC,MAAM,CAACV,QAAP,CAAgB3B,CAAhB,CAAD,EAAqBV,IAArB,CAApB;AACD;AACF;;AAED,aAAOa,IAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;;AAGI,aAASoC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC/B,UAAIC,MAAM,GAAG,EAAb,CAD+B,CACd;;AAEjB,WAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,KAAK,CAACxB,MAA1B,EAAkChB,CAAC,EAAnC,EAAuC;AACrC,YAAIG,IAAI,GAAGqC,KAAK,CAACxC,CAAD,CAAhB;AACA,YAAIG,IAAI,CAACC,IAAL,KAAc,SAAlB,EAA6B,SAFQ,CAEE;;AAEvC,YAAIsC,KAAK,GAAG,EAAZ;AACA,YAAIC,SAAS,GAAG,EAAhB;AACA,YAAIC,SAAS,GAAG,EAAhB;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,IAAI,CAACM,MAAL,CAAYO,MAAhC,EAAwC6B,CAAC,EAAzC,EAA6C;AAC3C,cAAIC,KAAK,GAAG3C,IAAI,CAACM,MAAL,CAAYoC,CAAZ,CAAZ;AACAH,UAAAA,KAAK,CAAChC,IAAN,CAAWoC,KAAK,CAACxC,IAAjB,EAF2C,CAEnB;AACxB;;AAEAqC,UAAAA,SAAS,CAACjC,IAAV,CAAeoC,KAAK,CAACvC,QAAN,CAAeU,CAAf,GAAmBd,IAAI,CAAC6B,MAAL,CAAYf,CAA9C;AACA0B,UAAAA,SAAS,CAACjC,IAAV,CAAeoC,KAAK,CAACvC,QAAN,CAAea,CAAf,GAAmBjB,IAAI,CAAC6B,MAAL,CAAYZ,CAA9C;AACAuB,UAAAA,SAAS,CAACjC,IAAV,CAAeoC,KAAK,CAACvC,QAAN,CAAec,CAAf,GAAmBlB,IAAI,CAAC6B,MAAL,CAAYX,CAA9C;AACAuB,UAAAA,SAAS,CAAClC,IAAV,CAAeoC,KAAK,CAACtC,QAAN,CAAeS,CAA9B;AACA2B,UAAAA,SAAS,CAAClC,IAAV,CAAeoC,KAAK,CAACtC,QAAN,CAAeY,CAA9B;AACAwB,UAAAA,SAAS,CAAClC,IAAV,CAAeoC,KAAK,CAACtC,QAAN,CAAea,CAA9B;AACAuB,UAAAA,SAAS,CAAClC,IAAV,CAAeoC,KAAK,CAACtC,QAAN,CAAeuC,CAA9B;AACD;;AAED,YAAI1E,KAAK,CAACZ,oBAAV,EAAgC;AAC9BgF,UAAAA,MAAM,CAAC/B,IAAP,CAAY,IAAItD,mBAAJ,CAAwB,YAAY+C,IAAI,CAAC2B,IAAjB,GAAwB,YAAhD,EAA8DY,KAA9D,EAAqEC,SAArE,CAAZ;AACD;;AAED,YAAItE,KAAK,CAACX,oBAAV,EAAgC;AAC9B+E,UAAAA,MAAM,CAAC/B,IAAP,CAAY,IAAIrD,uBAAJ,CAA4B,YAAY8C,IAAI,CAAC2B,IAAjB,GAAwB,cAApD,EAAoEY,KAApE,EAA2EE,SAA3E,CAAZ;AACD;AACF;;AAED,aAAO,IAAI7F,aAAJ,CAAkB,WAAlB,EAA+B,CAAC,CAAhC,EAAmC0F,MAAnC,CAAP;AACD;AACD;AACJ;AACA;;;AAGI,aAASpD,QAAT,CAAkBD,KAAlB,EAAyB;AACvB,UAAI+C,IAAJ,CADuB,CACb;;AAEV,aAAO,CAACA,IAAI,GAAG/C,KAAK,CAAC8B,KAAN,GAAcC,IAAd,EAAR,EAA8BH,MAA9B,KAAyC,CAAhD,EAAmD,CAAE;;AAErD,aAAOmB,IAAP;AACD;;AAED,QAAI9D,KAAK,GAAG,IAAZ;AACA,QAAIe,KAAK,GAAGP,IAAI,CAACa,KAAL,CAAW,UAAX,CAAZ;AACA,QAAI8C,KAAK,GAAGrD,OAAO,CAACC,KAAD,CAAnB;AACA,QAAI4D,UAAU,GAAG,EAAjB;AACAZ,IAAAA,WAAW,CAACI,KAAK,CAAC,CAAD,CAAN,EAAWQ,UAAX,CAAX;AACA,QAAIC,SAAS,GAAGV,gBAAgB,CAACC,KAAD,CAAhC;AACA,WAAO;AACLU,MAAAA,QAAQ,EAAE,IAAIlG,QAAJ,CAAagG,UAAb,CADL;AAELG,MAAAA,IAAI,EAAEF;AAFD,KAAP;AAID;AArSkE,CAA/C,CAAtB;AAwSA,SAAS3F,SAAT","sourcesContent":["import { Loader, FileLoader, AnimationClip, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack } from 'three';\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nvar BVHLoader = function (manager) {\n  Loader.call(this, manager);\n  this.animateBonePositions = true;\n  this.animateBoneRotations = true;\n};\n\nBVHLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: BVHLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (text) {\n    /*\n    reads a string array (lines) from a BVH file\n    and outputs a skeleton structure including motion data\n    returns thee root node:\n    { name: '', channels: [], children: [] }\n    */\n    function readBvh(lines) {\n      // read model structure\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.');\n      }\n\n      var list = []; // collects flat array of all bones\n\n      var root = readNode(lines, nextLine(lines), list); // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.');\n      } // number of frames\n\n\n      var tokens = nextLine(lines).split(/[\\s]+/);\n      var numFrames = parseInt(tokens[1]);\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.');\n      } // frame time\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      var frameTime = parseFloat(tokens[2]);\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.');\n      } // read frame data line by line\n\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n\n      return list;\n    }\n    /*\n    Recursively reads data from a single frame into the bone hierarchy.\n    The passed bone hierarchy has to be structured in the same order as the BVH file.\n    keyframe data is stored in bone.frames.\n    - data: splitted string array (frame values), values are shift()ed so\n    this should be empty after parsing the whole hierarchy.\n    - frameTime: playback time for this keyframe.\n    - bone: the bone to read frame data from.\n    */\n\n\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n      if (bone.type === 'ENDSITE') return; // add keyframe\n\n      var keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      var quat = new Quaternion();\n      var vx = new Vector3(1, 0, 0);\n      var vy = new Vector3(0, 1, 0);\n      var vz = new Vector3(0, 0, 1); // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.');\n        }\n      } // parse child nodes\n\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i]);\n      }\n    }\n    /*\n    Recursively parses the HIERACHY section of the BVH file\n    - lines: all lines of the file. lines are consumed as we go along.\n    - firstline: line containing the node type and name e.g. 'JOINT hip'\n    - list: collects a flat list of nodes\n    returns: a BVH node including children\n    */\n\n\n    function readNode(lines, firstline, list) {\n      var node = {\n        name: '',\n        type: '',\n        frames: []\n      };\n      list.push(node); // parse node type and name\n\n      var tokens = firstline.split(/[\\s]+/);\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE';\n        node.name = 'ENDSITE'; // bvh end sites have no name\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name');\n      } // parse OFFSET\n\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n      }\n\n      var offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n      }\n\n      node.offset = offset; // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/);\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n        }\n\n        var numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      } // read children\n\n\n      while (true) {\n        var line = nextLine(lines);\n\n        if (line === '}') {\n          return node;\n        } else {\n          node.children.push(readNode(lines, line, list));\n        }\n      }\n    }\n    /*\n    recursively converts the internal bvh node structure to a Bone hierarchy\n    source: the bvh root node\n    list: pass an empty array, collects a flat list of all converted THREE.Bones\n    returns the root Bone\n    */\n\n\n    function toTHREEBone(source, list) {\n      var bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n\n      return bone;\n    }\n    /*\n    builds a AnimationClip from the keyframe data saved in each bone.\n    bone: bvh root node\n    returns: a AnimationClip containing position and quaternion tracks\n    */\n\n\n    function toTHREEAnimation(bones) {\n      var tracks = []; // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        var bone = bones[i];\n        if (bone.type === 'ENDSITE') continue; // track data\n\n        var times = [];\n        var positions = [];\n        var rotations = [];\n\n        for (let j = 0; j < bone.frames.length; j++) {\n          var frame = bone.frames[j];\n          times.push(frame.time); // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks);\n    }\n    /*\n    returns the next non-empty line in lines\n    */\n\n\n    function nextLine(lines) {\n      var line; // skip empty lines\n\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line;\n    }\n\n    var scope = this;\n    var lines = text.split(/[\\r\\n]+/g);\n    var bones = readBvh(lines);\n    var threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    var threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n});\n\nexport { BVHLoader };\n"]},"metadata":{},"sourceType":"module"}