{"ast":null,"code":"import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (var i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (var ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) {\n    matches.push(match);\n  }\n\n  for (var _i = 0; _i < matches.length; _i++) {\n    var match = matches[_i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (var keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (var i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/core/FunctionNode.js"],"names":["TempNode","NodeLib","declarationRegexp","propertiesRegexp","FunctionNode","src","includes","extensions","keywords","type","isMethod","undefined","isInterface","call","parse","prototype","Object","create","constructor","nodeType","useKeywords","getShared","getType","builder","getTypeByFormat","getInputByName","name","i","inputs","length","getIncludeByName","generate","output","match","offset","include","ext","matches","exec","push","prop","isGlobal","reference","containsKeyword","node","keyword","getKeywordData","cache","getKeyword","build","substring","index","contains","get","format","qualifier","indexOf","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","JSON","stringify","uuid"],"mappings":"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","sourcesContent":["import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\n\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (let i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (let ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) matches.push(match);\n\n  for (let i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (let keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (let i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };\n"]},"metadata":{},"sourceType":"module"}