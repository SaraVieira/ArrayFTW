{"ast":null,"code":"import { Vector3, Color, Vector2, Matrix3 } from 'three';\n\nvar OBJExporter = function OBJExporter() {};\n\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function parse(object) {\n    var output = '';\n    var indexVertex = 0;\n    var indexVertexUvs = 0;\n    var indexNormals = 0;\n    var vertex = new Vector3();\n    var color = new Color();\n    var normal = new Vector3();\n    var uv = new Vector2();\n    var i;\n    var j;\n    var k;\n    var l;\n    var m;\n    var face = [];\n\n    var parseMesh = function parseMesh(mesh) {\n      var nbVertex = 0;\n      var nbNormals = 0;\n      var nbVertexUvs = 0;\n      var geometry = mesh.geometry;\n      var normalMatrixWorld = new Matrix3();\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      var vertices = geometry.getAttribute('position');\n      var normals = geometry.getAttribute('normal');\n      var uvs = geometry.getAttribute('uv');\n      var indices = geometry.getIndex(); // name of the mesh object\n\n      output += \"o \".concat(mesh.name, \"\\n\"); // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n      } // vertices\n\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n        }\n      } // uvs\n\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += \"vt \".concat(uv.x, \" \").concat(uv.y, \"\\n\");\n        }\n      } // normals\n\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += \"vn \".concat(normal.x, \" \").concat(normal.y, \" \").concat(normal.z, \"\\n\");\n        }\n      } // faces\n\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? indexVertexUvs + j : '').concat(normals ? \"/\".concat(indexNormals + j) : '') : '');\n          } // transform the face to export format\n\n\n          output += \"f \".concat(face.join(' '), \"\\n\");\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? indexVertexUvs + j : '').concat(normals ? \"/\".concat(indexNormals + j) : '') : '');\n          } // transform the face to export format\n\n\n          output += \"f \".concat(face.join(' '), \"\\n\");\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    var parseLine = function parseLine(line) {\n      var nbVertex = 0;\n      var geometry = line.geometry;\n      var type = line.type;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      var vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += \"o \".concat(line.name, \"\\n\");\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n        }\n      }\n\n      if (type === 'Line') {\n        output += 'l ';\n\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += \"\".concat(indexVertex + j, \" \");\n        }\n\n        output += '\\n';\n      }\n\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += \"l \".concat(indexVertex + j, \" \").concat(indexVertex + k, \"\\n\");\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n    };\n\n    var parsePoints = function parsePoints(points) {\n      var nbVertex = 0;\n      var geometry = points.geometry;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      var vertices = geometry.getAttribute('position');\n      var colors = geometry.getAttribute('color');\n      output += \"o \".concat(points.name, \"\\n\");\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += \"v \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z);\n\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += \" \".concat(color.r, \" \").concat(color.g, \" \").concat(color.b);\n          }\n\n          output += '\\n';\n        }\n      }\n\n      output += 'p ';\n\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += \"\".concat(indexVertex + j, \" \");\n      }\n\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\nexport { OBJExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/OBJExporter.js"],"names":["Vector3","Color","Vector2","Matrix3","OBJExporter","prototype","constructor","parse","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","i","j","k","l","m","face","parseMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","join","parseLine","line","type","parsePoints","points","colors","fromBufferAttribute","r","g","b","traverse","child","isMesh","isLine","isPoints"],"mappings":"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","sourcesContent":["import { Vector3, Color, Vector2, Matrix3 } from 'three';\n\nconst OBJExporter = () => {};\n\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function (object) {\n    let output = '';\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let i;\n    let j;\n    let k;\n    let l;\n    let m;\n    const face = [];\n\n    const parseMesh = mesh => {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position');\n      const normals = geometry.getAttribute('normal');\n      const uvs = geometry.getAttribute('uv');\n      const indices = geometry.getIndex(); // name of the mesh object\n\n      output += `o ${mesh.name}\\n`; // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += `usemtl ${mesh.material.name}\\n`;\n      } // vertices\n\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      } // uvs\n\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += `vt ${uv.x} ${uv.y}\\n`;\n        }\n      } // normals\n\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += `vn ${normal.x} ${normal.y} ${normal.z}\\n`;\n        }\n      } // faces\n\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    const parseLine = line => {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += `o ${line.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      }\n\n      if (type === 'Line') {\n        output += 'l ';\n\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += `${indexVertex + j} `;\n        }\n\n        output += '\\n';\n      }\n\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += `l ${indexVertex + j} ${indexVertex + k}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n    };\n\n    const parsePoints = points => {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const vertices = geometry.getAttribute('position');\n      const colors = geometry.getAttribute('color');\n      output += `o ${points.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}`;\n\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += ` ${color.r} ${color.g} ${color.b}`;\n          }\n\n          output += '\\n';\n        }\n      }\n\n      output += 'p ';\n\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += `${indexVertex + j} `;\n      }\n\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\n\nexport { OBJExporter };\n"]},"metadata":{},"sourceType":"module"}