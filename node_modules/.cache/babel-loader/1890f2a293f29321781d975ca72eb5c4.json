{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\n\nfunction PhongNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.specular = new ColorNode(0x111111);\n  this.shininess = new FloatNode(30);\n}\n\nPhongNode.prototype = Object.create(Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\n\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif', //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [// prevent undeclared normal\n    '#include <normal_fragment_begin>', // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push( // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n\n    if (environment) {\n      output.push(environment.code);\n\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nPhongNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\n\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { PhongNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/materials/nodes/PhongNode.js"],"names":["UniformsUtils","UniformsLib","Node","ColorNode","FloatNode","PhongNode","call","color","specular","shininess","prototype","Object","create","constructor","nodeType","build","builder","code","define","requires","lights","isShader","position","analyzeAndFlow","cache","undefined","mergeUniform","merge","fog","addParsCode","join","output","push","result","mask","analyze","slot","alpha","normal","light","ao","ambient","shadow","emissive","environment","environmentAlpha","flow","transparent","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\n\nfunction PhongNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.specular = new ColorNode(0x111111);\n  this.shininess = new FloatNode(30);\n}\n\nPhongNode.prototype = Object.create(Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\n\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif', //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [// prevent undeclared normal\n    '#include <normal_fragment_begin>', // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push( // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n\n    if (environment) {\n      output.push(environment.code);\n\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nPhongNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\n\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { PhongNode };\n"]},"metadata":{},"sourceType":"module"}