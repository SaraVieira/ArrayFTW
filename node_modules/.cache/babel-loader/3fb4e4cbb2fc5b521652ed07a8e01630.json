{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nvar lwoTree;\n\nvar LWOLoader = function LWOLoader(manager, parameters) {\n  Loader.call(this, manager);\n  parameters = parameters || {};\n  this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n};\n\nLWOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: LWOLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    var modelName = url.split(path).pop().split('.')[0];\n    var loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n\n    }, onProgress, onError);\n  },\n  parse: function parse(iffBuffer, path, modelName) {\n    lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}); // Parse the lwoTree object\n\nfunction LWOTreeParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nLWOTreeParser.prototype = {\n  constructor: LWOTreeParser,\n  parse: function parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  },\n  parseLayers: function parseLayers() {\n    // array of all meshes for building hierarchy\n    var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    var finalMeshes = [];\n    var geometryParser = new GeometryParser();\n    var scope = this;\n    lwoTree.layers.forEach(function (layer) {\n      var geometry = geometryParser.parse(layer.geometry, layer);\n      var mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  },\n  parseMesh: function parseMesh(geometry, layer) {\n    var mesh;\n    var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  },\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots: function applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        var pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          var parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  },\n  getMaterials: function getMaterials(namesArray, type) {\n    var materials = [];\n    var scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        var spec = {\n          color: mat.color\n        };\n\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n\n    var filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  },\n  getMaterialByName: function getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  },\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs: function duplicateUVs(geometry, materials) {\n    var duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n};\n\nfunction MaterialParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nMaterialParser.prototype = {\n  constructor: MaterialParser,\n  parse: function parse() {\n    var materials = [];\n    this.textures = {};\n\n    for (var name in lwoTree.materials) {\n      if (lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(lwoTree.materials[name], name, lwoTree.textures));\n      } else if (lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(lwoTree.materials[name], name, lwoTree.textures));\n      }\n    }\n\n    return materials;\n  },\n  parseMaterial: function parseMaterial(materialData, name, textures) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var connections = this.parseConnections(materialData.connections, materialData.nodes);\n    var maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    var attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    var materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  },\n  parseMaterialLwo2: function parseMaterialLwo2(materialData, name\n  /*, textures*/\n  ) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  },\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide: function getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  },\n  getSmooth: function getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  },\n  parseConnections: function parseConnections(connections, nodes) {\n    var materialConnections = {\n      maps: {}\n    };\n    var inputName = connections.inputName;\n    var inputNodeName = connections.inputNodeName;\n    var nodeName = connections.nodeName;\n    var scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  },\n  getNodeByRefName: function getNodeByRefName(refName, nodes) {\n    for (var name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  },\n  parseTextureNodes: function parseTextureNodes(textureNodes) {\n    var maps = {};\n\n    for (var name in textureNodes) {\n      var node = textureNodes[name];\n      var path = node.fileName;\n      if (!path) return;\n      var texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  },\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps: function parseAttributeImageMaps(attributes, textures, maps) {\n    for (var name in attributes) {\n      var attribute = attributes[name];\n\n      if (attribute.maps) {\n        var mapData = attribute.maps[0];\n        var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  },\n  parseAttributes: function parseAttributes(attributes, maps) {\n    var params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else params.color = new Color();\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  },\n  parsePhysicalAttributes: function parsePhysicalAttributes(params, attributes\n  /*, maps*/\n  ) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  },\n  parseStandardAttributes: function parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  },\n  parsePhongAttributes: function parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  },\n  parseEnvMap: function parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      var envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else envMap.mapping = EquirectangularReflectionMapping;\n\n      maps.envMap = envMap;\n    }\n  },\n  // get texture defined at top level by its index\n  getTexturePathByIndex: function getTexturePathByIndex(index) {\n    var fileName = '';\n    if (!lwoTree.textures) return fileName;\n    lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  },\n  loadTexture: function loadTexture(path) {\n    if (!path) return null;\n    var texture;\n    texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  },\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType: function getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  },\n  getMaterialType: function getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n};\n\nfunction GeometryParser() {}\n\nGeometryParser.prototype = {\n  constructor: GeometryParser,\n  parse: function parse(geoData, layer) {\n    var geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // var userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  },\n  // split quads into tris\n  splitIndices: function splitIndices(indices, polygonDimensions) {\n    var remappedIndices = [];\n    var i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (var k = 0; k < dim; k++) {\n          remappedIndices.push(indices[i + k]);\n        }\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (var _k = 1; _k < dim - 1; _k++) {\n          remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  },\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups: function parseGroups(geometry, geoData) {\n    var tags = lwoTree.tags;\n    var matNames = [];\n    var elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    var indexNum = 0; // create new indices in numerical order\n\n    var indexPairs = {}; // original indices mapped to numerical indices\n\n    var prevMaterialIndex;\n    var prevStart = 0;\n    var currentCount = 0;\n\n    for (var i = 0; i < remappedIndices.length; i += 2) {\n      var materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        var currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n\n    if (geometry.groups.length > 0) {\n      var currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n    geometry.userData.matNames = matNames;\n  },\n  splitMaterialIndices: function splitMaterialIndices(polygonDimensions, indices) {\n    var remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (var k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  },\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs: function parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (var name in layer.uvs) {\n      var uvs = layer.uvs[name].uvs;\n      var uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  },\n  parseMorphTargets: function parseMorphTargets(geometry, layer) {\n    var num = 0;\n\n    for (var name in layer.morphTargets) {\n      var remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      var morphPoints = layer.morphTargets[name].points;\n      var morphIndices = layer.morphTargets[name].indices;\n      var type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/loaders/LWOLoader.js"],"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","lwoTree","LWOLoader","manager","parameters","call","resourcePath","undefined","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","length","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","value","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","prevStart","currentCount","materialIndex","currentIndex","addGroup","groups","remappedUVs","from","count","uvs","uvIndices","j","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\nvar lwoTree;\n\nvar LWOLoader = function (manager, parameters) {\n  Loader.call(this, manager);\n  parameters = parameters || {};\n  this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n};\n\nLWOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: LWOLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    var modelName = url.split(path).pop().split('.')[0];\n    var loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n\n    }, onProgress, onError);\n  },\n  parse: function (iffBuffer, path, modelName) {\n    lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}); // Parse the lwoTree object\n\nfunction LWOTreeParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nLWOTreeParser.prototype = {\n  constructor: LWOTreeParser,\n  parse: function (modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  },\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    var finalMeshes = [];\n    var geometryParser = new GeometryParser();\n    var scope = this;\n    lwoTree.layers.forEach(function (layer) {\n      var geometry = geometryParser.parse(layer.geometry, layer);\n      var mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  },\n\n  parseMesh(geometry, layer) {\n    var mesh;\n    var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  },\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        var pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          var parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  },\n\n  getMaterials(namesArray, type) {\n    var materials = [];\n    var scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        var spec = {\n          color: mat.color\n        };\n\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n\n    var filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  },\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  },\n\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    var duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n\n};\n\nfunction MaterialParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nMaterialParser.prototype = {\n  constructor: MaterialParser,\n  parse: function () {\n    var materials = [];\n    this.textures = {};\n\n    for (let name in lwoTree.materials) {\n      if (lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(lwoTree.materials[name], name, lwoTree.textures));\n      } else if (lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(lwoTree.materials[name], name, lwoTree.textures));\n      }\n    }\n\n    return materials;\n  },\n\n  parseMaterial(materialData, name, textures) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var connections = this.parseConnections(materialData.connections, materialData.nodes);\n    var maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    var attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    var materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  },\n\n  parseMaterialLwo2(materialData, name\n  /*, textures*/\n  ) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  },\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  },\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  },\n\n  parseConnections(connections, nodes) {\n    var materialConnections = {\n      maps: {}\n    };\n    var inputName = connections.inputName;\n    var inputNodeName = connections.inputNodeName;\n    var nodeName = connections.nodeName;\n    var scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  },\n\n  getNodeByRefName(refName, nodes) {\n    for (let name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  },\n\n  parseTextureNodes(textureNodes) {\n    var maps = {};\n\n    for (let name in textureNodes) {\n      var node = textureNodes[name];\n      var path = node.fileName;\n      if (!path) return;\n      var texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  },\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (let name in attributes) {\n      var attribute = attributes[name];\n\n      if (attribute.maps) {\n        var mapData = attribute.maps[0];\n        var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  },\n\n  parseAttributes(attributes, maps) {\n    var params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else params.color = new Color();\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  },\n\n  parsePhysicalAttributes(params, attributes\n  /*, maps*/\n  ) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  },\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  },\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  },\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      var envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else envMap.mapping = EquirectangularReflectionMapping;\n\n      maps.envMap = envMap;\n    }\n  },\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    var fileName = '';\n    if (!lwoTree.textures) return fileName;\n    lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  },\n\n  loadTexture(path) {\n    if (!path) return null;\n    var texture;\n    texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  },\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  },\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n\n};\n\nfunction GeometryParser() {}\n\nGeometryParser.prototype = {\n  constructor: GeometryParser,\n\n  parse(geoData, layer) {\n    var geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // var userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  },\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    var remappedIndices = [];\n    var i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  },\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    var tags = lwoTree.tags;\n    var matNames = [];\n    var elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    var indexNum = 0; // create new indices in numerical order\n\n    var indexPairs = {}; // original indices mapped to numerical indices\n\n    var prevMaterialIndex;\n    var prevStart = 0;\n    var currentCount = 0;\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      var materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        var currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n\n    if (geometry.groups.length > 0) {\n      var currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n    geometry.userData.matNames = matNames;\n  },\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    var remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  },\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (let name in layer.uvs) {\n      var uvs = layer.uvs[name].uvs;\n      var uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  },\n\n  parseMorphTargets(geometry, layer) {\n    var num = 0;\n\n    for (let name in layer.morphTargets) {\n      var remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      var morphPoints = layer.morphTargets[name].points;\n      var morphIndices = layer.morphTargets[name].indices;\n      var type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };\n"]},"metadata":{},"sourceType":"module"}