{"ast":null,"code":"import { InputNode } from '../core/InputNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction CubeTextureNode(value, uv, bias) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new ReflectNode();\n  this.bias = bias;\n}\n\nCubeTextureNode.prototype = Object.create(InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\n\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\n\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nCubeTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\n\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { CubeTextureNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/inputs/CubeTextureNode.js"],"names":["InputNode","ReflectNode","ColorSpaceNode","ExpressionNode","CubeTextureNode","value","uv","bias","call","shared","prototype","Object","create","constructor","nodeType","getTexture","builder","output","generate","uuid","cubetex","build","undefined","context","setTexture","code","include","isShader","ignoreCache","outputType","getType","addContext","colorSpace","fromDecoding","getTextureEncodingFromMap","input","parse","removeContext","format","copy","source","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":"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","sourcesContent":["import { InputNode } from '../core/InputNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction CubeTextureNode(value, uv, bias) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new ReflectNode();\n  this.bias = bias;\n}\n\nCubeTextureNode.prototype = Object.create(InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\n\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\n\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nCubeTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\n\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { CubeTextureNode };\n"]},"metadata":{},"sourceType":"module"}