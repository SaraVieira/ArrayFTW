{"ast":null,"code":"import _classCallCheck from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Projects/arrayftw/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, ShaderMaterial, SphereGeometry } from 'three';\n\nvar LightProbeHelper = /*#__PURE__*/function (_Mesh) {\n  _inherits(LightProbeHelper, _Mesh);\n\n  var _super = _createSuper(LightProbeHelper);\n\n  function LightProbeHelper(lightProbe, size) {\n    var _this;\n\n    _classCallCheck(this, LightProbeHelper);\n\n    _this.lightProbe = lightProbe;\n    _this.size = size;\n    var material = new ShaderMaterial({\n      type: 'LightProbeHelperMaterial',\n      uniforms: {\n        sh: {\n          value: _this.lightProbe.sh.coefficients\n        },\n        // by reference\n        intensity: {\n          value: _this.lightProbe.intensity\n        }\n      },\n      vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n      fragmentShader: ['#define RECIPROCAL_PI 0.318309886', 'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {', '\t// matrix is assumed to be orthogonal', '\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );', '}', '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf', 'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {', '\t// normal is assumed to have unit length', '\tfloat x = normal.x, y = normal.y, z = normal.z;', '\t// band 0', '\tvec3 result = shCoefficients[ 0 ] * 0.886227;', '\t// band 1', '\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;', '\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;', '\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;', '\t// band 2', '\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;', '\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;', '\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );', '\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;', '\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );', '\treturn result;', '}', 'uniform vec3 sh[ 9 ]; // sh coefficients', 'uniform float intensity; // light probe intensity', 'varying vec3 vNormal;', 'void main() {', '\tvec3 normal = normalize( vNormal );', '\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', '\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );', '\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;', '\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );', '}'].join('\\n')\n    });\n    var geometry = new SphereGeometry(1, 32, 16);\n    _this = _super.call(this, geometry, material);\n    _this.type = 'LightProbeHelper';\n\n    _this.onBeforeRender();\n\n    return _this;\n  }\n\n  _createClass(LightProbeHelper, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender() {\n      this.position.copy(this.lightProbe.position);\n      this.scale.set(1, 1, 1).multiplyScalar(this.size);\n      this.material.uniforms.intensity.value = this.lightProbe.intensity;\n    }\n  }]);\n\n  return LightProbeHelper;\n}(Mesh);\n\nexport { LightProbeHelper };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/helpers/LightProbeHelper.js"],"names":["Mesh","ShaderMaterial","SphereGeometry","LightProbeHelper","lightProbe","size","material","type","uniforms","sh","value","coefficients","intensity","vertexShader","join","fragmentShader","geometry","onBeforeRender","dispose","position","copy","scale","set","multiplyScalar"],"mappings":";;;;AAAA,SAASA,IAAT,EAAeC,cAAf,EAA+BC,cAA/B,QAAqD,OAArD;;IAEMC,gB;;;;;AACJ,4BAAYC,UAAZ,EAAwBC,IAAxB,EAA8B;AAAA;;AAAA;;AAC5B,UAAKD,UAAL,GAAkBA,UAAlB;AACA,UAAKC,IAAL,GAAYA,IAAZ;AACA,QAAMC,QAAQ,GAAG,IAAIL,cAAJ,CAAmB;AAClCM,MAAAA,IAAI,EAAE,0BAD4B;AAElCC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,EAAE,EAAE;AACFC,UAAAA,KAAK,EAAE,MAAKN,UAAL,CAAgBK,EAAhB,CAAmBE;AADxB,SADI;AAIR;AACAC,QAAAA,SAAS,EAAE;AACTF,UAAAA,KAAK,EAAE,MAAKN,UAAL,CAAgBQ;AADd;AALH,OAFwB;AAWlCC,MAAAA,YAAY,EAAE,CAAC,uBAAD,EAA0B,eAA1B,EAA2C,gDAA3C,EAA6F,4EAA7F,EAA2K,GAA3K,EAAgLC,IAAhL,CAAqL,IAArL,CAXoB;AAYlCC,MAAAA,cAAc,EAAE,CAAC,mCAAD,EAAsC,oEAAtC,EAA4G,wCAA5G,EAAsJ,4DAAtJ,EAAoN,GAApN,EAAyN,mEAAzN,EAA8R,yEAA9R,EAAyW,2CAAzW,EAAsZ,kDAAtZ,EAA0c,YAA1c,EAAwd,gDAAxd,EAA0gB,YAA1gB,EAAwhB,sDAAxhB,EAAglB,sDAAhlB,EAAwoB,sDAAxoB,EAAgsB,YAAhsB,EAA8sB,0DAA9sB,EAA0wB,0DAA1wB,EAAs0B,mEAAt0B,EAA24B,0DAA34B,EAAu8B,gEAAv8B,EAAygC,iBAAzgC,EAA4hC,GAA5hC,EAAiiC,0CAAjiC,EAA6kC,mDAA7kC,EAAkoC,uBAAloC,EAA2pC,eAA3pC,EAA4qC,sCAA5qC,EAAotC,sEAAptC,EAA4xC,0DAA5xC,EAAw1C,+DAAx1C,EAAy5C,oEAAz5C,EAA+9C,GAA/9C,EAAo+CD,IAAp+C,CAAy+C,IAAz+C;AAZkB,KAAnB,CAAjB;AAcA,QAAME,QAAQ,GAAG,IAAId,cAAJ,CAAmB,CAAnB,EAAsB,EAAtB,EAA0B,EAA1B,CAAjB;AACA,8BAAMc,QAAN,EAAgBV,QAAhB;AACA,UAAKC,IAAL,GAAY,kBAAZ;;AACA,UAAKU,cAAL;;AApB4B;AAqB7B;;;;WAED,mBAAU;AACR,WAAKD,QAAL,CAAcE,OAAd;AACA,WAAKZ,QAAL,CAAcY,OAAd;AACD;;;WAED,0BAAiB;AACf,WAAKC,QAAL,CAAcC,IAAd,CAAmB,KAAKhB,UAAL,CAAgBe,QAAnC;AACA,WAAKE,KAAL,CAAWC,GAAX,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwBC,cAAxB,CAAuC,KAAKlB,IAA5C;AACA,WAAKC,QAAL,CAAcE,QAAd,CAAuBI,SAAvB,CAAiCF,KAAjC,GAAyC,KAAKN,UAAL,CAAgBQ,SAAzD;AACD;;;;EAjC4BZ,I;;AAqC/B,SAASG,gBAAT","sourcesContent":["import { Mesh, ShaderMaterial, SphereGeometry } from 'three';\n\nclass LightProbeHelper extends Mesh {\n  constructor(lightProbe, size) {\n    this.lightProbe = lightProbe;\n    this.size = size;\n    const material = new ShaderMaterial({\n      type: 'LightProbeHelperMaterial',\n      uniforms: {\n        sh: {\n          value: this.lightProbe.sh.coefficients\n        },\n        // by reference\n        intensity: {\n          value: this.lightProbe.intensity\n        }\n      },\n      vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n      fragmentShader: ['#define RECIPROCAL_PI 0.318309886', 'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {', '\t// matrix is assumed to be orthogonal', '\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );', '}', '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf', 'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {', '\t// normal is assumed to have unit length', '\tfloat x = normal.x, y = normal.y, z = normal.z;', '\t// band 0', '\tvec3 result = shCoefficients[ 0 ] * 0.886227;', '\t// band 1', '\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;', '\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;', '\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;', '\t// band 2', '\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;', '\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;', '\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );', '\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;', '\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );', '\treturn result;', '}', 'uniform vec3 sh[ 9 ]; // sh coefficients', 'uniform float intensity; // light probe intensity', 'varying vec3 vNormal;', 'void main() {', '\tvec3 normal = normalize( vNormal );', '\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', '\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );', '\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;', '\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );', '}'].join('\\n')\n    });\n    const geometry = new SphereGeometry(1, 32, 16);\n    super(geometry, material);\n    this.type = 'LightProbeHelper';\n    this.onBeforeRender();\n  }\n\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n\n  onBeforeRender() {\n    this.position.copy(this.lightProbe.position);\n    this.scale.set(1, 1, 1).multiplyScalar(this.size);\n    this.material.uniforms.intensity.value = this.lightProbe.intensity;\n  }\n\n}\n\nexport { LightProbeHelper };\n"]},"metadata":{},"sourceType":"module"}