{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\n\nfunction SpriteNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.spherical = true;\n}\n\nSpriteNode.prototype = Object.create(Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\n\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n\n    output.push( // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n\n    if (this.spherical) {\n      output.push( // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n\n    output.push( // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n        alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n        color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    }),\n        output = [];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n\n  return output.join('\\n');\n};\n\nSpriteNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\n\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { SpriteNode };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/nodes/materials/nodes/SpriteNode.js"],"names":["UniformsUtils","UniformsLib","Node","ColorNode","SpriteNode","call","color","spherical","prototype","Object","create","constructor","nodeType","build","builder","output","define","requires","lights","transparent","alpha","undefined","isShader","position","analyzeAndFlow","cache","mergeUniform","merge","fog","addParsCode","join","push","code","result","addCode","mask","analyze","slot","flow","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","sourcesContent":["import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\n\nfunction SpriteNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.spherical = true;\n}\n\nSpriteNode.prototype = Object.create(Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\n\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n\n    output.push( // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n\n    if (this.spherical) {\n      output.push( // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n\n    output.push( // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n        alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n        color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    }),\n        output = [];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n\n  return output.join('\\n');\n};\n\nSpriteNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\n\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { SpriteNode };\n"]},"metadata":{},"sourceType":"module"}