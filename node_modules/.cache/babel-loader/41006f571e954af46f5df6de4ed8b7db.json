{"ast":null,"code":"/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nvar DRACOExporter = function DRACOExporter() {};\n\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function parse(object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n\n    var geometry = object.geometry;\n    var dracoEncoder = DracoEncoderModule();\n    var encoder = new dracoEncoder.Encoder();\n    var builder;\n    var dracoObject;\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (var i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n\n      if (options.exportNormals === true) {\n        var normals = geometry.getAttribute('normal');\n\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs === true) {\n        var uvs = geometry.getAttribute('uv');\n\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n\n    var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    var encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    var decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n    if (options.quantization !== undefined) {\n      for (var _i = 0; _i < 5; _i++) {\n        if (options.quantization[_i] !== undefined) {\n          encoder.SetAttributeQuantization(_i, options.quantization[_i]);\n        }\n      }\n    }\n\n    var length;\n\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n\n    var outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      outputData[_i2] = encodedData.GetValue(_i2);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\nexport { DRACOExporter };","map":{"version":3,"sources":["/Projects/arrayftw/node_modules/three-stdlib/exporters/DRACOExporter.js"],"names":["DRACOExporter","prototype","constructor","parse","object","options","isBufferGeometry","Error","DracoEncoderModule","undefined","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","Mesh","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC"],"mappings":"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","sourcesContent":["/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nconst DRACOExporter = () => {};\n\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function (object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n\n      if (options.exportNormals === true) {\n        const normals = geometry.getAttribute('normal');\n\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs === true) {\n        const uvs = geometry.getAttribute('uv');\n\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n\n    let length;\n\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n\n    const outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n\nexport { DRACOExporter };\n"]},"metadata":{},"sourceType":"module"}