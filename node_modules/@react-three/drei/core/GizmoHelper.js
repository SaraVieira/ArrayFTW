import { useContext, useRef, useState, createElement, createContext } from 'react';
import { Object3D, Matrix4, Quaternion, Vector3, Scene } from 'three';
import { useThree, useFrame, createPortal } from '@react-three/fiber';
import { OrthographicCamera } from './OrthographicCamera.js';
import { useCamera } from './useCamera.js';

const Context = /*#__PURE__*/createContext({});
const useGizmoContext = () => {
  return useContext(Context);
};
const turnRate = 2 * Math.PI; // turn rate in angles per second

const dummy = new Object3D();
const matrix = new Matrix4();
const [q1, q2] = [new Quaternion(), new Quaternion()];
const target = new Vector3();
const targetPosition = new Vector3();
const targetQuaternion = new Quaternion();
const GizmoHelper = ({
  alignment = 'bottom-right',
  margin = [80, 80],
  onUpdate,
  onTarget,
  children: GizmoHelperComponent
}) => {
  const size = useThree(({
    size
  }) => size);
  const mainCamera = useThree(({
    camera
  }) => camera);
  const gl = useThree(({
    gl
  }) => gl);
  const gizmoRef = useRef();
  const virtualCam = useRef(null);
  const [virtualScene] = useState(() => new Scene());
  const animating = useRef(false);
  const radius = useRef(0);
  const focusPoint = useRef(new Vector3(0, 0, 0));

  const tweenCamera = direction => {
    animating.current = true;
    focusPoint.current = onTarget();
    radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation

    dummy.position.copy(target);
    dummy.lookAt(mainCamera.position);
    q1.copy(dummy.quaternion); // To new current camera orientation

    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);
    dummy.lookAt(targetPosition);
    q2.copy(dummy.quaternion);
  };

  const animateStep = delta => {
    if (!animating.current) return;
    const step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere

    q1.rotateTowards(q2, step);
    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current); // animate orientation

    mainCamera.quaternion.rotateTowards(targetQuaternion, step);
    mainCamera.updateProjectionMatrix();
    onUpdate && onUpdate();

    if (q1.angleTo(q2) < 0.01) {
      animating.current = false;
    }
  };

  const beforeRender = () => {
    var _gizmoRef$current;

    // Sync gizmo with main camera orientation
    matrix.copy(mainCamera.matrix).invert();
    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);
  };

  useFrame((_, delta) => {
    if (virtualCam.current && gizmoRef.current) {
      animateStep(delta);
      beforeRender();
      gl.autoClear = false;
      gl.clearDepth();
      gl.render(virtualScene, virtualCam.current);
    }
  });
  const gizmoHelperContext = {
    tweenCamera,
    raycast: useCamera(virtualCam)
  }; // Position gizmo component within scene

  const [marginX, marginY] = margin;
  const x = alignment.endsWith('-left') ? -size.width / 2 + marginX : size.width / 2 - marginX;
  const y = alignment.startsWith('top-') ? size.height / 2 - marginY : -size.height / 2 + marginY;
  return createPortal( /*#__PURE__*/createElement(Context.Provider, {
    value: gizmoHelperContext
  }, /*#__PURE__*/createElement(OrthographicCamera, {
    ref: virtualCam,
    makeDefault: false,
    position: [0, 0, 100]
  }), /*#__PURE__*/createElement("group", {
    ref: gizmoRef,
    position: [x, y, 0]
  }, GizmoHelperComponent)), virtualScene);
};

export { GizmoHelper, useGizmoContext };
