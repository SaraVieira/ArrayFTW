import { forwardRef, useRef, useMemo, useState, createElement } from 'react';
import { Color, Vector3, Spherical, AdditiveBlending, ShaderMaterial } from 'three';
import { useFrame } from '@react-three/fiber';

class StarfieldMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader:
      /* glsl */
      "\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader:
      /* glsl */
      "\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    });
  }

}

const genStar = r => {
  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

const Stars = /*#__PURE__*/forwardRef(({
  radius = 100,
  depth = 50,
  count = 5000,
  saturation = 0,
  factor = 4,
  fade = false
}, ref) => {
  const material = useRef();
  const [position, color, size] = useMemo(() => {
    const positions = [];
    const colors = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color = new Color();
    let r = radius + depth;
    const increment = depth / count;

    for (let i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push(...genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, [count, depth, factor, radius, saturation]);
  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));
  const [starfieldMaterial] = useState(() => new StarfieldMaterial());
  return /*#__PURE__*/createElement("points", {
    ref: ref
  }, /*#__PURE__*/createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/createElement("primitive", {
    dispose: undefined,
    ref: material,
    object: starfieldMaterial,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

export { Stars };
