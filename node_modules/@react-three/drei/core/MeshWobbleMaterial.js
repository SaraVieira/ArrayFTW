import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { forwardRef, useState, createElement } from 'react';
import { MeshStandardMaterial } from 'three';
import { useFrame } from '@react-three/fiber';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';

class WobbleMaterialImpl extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_factor", void 0);

    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._factor = {
      value: 1
    };
  }

  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = "\n      uniform float time;\n      uniform float factor;\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  }

  get time() {
    return this._time.value;
  }

  set time(v) {
    this._time.value = v;
  }

  get factor() {
    return this._factor.value;
  }

  set factor(v) {
    this._factor.value = v;
  }

}

const MeshWobbleMaterial = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const [material] = useState(() => new WobbleMaterialImpl());
  useFrame(state => material && (material.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: material,
    ref: ref,
    attach: "material"
  }, props));
});

export { MeshWobbleMaterial };
